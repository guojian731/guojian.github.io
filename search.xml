<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[java多线程-wait、notify、notifyAll]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F07%2F16%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B-wait%E3%80%81notify%E3%80%81notifyAll%2F</url>
    <content type="text"><![CDATA[wait、notify、notifyAll难点前提首先是需要有共享变量，这个变量如果不满足条件，该线程执行wait()就会处于等待状态，但是这个变量不会永远处于不满足状态，当共享变量满足条件后，再将线程唤醒。wait()的作用就是将线程进行等待，notify()的作用就是唤醒一个被暂停的线程。 很显然，提到了共享变量，所以这个过程是原子性的，必须在synchronize修饰过的方法或者代码块中才能使用wait()。（也就是说，调用一个对象的wait方法，必须获得这个对象的内部锁） 在Object对象中，维护了一个因为该对象暂停的线程队列，该对象wait()的时候就会往队列里添加一个，notify()的时候就会唤醒其中一个线程。所以wait()、notify()在Object类里能更好的管理。 wait()方法会释放该对象的内部锁，试想一下，别人线程需要更改该对象(共享变量)的状态，首先需要获取该对象的锁，如果wait()方法不释放锁，其他线程又怎么能获得锁呢。（wait()方法暂停当前线程释放的锁只是wait对象所属对象的内部锁，当前线程持有的其他锁、显示锁并不会因此而释放）。 wait()方法并不是简单的释放锁、暂停线程就结束了。而是包括加入等待集，暂停当前线程、释放锁以及将唤醒后的等待线程从等待集中移除等，都是在Object.wait()中实现的。wait()伪代码： 1234567891011121314public void wait()&#123; atomic&#123;//原子操作开始 //释放当前内部锁 releaseLock(this); //暂停当前线程 block(Thread.currentThread());//语句1 &#125;//原子操作结束 //再次申请当前对象的内部锁 acquireLock(this);//语句2 //将当前线程从当前对象的等待中移除 removeFromWaitSet(Thread.currentThread()); return;//返回&#125; 等待线程在语句1执行的时候被暂停了。被唤醒的线程在其占用处理器继续运行的时候会继续执行其他暂停前调用的Object.wait()中的其他指令，即从上述代码中的语句2开始继续执行：先再次申请Object.wait()所属对象的内部锁，接着将当前线程从相应的等待线程中移除，然后Object.wait()调用才返回。 Object.wait()的执行线程会一直处于Waiting状态，知道通知线程唤醒该线程并且保护条件成立。因此，Object.wait()所实现的等待是无限等待，而Object.wait(long)允许我们指定一个超时时间，如果被暂停的等待线程在这个时间内没有被其他线程唤醒，那么Java虚拟机会自动唤醒该线程。不过Object.wait(long)即无返回值也不会抛出特定的异常，以便区分其返回是由于其他线程通知了当前线程还是由于等待超时。因为，使用Object.wai(long)的时候我们需要一些额外的处理。 wait()场景题1.现在有一个大的水桶100L，每三秒会有机器将水桶注满;有三个管道可以输出水，每个人都可以申请水0~100L,如果申请的水资源不够或者没有空余的管道，就需要等待。 Bucket，水桶类 12345678910111213141516171819202122232425262728293031323334353637383940414243public class Bucket&#123; private volatile AtomicInteger capacity=new AtomicInteger(100);//容量 private volatile AtomicInteger length=new AtomicInteger(3);//管道数 /** * 取水方法 * @param count * @throws InterruptedException */ public void takeWater(int count) throws InterruptedException &#123; synchronized (this)&#123; while (count&gt;capacity.get() || length.get()&lt;=0)&#123; System.out.println("无法获取水，取水数量："+count+"；当前容量："+capacity+"；当前管道数："+length); try &#123; this.wait(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("开始取水："+count+"；当前容量："+capacity+"；当前管道数："+length); length.decrementAndGet();//取水占用管道 capacity.addAndGet(-count);//取水占用容量 this.notify(); &#125; Thread.sleep(1000);//模拟取水的过程 length.incrementAndGet();//取完水之后放开管道 System.out.println("取水完成："+count+";当前容量："+capacity+";当前管道数："+length); &#125; public void inWater()&#123; synchronized (this)&#123; capacity.set(100); System.out.println("将水库的水填满"); this.notifyAll(); &#125; &#125; &#125; 取水的线程。123456789101112131415161718public class TakeWater implements Runnable&#123; private Bucket bucket; private int count; public TakeWater(Bucket reservoir,int count)&#123; this.bucket=reservoir; this.count=count; &#125; @Override public void run() &#123; try &#123; bucket.takeWater(count); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125; 注水的线程 123456789101112131415161718public class InWater implements Runnable&#123; private Bucket bucket; public InWater(Bucket reservoir)&#123; this.bucket=reservoir; &#125; @Override public void run() &#123; while (true)&#123; try &#123; Thread.sleep(3000); bucket.inWater(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 场景模拟：12345678910111213public class Client &#123; public static void main(String[] args) throws InterruptedException &#123; Bucket bucket=new Bucket(); Integer[] table=&#123;30,70,80,100&#125;; for (int i=0;i&lt;table.length;i++)&#123; Thread t2=new Thread(new TakeWater(bucket,table[i])); t2.start(); &#125; Thread t3=new Thread(new InWater(bucket)); t3.start(); &#125;&#125; 运行结果 12345678910111213141516开始取水：30；当前容量：100；当前管道数：3开始取水：70；当前容量：70；当前管道数：2无法获取水，取水数量：80；当前容量：0；当前管道数：1无法获取水，取水数量：100；当前容量：0；当前管道数：1取水完成：70;当前容量：0当前管道数;3取水完成：30;当前容量：0当前管道数;3将水库的水填满开始取水：100；当前容量：100；当前管道数：3无法获取水，取水数量：80；当前容量：0；当前管道数：2取水完成：100;当前容量：0当前管道数;3将水库的水填满开始取水：80；当前容量：100；当前管道数：3取水完成：80;当前容量：20当前管道数;3将水库的水填满将水库的水填满... wait/notify的开销问题 过早唤醒问题：现在有一个房地产开发商发放礼物，总共有十个柜台，如果柜台有空余的话，买房的人(vip)和没买房的人(normal)都可以领取礼物，当时一旦发放礼物的柜台都满的情况下，当空出柜台的时候，优先给vip办理，normal只能在没有vip等待的时候才能过去领取奖励。在这个时候，我们如果把每个人都换做线程的话，其实在这种排队的情况下，我们只需要唤醒vip用户，normal用户是不需要唤醒的，虽然我们可以拿程序进行判断，normal用户唤醒之后还会不满足条件继续等待，但是还会造成资源浪费。 欺骗性唤醒问题，等待线程也可能在没有其他任何线程的情况执行Object.notify()/Object.notify()下被唤醒，由于欺骗性唤醒的作用，等待线程没有任何线程对共享变量进行更新。可见，欺骗性唤醒也会导致过早唤醒。所以，在使用Object.wait()的时候，一定要放在一个魂环语句之中，欺骗性唤醒就不会对我们造成实际的影响。 wait/notify的问题根据刚才总结，发现wait()有两个比较明显的缺点，第一个就是，执行wait(long)的线程，我们不知道是超时之后自动被取消等待的，还是别的线程执行notify()方法来唤醒的。第二点，就是我们在过早唤醒的时候举个例子，我们唤醒了一些判断条件不符合的线程，最后它们还是会因为条件不满足而继续等待。那么这两个问题能否解决呢，使用java.util.concurrent.locks.Condition类可以解决这两个问题，不过他是配合ReentrantLock可冲入锁来使用的。]]></content>
      <tags>
        <tag>java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[每日一问-数据结构类]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F07%2F14%2F%E6%AF%8F%E6%97%A5%E4%B8%80%E9%97%AE-%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[HashMap问题Q：为什么HashMap的容量必须为2的n次方。 A： 1234static int indexFor(int h, int length) &#123; // assert Integer.bitCount(length) == 1 : "length must be a non-zero power of 2"; return h &amp; (length-1); &#125; 与运算：运算规则：0&amp;0=0;0&amp;1=0;1&amp;0=0;1&amp;1=1;即：两位同时为“1”，结果才为“1”，否则为0；hashMap是根据key的hashCode值进行处理之后的hash值，根据这个hash值来判断放入哪个槽里。为了数据可以均匀分布，我们一般都是取余，但是在计算机中取余的速度并没有与运算效率高,所以hashMap使用的是与运算，源码如下。2的n次方-1的二进制都是”1”,”11”,”111”,再进行与运算的时候数据可以均匀分布。我们分别将hash值设置0~20，map的容量分别设置为8和10，当length=8的时候为2的n次方为8的时候，数据排列是均匀的；当length等于10的时候，数组中下标为0，1，8，9存了很多的值，而其他的没有值，造成了数据严重的不均匀。 1234567public static void main(String[] args) &#123; int length=8; for (int hash=0;hash&lt;20;hash++)&#123; System.out.println("hash值："+hash +";与的值"+(hash &amp; (length-1))); &#125; &#125; length=8： 123456789101112131415161718192021hash值：0;与的值0hash值：1;与的值1hash值：2;与的值2hash值：3;与的值3hash值：4;与的值4hash值：5;与的值5hash值：6;与的值6hash值：7;与的值7hash值：8;与的值0hash值：9;与的值1hash值：10;与的值2hash值：11;与的值3hash值：12;与的值4hash值：13;与的值5hash值：14;与的值6hash值：15;与的值7hash值：16;与的值0hash值：17;与的值1hash值：18;与的值2hash值：19;与的值3 length=10: 123456789101112131415161718192021hash值：0;与的值0hash值：1;与的值1hash值：2;与的值0hash值：3;与的值1hash值：4;与的值0hash值：5;与的值1hash值：6;与的值0hash值：7;与的值1hash值：8;与的值8hash值：9;与的值9hash值：10;与的值8hash值：11;与的值9hash值：12;与的值8hash值：13;与的值9hash值：14;与的值8hash值：15;与的值9hash值：16;与的值0hash值：17;与的值1hash值：18;与的值0hash值：19;与的值1 Q：hashMap的key值可以为null吗？ A：可以，hashmap中判断key是否为null，如果为null，在为0的数组中，遍历链表，查找是否存在key值是有为null，有替换value，没有加上。 Q:hashMap（jdk1.7）数据量大的时候为什么效率不高？ A：因为当数据量庞大的时候，容量到了极限就无法扩容，导致数组中的链表长度过长，在put和get的时候需要遍历该下标下的所有链表并进行判断。 Q:hashMap在1.8进行了哪些优化 A： hash的算法上，获取key的hash值更加随机，并且在扩容上更有优势。 数据结构上来说1.7：是一个数组加链表的组合。1.8：是一个数组+链表+红黑树的组合，当链表长度&lt;=8的时候，依旧是使用数组，当链表长度&gt;8的时候，链表变成红黑树，这样容易数据的查找。 存储值的顺序上1.7：冲突的hash值会放在链表的头上，因为工程师认为新的key值用到的几率更大。1.8：冲突的hash值会放在链表的尾上(链表的长度是8以内，超过之后就变成红黑树了)。 扩容上1.7，1.8在扩容的时候，都需要新建一个之前容量*2的数组，但是1.7的每个key的值都需要重新运算hash值，而1.8扩容后的hash可以进行规律计算，极大减少了扩容的时间。另外，因为1.7采用的是头插法，在多线程中会出现逆序或者链表死循环的问题，而1.8在多线程中因为是尾插法，所以不会出现这种情况。但是，hashMap依旧是线程不安全的。 读取速度上数据量大的时候快的不是一星半点，1.7最坏的打算是需要算出数组下标之后，遍历了所有的元素。而1.8之后采用红黑树，在查询、删除、更新都有极大的优势。 Q:hashMap中的加载因子有什么用，hashMap如何扩容。 A：加载因子(loadFactor)默认值是0.75(loadFactor的值允许&gt;1)，它是给map设置一些空余空间，当loadFactor过低时，空间利用率小，但是查询效率高。当loadFactor过高时，空间利用率高，链表变长，查找效率变低。扩容阀值threshold=容量*加载因子，当容量为16，加载因子为0.75时，当map的size为13的时候就开始扩容了。 Q:如何使Map线程安全 A： 使用HashTable:确实可以使用HashTable来解决线程安全的问题，而且HashTable可以看做是另一种HashMap，因为HashTable虽然没有key值，但是是根据value的值计算出hash值，进行hashMap的操作的。但是HashTable保证线程安全使用的是synchronize，那么说在put和get的时候都会将整个表进行阻塞，所以效率非常低下。 Collections.synchronizedMap(map):这种方法是在put，和get的时候在在外面包了一层synchronized，保证了线程安全，实现方式跟HashTable很像。 123456public V put(K var1, V var2) &#123; Object var3 = this.mutex; synchronized(this.mutex) &#123; return this.m.put(var1, var2); &#125; &#125; ConcurrentHashMap: 1.7：ConcurrentHashMap的实现方式与1.7的hashMap核心思想多出一个Segment数组，每个数组都是一个HashEntry&lt;K,V&gt;[] table，相当于一个HashMap又根据hash分成了几部分。重要的是Segment继承了可重入锁ReentrantLock，这样相当于把HashMap分成了好几个部分，这样只是落入每个槽之内的key相互竞争。在put的时候，都需要先tryLock()申请锁，如果申请锁成功了，那么进行put操作。如果没有申请到锁，就进入scanAndLockForPut()方法，再方法里一直尝试tryLock()申请锁，如果超过64次没有申请到锁，那么就上锁，等待其他线程释放锁。注： tryLock():如果当前对象没锁，申请锁并返回ture；如果没锁，直接返回false。 缺点：因为1.7中ConcurrentHashMap分成了多个Segment，所以算总量的时候需要多个Segment的和。因为是高并发，所以他会使用不加锁的模式去尝试多次计算ConcurrentHashMap的size，最多三次，比较前后两次计算的结果，结果一致就认为当前没有元素加入，计算的结果是准确的；如果三次之外，将每个Segment加锁，算出结果。 1234567891011121314151617181920212223242526272829303132private HashEntry&lt;K,V&gt; scanAndLockForPut(K key, int hash, V value) &#123; HashEntry&lt;K,V&gt; first = entryForHash(this, hash); HashEntry&lt;K,V&gt; e = first; HashEntry&lt;K,V&gt; node = null; int retries = -1; // negative while locating node //一直在尝试申请锁 while (!tryLock()) &#123; HashEntry&lt;K,V&gt; f; // to recheck first below if (retries &lt; 0) &#123; if (e == null) &#123; if (node == null) // speculatively create node node = new HashEntry&lt;K,V&gt;(hash, key, value, null); retries = 0; &#125; else if (key.equals(e.key)) retries = 0; else e = e.next; &#125; else if (++retries &gt; MAX_SCAN_RETRIES) &#123; //超过申请次数，上锁，等待其他线程释放锁。 lock(); break; &#125; else if ((retries &amp; 1) == 0 &amp;&amp; (f = entryForHash(this, hash)) != first) &#123; e = first = f; // re-traverse if entry changed retries = -1; &#125; &#125; return node; &#125; 1.8 ConcurrentHashMap在1.8中的结构与HashMap中是一样的，都是数组+链表+红黑树组合，为了更好地并发，设置了int类型的标志位，当扩容或者或是扩容的时候，然后使用CAS技术，将标志位设置为-1，其他线程获取到-1的时候，就等待；在put的时候，使用synchronize锁住对象，保证数据的安全性。 注： 1.ConcurrentHashMap每次操作都会记录size值，而不是像1.7那样需要计算。 2.ConcurrentHashMap构造函数是一个空方法，初始化是在put()的时候。 3.put的时候，如果发现需要扩容，额外开启一个线程进行扩容，该线程等待map扩容，保证扩容的效率。]]></content>
      <tags>
        <tag>每日一问</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程-概念、难点汇总]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F07%2F11%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E6%A6%82%E5%BF%B5%E3%80%81%E9%9A%BE%E7%82%B9%E6%B1%87%E6%80%BB%2F</url>
    <content type="text"><![CDATA[线程创建的方式 继承Thread类 继承runnable接口 两种方式比较 面向对象编程：继承Thread类用的是继承技术，继承runnable接口是以Runaable接口实例为构造器参数直接通过new创建实例，是一种组合的技术。第二种方式类和类之间的耦合性更低，一般组合是优先选用的技术。 对象共享角度:第二种方式可以创建一个Runnable实例，多线程可以共享一个Runnable实例。而第一种方法不行。 从创建对象的角度：假如我们只是想单纯调用类中的方法，而第一种是创建线程，那么需要耗费更多的资源，我们新建第二种方式的对象就是普通的对象。 线程的安全性原子性我们在事务上经常能听到这个词，原子性的概念必须要依托于外界，就是该操作在外界看来是不可分割的，那么就是原子操作，该操作具有原子性。 double、long写操作不是原子性在32的系统下，double、long是线程不安全的，主要的原因是double和long是64位的，所以有一个转化的过程，所以double、long的写操作不是原子性的。除了double、long之外的其他基本类型(byte、boolean、short、char、float、int)的写操作都是原子性的。 为什么i++是线程不安全的？这就需要从原子性来讲，因为i++这个操作相当于取i的值，做+1运算，再将值做赋给i，这是一个整套的动作。但是这期间，别的线程也会读取i的值，所以i++不是原子性的，也就是线程不安全的。 原子性的保证：使用锁：保障一个共享变量在同一时间只允许一个线程进行访问，消除了竞态。使用CAS：实现的实质与锁是一样的，锁是在软件这一层次实现的，CAS直接在硬件（处理器和内存）这一层次实现的，所以被看做“硬件锁”。可见性在多线程的环境下，一个线程对某个共享变量进行更新的时候，后续访问该变量的线程可以无法立刻读取这个更新的结果，甚至永远无法读取到这个更新的结果。有序性重排序是对内存访问有关的操作（度和写）所做的优化，他可以在不影响单线程程序正确性的情况下提升程序的性能，但是在多线程的情况下可能会对正确性产生影响，可能导致线程安全的问题。 volatile关键字volatile关键字的作用：保障了可见性、有序性以及long、double型变量读写操作的原子性。之前说过，”long/double”的写操作在32位系统上不是原子性的，他可以保证”long/double”写操作的原子性。 实现原理：volatile变量不会被编译器分配到寄存器进行存储，读写操作都是内存访问(访问告诉缓存相当于主内存)操作。 voliate与锁的区别：volatile关键字会被称为轻量锁，它可以跟锁一样保证可见性和有序性，原子性上只能保障volatile写操作的原子性，但是没有锁的排他性(int中i++的问题);其次volatile关键字使用，不会引起上下文的切换。 volatile变量的开销：volatile变量的读写操作都不会引起上下文切换，volatile变量的开销要比锁要小。因为是放在内存中，所以volitile的写操作成本在于普通变量的写操作和在临界区内进行的写操作之间。读操作需要访问内存，而不是访问各自的寄存器，所以发挥不了访问的高效性。 CAS操作 CAS只能保障共享变量更新操作的原子性，他并不保障可见性。使用场景 之前我们想要保证i++的线程安全性来说，需要用synchronized，但是锁是非常消耗资源的，我们可以用CAS这种方式来解决”read-modify-write”的问题。 如何工作：CAS相当于一个管理人，它存储着共享变量V。如果一个线程像修改这个共享变量的值的时候，这时候线程需要将自己看见当前共享变量的值A，与V的值进行比较，如果相当，说明其他线程没有改过，然后将值改成B。如果发现A的值与V的值不一样了，说明了其他线程已经将这个值改过了，所以请求就失败了，通常失败了之后可以再次尝试，直到成功。 伪代码： 12345678boolean compareAndSwap(Variable V,Object A,Object B)&#123; if(A==V.get())&#123;//check:检查变量值是否被其他线程修改过 V.set(B);//act:更新变量值 return true;//更新成功 &#125; return false;//变量值已被其他线程修改，更新失败&#125; 注意！！！CAS只能保证共享变量更新操作的原子性，他并不保障可见性。所以需要在变量前使用volatile保证它的可见性。 Atomic家族的类都是根据CAS来实现变量的”read-modify-write”，他们都是共享变量更新操作的原子性，也保障可见性。]]></content>
      <tags>
        <tag>java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程-CompletionService、FutureTask]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F06%2F28%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B-CompletionService%E3%80%81FutureTask%2F</url>
    <content type="text"><![CDATA[CompletionService使用案例之前我们使用了线程池，发现线程池在多线程的使用上非常的好用，但是有一点弊端，是什么呢？我们来用代码看一下。我们现在有一个核心线程数是5个的线程池，现在一下来了6个任务，我们用Thread.sleep()来模拟中间运行时长，我们假设i%5==0的线程刚好发生网络延迟，需要10000ms，其他的线程很快，只需要1000ms。我们来看一下结果。 12345678910111213141516171819202122232425262728293031323334353637383940public class Test2 &#123; static ExecutorService executor= new ThreadPoolExecutor(5, 5, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue(20),new ThreadPoolExecutor.CallerRunsPolicy()); public static void main(String[] args) &#123; List&lt;Future&lt;String[]&gt;&gt; futureList=new ArrayList&lt;&gt;(); long start=System.currentTimeMillis(); for(int i=0;i&lt;6;i++)&#123; Future&lt;String[]&gt; future= executor.submit(new ThreadTest1(i)); futureList.add(future); &#125; for (Future&lt;String[]&gt; future:futureList)&#123; try &#123; System.out.println(future.get()[2]+"序号"+future.get()[0]+"实际处理时间:"+future.get()[1]+";实际所用时间："+(System.currentTimeMillis()-start)+"ms"); //获取到future之后的逻辑处理 //Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("总耗时:"+(System.currentTimeMillis()-start)+"ms"); &#125; static class ThreadTest1 implements Callable&lt;String[]&gt; &#123; private int num; public ThreadTest1(int num)&#123; this.num=num; &#125; @Override public String[] call() throws Exception &#123; if (num % 5==0)&#123; Thread.sleep(10000); return new String[]&#123;String.valueOf(num),String.valueOf(5000),Thread.currentThread().getName()&#125;; &#125;else &#123; Thread.sleep(1000); return new String[]&#123;String.valueOf(num),String.valueOf(1000),Thread.currentThread().getName()&#125;; &#125; &#125; &#125;&#125; 1234567pool-1-thread-1序号0实际处理时间:10000;实际所用时间：10002mspool-1-thread-2序号1实际处理时间:1000;实际所用时间：10002mspool-1-thread-3序号2实际处理时间:1000;实际所用时间：10002mspool-1-thread-4序号3实际处理时间:1000;实际所用时间：10002mspool-1-thread-5序号4实际处理时间:1000;实际所用时间：10002mspool-1-thread-2序号5实际处理时间:10000;实际所用时间：11001ms总耗时:11001ms 我们可以看到，其实线程2、3、4、5实际处理的时间都是1000ms，但是因为线程1的future最先进入futureList中，所以线程1的future.get()阻塞了其他的线程。当线程1的future.get()处理完之后，其他线程等待的线程立马可以获取结果了。而且我们看i=5时，会发现，其实线程4在处理完任务1000ms后返回future的值之后就立马返回线程池中，供其他请求使用，所以序号5的实际所用时间是11001ms而不是20000ms。这样看我们觉得没什么太大问题，因为这种情况只是结果阻塞，而线程并没有一起等待，还在实际工作中。但是我们现实生活中，经常会拿到结果future结果后再进行后续操作，假设操作时间为1000ms，我们把上面的Thread.sleep(1000);注释打开，再运行一下，我们使用了16s完成了所有的操作，仔细想一想，如果序号1、2、3、4执行完之后就进行业务处理，可以省下4s的时间，怎么样才能解决这个问题呢？ 1234567pool-1-thread-1序号0实际处理时间:10000;实际所用时间：10002mspool-1-thread-2序号1实际处理时间:1000;实际所用时间：11002mspool-1-thread-3序号2实际处理时间:1000;实际所用时间：12002mspool-1-thread-4序号3实际处理时间:1000;实际所用时间：13003mspool-1-thread-5序号4实际处理时间:1000;实际所用时间：14003mspool-1-thread-4序号5实际处理时间:10000;实际所用时间：15003ms总耗时:16004ms CompletionServiceCompletionService是一个接口，他的核心方法是:12345Future&lt;V&gt; take() throws InterruptedException; Future&lt;V&gt; poll(); Future&lt;V&gt; poll(long var1, TimeUnit var3) throws InterruptedException; 其中ExecutorCompletionService实现take()方法的时候，维护了一个队列，将已经处理完的结果放进队列里，取出来的时候按照该队列的顺序来进行，而不是之前的放进去的顺序。如果队列中没有数据，会进行阻塞。建立ExecutorCompletionService的时候我们要传入一个线程池。好了，我们将代码稍稍改变一下。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546public class Test11 &#123; static ExecutorService executor= Executors.newFixedThreadPool(5); static CompletionService&lt;String[]&gt; cService = new ExecutorCompletionService&lt;String[]&gt;(executor); public static void main(String[] args) &#123; for(int i=0;i&lt;6;i++)&#123; cService.submit(new ThreadTest1(i)); &#125; long start=System.currentTimeMillis(); for (int i=0;i&lt;6;i++)&#123; try &#123; Future&lt;String[]&gt; future= cService.take(); System.out.println(future.get()[2]+"线程"+future.get()[0]+"实际处理时间:"+future.get()[1]+";实际所用时间："+(System.currentTimeMillis()-start)+"ms"); //获取到future之后的逻辑处理 //Thread.sleep(1000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("总耗时:"+(System.currentTimeMillis()-start)+"ms"); &#125; static class ThreadTest1 implements Callable&lt;String[]&gt; &#123; private int num; public ThreadTest1(int num)&#123; this.num=num; &#125; @Override public String[] call() throws Exception &#123; if (num % 5==0)&#123; Thread.sleep(10000); return new String[]&#123;String.valueOf(num),String.valueOf(10000),Thread.currentThread().getName()&#125;; &#125;else &#123; Thread.sleep(1000); return new String[]&#123;String.valueOf(num),String.valueOf(1000),Thread.currentThread().getName()&#125;; &#125; &#125; &#125;&#125; 我们看到结果，先完成的结果在主线程进行处理了，不会因为没完成的future阻塞完成的future执行了，这样主线程的利用率就变的高效了。12345678pool-1-thread-4线程3实际处理时间:1000;实际所用时间：1000mspool-1-thread-3线程2实际处理时间:1000;实际所用时间：2001mspool-1-thread-2线程1实际处理时间:1000;实际所用时间：3002mspool-1-thread-5线程4实际处理时间:1000;实际所用时间：4003mspool-1-thread-1线程0实际处理时间:10000;实际所用时间：10000mspool-1-thread-2线程5实际处理时间:10000;实际所用时间：11001ms总耗时:12001ms FutureTask使用ExecutorService这个接口，我们需要不需要返回结果的时候,需要的参数必须继承Runnable接口。当我们需要返回结果的时候，必须需要继承Callable接口，而且又能继承future接口代表返回值。我们不能因为返回不返回的问题就继承两个接口，并且里面的核心代码一样吧？有什么解决办法吗？有，它就是FutureTask，他继承了Runnable接口和future接口，而且你可以传入参数Callable实现，他会转成Runnable接口的实现。 123456789101112public class DemoFuture implements Callable &#123; private int i; public DemoFuture(int i)&#123; this.i=i; &#125; @Override public String call() throws Exception &#123; System.out.println(i); return "执行的是:"+i; &#125;&#125; 123456public class Test1 &#123; static ExecutorService executor=Executors.newFixedThreadPool(10); public static void main(String[] args) &#123; executor.execute(new FutureTask&lt;&gt;(new DemoFuture(2))); &#125;&#125;]]></content>
      <tags>
        <tag>java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程3-线程池]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F06%2F13%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E6%B1%A0%2F</url>
    <content type="text"><![CDATA[为什么要用线程池？ 线程是一种昂贵的资源，其开销主要包括以下几个方面： 线程的创建与启动的开销。与普通的对象相比，Java线程还占用了额外的存储空间–栈空间。并且，线程的启动会产生相应的线程调度开销。线程的销毁,线程的销毁也有其开销。线程调度的开销。线程的调度会导致上下文切换，从而增加处理器资源的消耗，使得应用程序本身可以使用的处理器资源减少。一个系统能够穿件的线程总是受限于该系统所拥有的处理器数目，无论是CPU密集型还是I/O密集型线程，这些线程的数量的临界值总是处理器的数目。 因此，从整个系统乃至整个主机的角度来看，我们需要一种有效线程的方式。线程池就是有效使用线程的一种方式。 常见的对象池（比如数据库连接池）的实现方式是对象池（本身也是个对象）内部威虎一定数量的对象，客户端需要一个对象的时候就向对象池申请一个对象，用完之后再将该对象返还给对象池，于是对象池中的一个对象就可以先后为多个客户端线程服务。线程池本身也是一个对象，不过他的实现方式与普通的对象池不同，线程池内部可以预先创建一定数量的工作者线程，客户端代码并不需要向线程池借用线程而是将其需要执行的任务作为一个对象提交给线程池，线程池可能将这些任务缓存在队列（工作队列）中，而线程池内部的各个工作者线程则不断地从队列中去除任务并执行。因为，线程池可以看做给予生产者-消费者模式的一种服务，该服务内部维护的工作者线程相当于消费者线程，线程池的客户端线程相当于生产者线程，客户端代码提交给线程池的任务相当于”产品”,线程池内部用于缓存任务的队列相当于传输通道。 线程池的参数java.util.concurrent.ThreadPoolExecutor类就是一个线程池，客户端可以调用submit()或者execute()方法向其提交任务。 public ThreadPoolExecutor(int corePoolSize, int maximumPoolSize, long keepAliveTime, TimeUnit unit, BlockingQueue workQueue, ThreadFactory threadFactory, RejectedExecutionHandler handler) ; 线程池的有关线程的数量的变量总共有三个，当前的线程数量（currentPoolSize）表示线程中实际存在的工作者线程的数量。最大线程池的大小（maximumPoolSize）表示线程池中允许存在的最大线程池的数量。核心线程数（corePoolSize）表示一个不大于最大线程池大小的工作者线程数量上限。 workQueue:workQueue是被称为工作队列的阻塞队列，它相当于声场这-消费者模式中的传输通道。BlockingQueue是一个接口，在建立线程池中，可以用LinkedBlockingQueue和SynchronousQueue两个实现类，使用不同的实现类有着不同的效果。LinkedBlockingQueue是一个链表构成的队列，需要设置链表的长度，如果没有设置，默认为2147483647。 threadFactory指定用于创建工作者线程的线程工厂（比如你向让你创建的线程都有特色，比如是守护线程，优先级等，如果你的线程没有这么多限制的话，可以缺省它）。 keepAliveTime和unit共同组成了线程池中空闲线程的最大存活时间。 handler是我们现在需要介绍的。 参数例子12345678910111213public class RandomThread implements Callable&lt;String&gt; &#123; @Override public String call() &#123; Random rand = new Random(); int i=rand.nextInt(200)+1999; try &#123; Thread.sleep(i); &#125; catch (InterruptedException e) &#123; System.out.println("抛出了InterruptedException异常:"+e.getMessage()); &#125; return "这个线程执行了,i的值为："+i; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637public class Test &#123; static int length=20; static int corePoolSize=4; static int workQueue=10; final static int N_CPU =Runtime.getRuntime().availableProcessors(); final static ThreadPoolExecutor executor=new ThreadPoolExecutor(corePoolSize,N_CPU*2,5, TimeUnit.SECONDS,new ArrayBlockingQueue&lt;Runnable&gt;(workQueue),new ThreadPoolExecutor.CallerRunsPolicy()); public static void main(String[] args) &#123; int count=0; long start=System.currentTimeMillis(); List&lt;Future&gt; list =new ArrayList&lt;&gt;(length); for (int i=0;i&lt;length;i++)&#123; Future&lt;String&gt; future =executor.submit(new RandomThread()); list.add(future); &#125; System.out.println("futureList Size:"+list.size()); for (Future future:list)&#123; try &#123; String value=future.get(); System.out.println(value); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; &#125; System.out.println("完成所有"+length+"个任务之后线程数量为："+executor.getPoolSize()); System.out.println("所有任务完成耗时："+(System.currentTimeMillis()-start)); try &#123; Thread.sleep(6000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("完成任务6s后线程池的线程数量为："+executor.getPoolSize()); &#125;&#125; 这几个参数关联性非常高，注意，是”非常”，为什么这么强调呢，看我下面的解释。我们默认我们的线程池是新的，里面线程一个都没有，即当前线程数currentPoolSize=0.接下来我们在进行一些模拟，我将以corePoolSize代表核心线程数，workQueue代表等待的队列。keepAliveTime和unit组成线程空闲了5s就销毁。 【一】 1）corePoolSize=5，maximumPoolSize=8，workQueue为10，任务数为9 9个任务队列刚好能放在队列里，而且currentPoolSize&lt;corePoolSize,这个时候currentPoolSize就会涨到5，当线程完成任务后，连续5s都空闲的时候，会被检查，发现池内的线程数刚好等于corePoolSize，不会销毁。 12345678910111213futureList Size:9这个线程执行了,i的值为：2050...这个线程执行了,i的值为：2111完成所有9个任务之后线程数量为：5所有任务完成耗时：4290完成任务6s后线程池的线程数量为：5 2）corePoolSize=5，maximumPoolSize=8，workQueue为10，任务数为2 2个任务可以存储到队列里，而且currentPoolSize&lt;corePoolSize,这个时候currentPoolSize就会涨到2，当线程完成任务之后，连续5s都空闲，被检测，发现线程数不超过5个，进行保留，不销毁。 12345futureList Size:2这个线程执行了,i的值为：2068这个线程执行了,i的值为：2151完成所有2个任务之后线程数量为：2所有任务完成耗时：2153 3）corePoolSize=5，maximumPoolSize=8，workQueue为10，任务数为17 当17个任务数&gt;corePoolSize(5)+workQueue(10),当前线程数=17-10=7,当线程完成任务后，连续5s后空闲后，发现maximumPoolSize&gt;corePoolSize,所以线程数降到5个，剩下的3个进行销毁。 1234567futureList Size:17这个线程执行了,i的值为：2166...这个线程执行了,i的值为：2150完成所有17个任务之后线程数量为：7所有任务完成耗时：6352完成任务6s后线程池的线程数量为：5 4）corePoolSize=5，maximumPoolSize=8，workQueue为10，任务数为20 当20个任务数&gt;corePoolSize(5)+workQueue(10),因为20-10=10&gt;8,所以当前线程数=8,当线程完成任务后，连续5s后空闲后，发现maximumPoolSize&gt;corePoolSize,所以线程数降到5个，剩下的3个进行销毁。 1234567futureList Size:20这个线程执行了,i的值为：2002...这个线程执行了,i的值为：2101完成所有20个任务之后线程数量为：8所有任务完成耗时：6251完成任务6s后线程池的线程数量为：5 5）corePoolSize=0，maximumPoolSize=8，workQueue为100，任务数为20 因为任务数&lt;100,并且corePoolSize=0，所以currentPoolSize=1，无法建立新的线程，那么这20个任务只能串行执行。当任务都执行过后5s后，当前线程池的数量是1，要销毁变成0。我们看一下任务耗时，也可以看出来相当于10个任务串行执行。 1234567futureList Size:20这个线程执行了,i的值为：2163...这个线程执行了,i的值为：2068完成所有20个任务之后线程数量为：1所有任务完成耗时：42416完成任务6s后线程池的线程数量为：0 6）corePoolSize=0，maximumPoolSize=8，workQueue为10，任务数为30 30个任务数无法存储到队列，这时候currentPoolSize会涨到8，执行完过后5s后，当前线程数为8，如果都空闲，就会都销毁。 1234567futureList Size:30这个线程执行了,i的值为：2001...这个线程执行了,i的值为：2143完成所有30个任务之后线程数量为：8所有任务完成耗时：8384完成任务6s后线程池的线程数量为：0 【二】为什么我们要使用【一】、【二】来讲例子分开，因为一的时候，我们建立的线程池workQueue都是使用的ArrayBlockingQueue，拒绝策略使用的都是CallerRunsPolicy(在客户端线程中执行被拒绝的任务)。我们看一下下面的表格，就可以了解拒绝策略了。之前我们使用的都是超过ThreadPoolExecutor.CallerRunsPolicy，在客户端线程中执行被拒绝的任务。 7）同样我们将4）(corePoolSize=5，maximumPoolSize=8，workQueue为10，任务数为20)其他参数都不变，因为20&gt;8+10的，所以会用到拒绝策略，将拒绝策略改成ThreadPoolExecutor.DiscardPolicy(丢弃当前被拒绝的任务（不抛出异常）)。12345678910111213141516171819futureList Size:20这个线程执行了,i的值为：1999这个线程执行了,i的值为：2051这个线程执行了,i的值为：2066这个线程执行了,i的值为：2111这个线程执行了,i的值为：2113这个线程执行了,i的值为：2144这个线程执行了,i的值为：2156这个线程执行了,i的值为：2193这个线程执行了,i的值为：2099这个线程执行了,i的值为：2196这个线程执行了,i的值为：2160这个线程执行了,i的值为：2123这个线程执行了,i的值为：2126这个线程执行了,i的值为：2185这个线程执行了,i的值为：2176这个线程执行了,i的值为：2144这个线程执行了,i的值为：2125这个线程执行了,i的值为：2186 如果你试着数一下，会发现被执行的线程是18个，也就是说20-10-8=2，两个线程被丢弃了。问题就这样过去了吗？？！！不是的，注意看我们的代码，正常走完整段代码是要输出完成之后的线程数、所用时间以及6s后的线程数量的。没有输出，说明我们这段代码出问题了！！出在哪呢，就是future.get();方法是阻塞的，它需要接到所有20的结果的时候才会继续向下运行，可是我们有两个线程还没有被处理就被丢弃了，无法返回值了。这样future.get();就会一直阻塞 所以在这个时候，我们这种时间限制的等待是不现实的，也是毫无意义的。这个时候我们需要用到另外一个版本，future.get(long timeout,TimeUnit unit)。 我们可以指定一个时间，如果再这个时间内任务无法执行就抛出TimeoutException。 12345678910111213141516171819202122232425262728futureList Size:20这个线程执行了,i的值为：2002这个线程执行了,i的值为：2017这个线程执行了,i的值为：2065这个线程执行了,i的值为：2069这个线程执行了,i的值为：2070这个线程执行了,i的值为：2099这个线程执行了,i的值为：2182这个线程执行了,i的值为：2195这个线程执行了,i的值为：2014这个线程执行了,i的值为：2069这个线程执行了,i的值为：2132这个线程执行了,i的值为：2096这个线程执行了,i的值为：2123这个线程执行了,i的值为：2102这个线程执行了,i的值为：2140这个线程执行了,i的值为：2172这个线程执行了,i的值为：2049这个线程执行了,i的值为：2027java.util.concurrent.TimeoutException at java.util.concurrent.FutureTask.get(FutureTask.java:205) at kjava.Test.main(Test.java:25)java.util.concurrent.TimeoutException完成所有20个任务之后线程数量为：5 at java.util.concurrent.FutureTask.get(FutureTask.java:205)所有任务完成耗时：12168 at kjava.Test.main(Test.java:25)完成任务6s后线程池的线程数量为：5 根据结果我们可以看到，我们捕获了两个超时异常，方法继续的向下运行了。所以在平时的使用中，还是推荐使用带future.get(long timeout,TimeUnit unit)避免一直阻塞。（注：现在看到”完成所有20个任务之后线程数量为：5”，因为future.get()导致线程阻塞超过6s，所以部分的线程已经被回收掉了。） 8）在我们将future.get()改成future.get(3,TimeUnit.SECONDS)后，拒绝策略改成ThreadPoolExecutor.AbortPolicy(直接抛出异常)。其他还是(corePoolSize=5，maximumPoolSize=8，workQueue为10，任务数为20)。 123456789Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@12a3a380 rejected from java.util.concurrent.ThreadPoolExecutor@29453f44[Running, pool size = 8, active threads = 8, queued tasks = 10, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379) at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) at kjava.Test.main(Test.java:20) 我们发现除了异常什么都没有，那是因为在for循环的时候，之前的18个都运行了，第19个线程才会抛出异常，因为抛出异常之后，主线程结束，不再继续运行了，所以连futureList的容量都没有打印。我们在线程RandomThread的call()函数上添加System.out.println(“this is thread :”+i);再看一遍。 123456789101112131415161718192021222324252627Exception in thread "main" java.util.concurrent.RejectedExecutionException: Task java.util.concurrent.FutureTask@12a3a380 rejected from java.util.concurrent.ThreadPoolExecutor@29453f44[Running, pool size = 8, active threads = 8, queued tasks = 10, completed tasks = 0] at java.util.concurrent.ThreadPoolExecutor$AbortPolicy.rejectedExecution(ThreadPoolExecutor.java:2063) at java.util.concurrent.ThreadPoolExecutor.reject(ThreadPoolExecutor.java:830) at java.util.concurrent.ThreadPoolExecutor.execute(ThreadPoolExecutor.java:1379) at java.util.concurrent.AbstractExecutorService.submit(AbstractExecutorService.java:134) at kjava.Test.main(Test.java:20)this is thread :2167this is thread :2143this is thread :2155this is thread :2011this is thread :2013this is thread :2088this is thread :2027this is thread :2033this is thread :2071this is thread :2117this is thread :2100this is thread :2142this is thread :2036this is thread :2138this is thread :2093this is thread :2127this is thread :2151this is thread :2020 发现果然还是如此，18个线程完成了他们的任务，只是主线程异常结束了，无法再调用future.get()并输出了，才使他们看起来像都没运行的假像。在运行19个时候报了RejectedExecutionException异常，那我们捕获它，才能让我们的项目进行正常的运转。 123456789for (int i=0;i&lt;length;i++)&#123; try &#123; Future&lt;String&gt; future =executor.submit(new RandomThread()); list.add(future); &#125;catch (RejectedExecutionException e)&#123; System.out.println("catch 到了 RejectedExecutionException异常 "); &#125; &#125; 修改后，我们再看一看结果。因为抛出异常之后，无法加入futureList中，所以futureList一直为18，如果用到ThreadPoolExecutor.AbortPolicy(直接抛出异常)策略的话，可以根据catch RejectedExecutionException进行逻辑判断。 12345678910111213catch 到了 RejectedExecutionException异常 catch 到了 RejectedExecutionException异常 futureList Size:18this is thread :2186this is thread :2134...这个线程执行了,i的值为：2045这个线程执行了,i的值为：2086完成所有20个任务之后线程数量为：8所有任务完成耗时：6216完成任务6s后线程池的线程数量为：5 Executors下的线程池concurrent包为我们提供一些我们建立线程池的方法，在idea上使用阿里巴巴插件公约的时候，会提示我们应该手动的建立线程池，而不应该使用Executors。这是因为每个项目的使用线程池的场景都不一样，没有那个线程池是最优的，只有最适合自己的。我们手动建立线程池，同时Executors参数设置看看想想他们使用的场景。 newCachedThreadPool()123public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, 2147483647, 60L, TimeUnit.SECONDS, new SynchronousQueue());&#125; 我们可以看到核心线程数为0，最大线程数为2147483647(Integer最大值)。阻塞队列时new SynchronousQueue()，我们可以理解SynchronousQueue容量为0的队列。所以当大量请求来的时候，没有阻塞队列缓冲，来了就会创建线程。如果线程非常多，就会创造非常多的线程，这样会OOM。而且如果每一个任务执行的时间都很长，那么创建这么多线程，系统会进行大量的上下文切换，影响系统性能。再想一想，如果每一个线程都需要查询一下数据库表，可是数据库连接池的连接就那么多，很多线程都等待得到数据库的连接，都是newCachedThreadPool() 的弊端。newCachedThreadPool()的使用，适合执行之间非常短，任务多的数据。 newFixedThreadPool()123456789public static ExecutorService newFixedThreadPool(int var0) &#123; return new ThreadPoolExecutor(var0, var0, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue());&#125;public LinkedBlockingQueue() &#123; this(2147483647);&#125;private static final RejectedExecutionHandler defaultHandler = new ThreadPoolExecutor.AbortPolicy(); 我们需要传递一个参数var0，设置核心线程数和最大线程数，队列为容量为2147483647，采用拒绝策略为抛出异常。这种设置，相当于超时时间是无效的，当线程达到核心线程数的时候永远都不会被回收。所以这种情况，如果线程池使用频率较少，而且var0设置很高的话，系统中会存在很多没用的线程。如果请求很多的话，这样就会造成队列数据过多，可能会造成OOM。 我接触的时候就有这个场景，因为我们本地数据一个表表中数据非常多，并且每秒还会有很多的数据进入这个列表，表的查询等已经非常慢了。我们要将状态为”处理完成”的，一个月以前的数据迁入到历史表中。我的做法是每次查询2000条数据，分为10个线程，每个线程200条数据进行处理，我会将LinkedBlockingQueue()设置为10。并且将ThreadPoolExecutor.DiscardPolicy()即丢弃当前的任务，因为每条数据并没有关联性，而且不会丢失，以后我再获取就可以了。 newSingleThreadExecutor()1new ThreadPoolExecutor(1, 1, 0L, TimeUnit.MILLISECONDS, new LinkedBlockingQueue()); 好了，这个就不用多说了，这个就是无论怎么样，我都是单线程，就算是你的请求再多，这样就会造成队列数据过多，可能会造成OOM。 总结这篇文章主要是，根据自己的实践，来利用参数的改变选择自己合适的线程池，以及再实际开发中注意什么。]]></content>
      <tags>
        <tag>java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-策略模式]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F06%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[现在的生活中我们有很多种交通工具可以选择，就拿我来说，离单位比较进，所以上班的时候选择使用共享单车，但是共享单车你是知道的，周围可能会没有，这时候只能选择去坐地铁。现在周末正在学车，得去驾校，驾校的校车非常方便，我就会选择做校车。这种选择就是一种策略。 首先我们定义策略的接口，就一个方法operate(); 123public interface IStrategy &#123; public void operate();&#125; 123456public class Mobike implements IStrategy&#123; @Override public void operate() &#123; System.out.println("平常我就骑自行车"); &#125;&#125; 1234567public class SchoolBus implements IStrategy&#123; @Override public void operate() &#123; System.out.println("周末去驾校学车，坐校车"); &#125;&#125; 1234567public class Subway implements IStrategy&#123; @Override public void operate() &#123; System.out.println("没有自行车的时候，我就坐地铁"); &#125; &#125; 我们需要一个类来装我们的策略，就是context，方便我们来使用。 123456789101112public class Context &#123; private IStrategy strategy; public Context(IStrategy strategy)&#123; this.strategy=strategy; &#125; public void operate()&#123; this.strategy.operate(); &#125; &#125; 123456789101112131415161718192021public class Client &#123; public static void main(String[] args) &#123; Context context; System.out.println("看见自行车了"); context=new Context(new Mobike()); context.operate(); System.out.println("----------"); System.out.println("今天是周末，到时间学车了"); context=new Context(new SchoolBus()); context.operate(); System.out.println("----------"); System.out.println("没看见自行车"); context=new Context(new Subway()); context.operate(); &#125; &#125; 策略模式使用的就是面向对象的继承和多态机制，非常容易理解和掌握，我们再来看看策略模式的三个角色：● Context封装角色它也叫做上下文角色，起承上启下封装作用，屏蔽高层模块对策略、算法的直接访问，封装可能存在的变化。● Strategy抽象策略角色策略、算法家族的抽象，通常为接口，定义每个策略或算法必须具有的方法和属性。● ConcreteStrategy具体策略角色实现抽象策略中的操作，该类含有具体的算法。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-命令模式]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F06%2F07%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[我们现在处于物联网时代了，许多东西都可以在手机上进行操控。 空调 123456789101112131415public class AirConditioner &#123; public void turnOn()&#123; System.out.println("开启空调"); &#125; public void setTemperature(int temperature)&#123; System.out.println("将空调温度设置为："+temperature); &#125; public void turnOff()&#123; System.out.println("关闭空调"); &#125; &#125; 加湿器 12345678910111213141516public class Humidifier &#123; public void work()&#123; System.out.println("开启加湿器"); &#125; public void setTiming(int time)&#123; System.out.println("加湿器开启定时："+time+"分"); &#125; public void turnOff()&#123; System.out.println("关闭热水器"); &#125; &#125; 有时我们想用遥控器一样，进行远程控制。比如，还没到家的时候，家里太热，我想把空调打开，空气太干，我想将加湿器打开，并且我还不想让房间空气太潮湿，设置定时启动30分钟。这一个夏天，我每天都会这么做，我并不想一步一步地做出来，我想用一个命令解决所有问题。同时，当我离家的时候我想将空调和加湿器关掉，同样也是一个按钮解决，这样就可以避免少关掉一个等问题。 这个时候，我们将我们的需求设置成一个一个的命令，就像遥控器的按钮一样，点击就会执行。我们设计出了我们的命令类，他来负责发布我们的命令，定义我们的家用电器加湿器、空调，供子类使用。顶一个抽象方法execute()，由子类实现。 123456789public abstract class Command &#123; protected AirConditioner airConditioner=new AirConditioner(); protected Humidifier humidifier=new Humidifier(); public abstract void execute();&#125; Invoker相当于遥控器，负责执行工作，setCommand()负责接收我们的工作，action()负责执行工作。 1234567891011121314public class Invoker &#123; private Command command; public void setCommand(Command command)&#123; this.command=command; &#125; //执行客户的命令 public void action()&#123; this.command.execute(); &#125; &#125; 我们首先来一个简单的命令，就是单纯的打开空调。 1234567public class AirConditionerOpen extends Command&#123; @Override public void execute() &#123; super.airConditioner.turnOn(); &#125;&#125; 我们设置一个命令为”回家”，这个命令可以将空调打开，温度设置为22度，将加湿器打开，并且定时运行30分钟。 12345678910public class BackHome extends Command&#123; @Override public void execute() &#123; super.airConditioner.turnOn(); super.airConditioner.setTemperature(22); super.humidifier.work(); super.humidifier.setTiming(30); &#125; &#125; 我们运行一下 123456789101112public class Client &#123; public static void main(String[] args) &#123; Invoker invoker=new Invoker(); Command airConditionerOpen= new AirConditionerOpen() ; invoker.setCommand(airConditionerOpen); invoker.action(); System.out.println("--------我是分割线-------"); Command backHome=new BackHome(); invoker.setCommand(backHome); invoker.action(); &#125;&#125; ● Receive接收者角色 该角色就是干活的角色，命令传递到这里是应该被执行的，具体到例子就是我们的空调和加湿器。 ● Command命令角色 需要执行的所有命令都在这里声明。 ● Invoker调用者角色 接收到命令，并执行命令。在例子中，遥控器就是这个角色。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-原型模式]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F05%2F31%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[今天开始说一下原型模式，我们现在有一个系统，是一个工资提醒系统，如果发工资了，就给员工发送一条短信提醒一下，这样显得人性化么。有很多公司使用我们的系统。 今天是”某某某文化公司”发工资的日子，我们通常会有一个Company代表BO。 123456789101112131415161718192021222324252627282930313233public class Company &#123; private String companyName="某某某文化有限公司"; private String companyAccount="8888888888888888"; private String companyBank="招商银行"; public String getCompanyName() &#123; return companyName; &#125; public void setCompanyName(String companyName) &#123; this.companyName = companyName; &#125; public String getCompanyAccount() &#123; return companyAccount; &#125; public void setCompanyAccount(String companyAccount) &#123; this.companyAccount = companyAccount; &#125; public String getCompanyBank() &#123; return companyBank; &#125; public void setCompanyBank(String companyBank) &#123; this.companyBank = companyBank; &#125;&#125; 还有一个就是工资信息类，也就一个简单的pojo类。它包括发工资的公司名称、公司帐号1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374public class SalaryMessage&#123; public SalaryMessage(Company company)&#123; this.companyName=company.getCompanyName(); this.companyAccount=company.getCompanyAccount(); this.companyBank=company.getCompanyBank(); &#125; /** * 公司名称 */ private String companyName; /** * 公司帐号 */ private String companyAccount; /** * 所属银行 */ private String companyBank; /** * 用户名称 */ private String userName; /** * 用户帐号 */ private String userAcount; public String getCompanyName() &#123; return companyName; &#125; public void setCompanyName(String companyName) &#123; this.companyName = companyName; &#125; public String getCompanyAccount() &#123; return companyAccount; &#125; public void setCompanyAccount(String companyAccount) &#123; this.companyAccount = companyAccount; &#125; public String getCompanyBank() &#123; return companyBank; &#125; public void setCompanyBank(String companyBank) &#123; this.companyBank = companyBank; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUserAcount() &#123; return userAcount; &#125; public void setUserAcount(String userAcount) &#123; this.userAcount = userAcount; &#125;&#125; 发工资的问题：1、我们开始为员工们发工资，正常的员工信息是从数据库中取出来的，但是我们没有，只能随机造出来了。2、而且由于我们发送短息的系统老旧，而且员工人数很多，单线程是无法满足需求的，只能使用多线程。3.为了更好的观察，我们客户的名称就是银行卡号的前5位，也可以将客户名称当作客户在公司里的编码。 我们先建立负责发短信的线程类。 12345678910111213141516171819public class SendThread implements Runnable&#123; private SalaryMessage salaryMessage; public SendThread(SalaryMessage salaryMessage)&#123; this.salaryMessage=salaryMessage; &#125; @Override public void run() &#123; sendMessage(this.salaryMessage); &#125; public void sendMessage(SalaryMessage salaryMessage)&#123; StringBuilder stringBuilder=new StringBuilder(); stringBuilder.append(salaryMessage.getUserName()).append("先生/女士，").append(salaryMessage.getCompanyName()).append("的").append(salaryMessage.getCompanyBank()).append("，帐号为：") .append(salaryMessage.getCompanyAccount()).append("为你").append(salaryMessage.getUserAcount()).append("账户下进行了打款，备注为工资"); System.out.println(stringBuilder); &#125;&#125; 我们再进行客户端的实现。12345678910111213141516171819202122232425262728293031public class Client&#123; private static int MAX_COUNT = 100; public static void main(String[] args) &#123; SalaryMessage salaryMessage = new SalaryMessage(new Company()); for (int i=0;i&lt;MAX_COUNT;i++)&#123; String account=getRandAcount(12); String userName=account.substring(0,5); salaryMessage.setUserAcount(account); salaryMessage.setUserName(userName); Thread t1=new Thread(new SendThread(salaryMessage)); t1.start(); &#125; &#125; //获得指定长度的随机字符串 public static String getRandAcount(int maxLength)&#123; String source=null; source ="1234567890"; StringBuffer sb = new StringBuffer(); Random rand = new Random(); for(int i=0;i&lt;maxLength;i++)&#123; sb.append(source.charAt(rand.nextInt(source.length()))); &#125; return sb.toString(); &#125; &#125; 我们使用运行一下这段代码，看看结果是什么样的。 我们看一下代码，正确的方式是名称和卡号的前五位是对应的。因为是多线程，每个线程多会对salaryMessage进行修改，使对象的值进行变化。我们为了使线程之前相互不影响，只能new多个salaryMessage对象时传入Company信息。因为salaryMessage对象中的信息在这次业务处理中是不变的，我可不可以不用每次都传入重复的Company对象呢？答案是可以，这时候就使用了原型模式。 我们修改一下我们的SalaryMessage类，使它继承Cloneable接口,并且重写clone()方法。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788public class SalaryMessage implements Cloneable&#123; public SalaryMessage(Company company)&#123; this.companyName=company.getCompanyName(); this.companyAccount=company.getCompanyAccount(); this.companyBank=company.getCompanyBank(); &#125; /** * 公司名称 */ private String companyName; /** * 公司帐号 */ private String companyAccount; /** * 所属银行 */ private String companyBank; /** * 用户名称 */ private String userName; /** * 用户帐号 */ private String userAcount; public String getCompanyName() &#123; return companyName; &#125; public void setCompanyName(String companyName) &#123; this.companyName = companyName; &#125; public String getCompanyAccount() &#123; return companyAccount; &#125; public void setCompanyAccount(String companyAccount) &#123; this.companyAccount = companyAccount; &#125; public String getCompanyBank() &#123; return companyBank; &#125; public void setCompanyBank(String companyBank) &#123; this.companyBank = companyBank; &#125; public String getUserName() &#123; return userName; &#125; public void setUserName(String userName) &#123; this.userName = userName; &#125; public String getUserAcount() &#123; return userAcount; &#125; public void setUserAcount(String userAcount) &#123; this.userAcount = userAcount; &#125; @Override public SalaryMessage clone()&#123; SalaryMessage salaryMessage =null; try &#123; salaryMessage = (SalaryMessage)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return salaryMessage; &#125; &#125; 再修改一下我们的客户端 1234567891011121314151617181920212223242526272829303132public class Client&#123; private static int MAX_COUNT = 100; public static void main(String[] args) &#123; SalaryMessage salaryMessage = new SalaryMessage(new Company()); for (int i=0;i&lt;MAX_COUNT;i++)&#123; SalaryMessage cloneSalaryMessage=salaryMessage.clone(); String account=getRandAcount(12); String userName=account.substring(0,5); cloneSalaryMessage.setUserAcount(account); cloneSalaryMessage.setUserName(userName); Thread t1=new Thread(new SendThread(cloneSalaryMessage)); t1.start(); &#125; &#125; //获得指定长度的随机字符串 public static String getRandAcount(int maxLength)&#123; String source=null; source ="1234567890"; StringBuffer sb = new StringBuffer(); Random rand = new Random(); for(int i=0;i&lt;maxLength;i++)&#123; sb.append(source.charAt(rand.nextInt(source.length()))); &#125; return sb.toString(); &#125; &#125; 注意：salaryMessage = (SalaryMessage)super.clone();Object.clone()这个方法实现的是浅复制哦，在使用的时候一定要注意深复制和浅复制。之前写过类似的文章。 原型模式的优点 ● 性能优良 原型模式是在内存二进制流的拷贝，要比直接new一个对象性能好很多，特别是要在一个循环体内产生大量的对象时，原型模式可以更好地体现其优点。 ● 逃避构造函数的约束 这既是它的优点也是缺点，直接在内存中拷贝，构造函数是不会执行的。优点就是减少了约束，缺点也是减少了约束，需要大家在实际应用时考虑。 原型模式的使用场景 ● 资源优化场景类初始化需要消化非常多的资源，这个资源包括数据、硬件资源等。 ● 性能和安全要求的场景通过new产生一个对象需要非常繁琐的数据准备或访问权限，则可以使用原型模式。 ● 一个对象多个修改者的场景一个对象需要提供给其他对象访问，而且各个调用者可能都需要修改其值时，可以考虑使用原型模式拷贝多个对象供调用者使用。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-建造者模式]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F05%2F30%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[之前我们在做模版模式的时候，关键词就是每个子类都有相同的实现并且顺序一致，这样我们可以提取到父类上，并使用final防止子类复写。 现在我们的周末有很多选择，可以去看电影、吃大餐、玩游戏，当然还有我最喜欢地去加班。我们可以把所有事情都干了，也可以干其中的几个，你可以先看电影，然后吃大餐，再去玩游戏；也可以玩游戏、看电影；或者像我一样，只选择加班。它们之间没有必然的联系，也无顺序可言。我们来设计我们的抽象类,我们使用一个list里面代表我们需要干什么。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public abstract class AbstractPerson &#123; private List&lt;String&gt; sequence=new ArrayList&lt;String&gt;(); /** * 看电影 */ protected abstract void watchMovie(); /** * 吃大餐 */ protected abstract void eatDeliciousFood(); /** * 玩游戏 */ protected abstract void playGame(); /** * 去工作 */ protected abstract void goWork(); /** * 周末做事 */ protected void doThing()&#123; for (String str :sequence)&#123; if (str.equals("watchMovie"))&#123; this.watchMovie(); &#125; if (str.equals("eatDeliciousFood"))&#123; this.eatDeliciousFood(); &#125; if (str.equals("playGame"))&#123; this.playGame(); &#125; if (str.equals("goWork"))&#123; this.goWork(); &#125; &#125; &#125; final void setSequence(List&lt;String&gt; list)&#123; this.sequence=list; &#125; &#125; 我们通常会有一类人，叫做文艺青年，他们干什么都很文艺。还有那就是程序员，他们干什么都没女朋友.. 123456789101112131415161718192021222324public class ArtisticPerson extends AbstractPerson &#123; @Override protected void watchMovie() &#123; System.out.println("文艺青年看电影"); &#125; @Override protected void eatDeliciousFood() &#123; System.out.println("文艺青年吃美食"); &#125; @Override protected void playGame() &#123; System.out.println("文艺青年玩游戏"); &#125; @Override protected void goWork() &#123; System.out.println("文艺青年去工作"); &#125; &#125; 123456789101112131415161718192021public class ProgrammerPerson extends AbstractPerson &#123; @Override protected void watchMovie() &#123; System.out.println("程序员看电影"); &#125; @Override protected void eatDeliciousFood() &#123; System.out.println("程序员吃美食"); &#125; @Override protected void playGame() &#123; System.out.println("程序员玩游戏"); &#125; @Override protected void goWork() &#123; System.out.println("程序员敲代码"); &#125;&#125; 这个周末我们的文艺青年，去看电影和玩游戏。 1234567891011public class Test &#123; public static void main(String[] args) &#123; AbstractPerson artisticPerson=new ArtisticPerson(); List&lt;String&gt; list =new ArrayList&lt;String&gt;(); list.add("watchMovie"); list.add("playGame"); artisticPerson.setSequence(list); artisticPerson.doThing(); &#125;&#125; 现在我们应该改进一下，我们需要一个建造者，我们只要告诉他我们是什么人，我需要的顺序是什么，就可以进行这一天的活动了。做法跟之前工厂模式的factory极其相似，只不过我们在还需要传入一个顺序的参数，并且设置到我们的Sequence里面。 1234567891011121314public class PersonBuilder &#123; public &lt;T extends AbstractPerson&gt; T createPerson(Class&lt;T&gt; c,List&lt;String&gt; list)&#123; AbstractPerson abstractPerson=null; try &#123; abstractPerson= (AbstractPerson) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; abstractPerson.setSequence(list); return (T) abstractPerson; &#125;;&#125; 同时，我们应该对干什么的排序进行规范，我们新建一个Director类来保存我们的顺序。 123456789101112131415161718192021222324252627public class Director &#123; /** * 方法1:1.吃美食,2.玩游戏 */ public static List&lt;String&gt; method1()&#123; List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add("eatDeliciousFood"); list.add("playGame"); return list; &#125; /** * 方法2:1.去工作,2.玩游戏,3.吃大餐,4.看电影 */ public static List&lt;String&gt; method2()&#123; List&lt;String&gt; list=new ArrayList&lt;&gt;(); list.add("goWork"); list.add("playGame"); list.add("eatDeliciousFood"); list.add("watchMovie"); return list; &#125;&#125; 我们来再来试一试吧，建造一个文艺青年来吃美食、玩游戏，再建造一个程序员来工作、玩游戏、吃大餐、看电影。 12345678910public class Client &#123; public static void main(String[] args) &#123; PersonBuilder personBuilder=new PersonBuilder(); AbstractPerson artisticPerson=personBuilder.createPerson(ArtisticPerson.class,Director.method1()); artisticPerson.doThing(); System.out.println("---wanmei de fengexian---"); AbstractPerson programmerPerson=personBuilder.createPerson(ProgrammerPerson.class,Director.method2()); programmerPerson.doThing(); &#125;&#125; 使用场景：● 相同的方法，不同的执行顺序，产生不同的事件结果时，可以采用建造者模式。● 多个部件或零件，都可以装配到一个对象中，但是产生的运行结果又不相同时，则可以使用该模式。● 产品类非常复杂，或者产品类中的调用顺序不同产生了不同的效能，这个时候使用建造者模式非常合适。 区别：建造者模式最主要的功能是基本方法的调用顺序安排，也就是这些基本方法已经实现了，通俗地说就是零件的装配，顺序不同产生的对象也不同；而工厂方法则重点是创建，创建零件是它的主要职责，组装顺序则不是它关心的。建造者和模版模式，区别就是掌管顺序的方法一个是无序的，一个是有序的。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-模版模式]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F05%2F25%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E6%A8%A1%E7%89%88%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[在这之前我学习了单例模式和工厂模式，现在开始接触模版模式。场景：现在我们建立一个汽车悍马汽车模型，它旗下有很多车型，每个车都得启动，踩离合，加速，刹车等动作,我们开车的动作，启动、踩离合、加速、刹车这样的顺序进行启动的。 我们来建立悍马的抽象类来定义悍马车的动作。 123456789101112131415161718192021222324public abstract class HummerModel &#123; /** * 汽车启动 */ protected abstract void start(); /** * 踩离合 */ protected abstract void stepClutch(); /** * 停车 */ protected abstract void accelerate(); /** * 加速 */ protected abstract void stop(); public abstract void run();&#125; 我们来创造悍马H1和悍马H2两个车型 12345678910111213141516171819202122232425262728293031public class HummerH1Model extends HummerModel &#123; @Override protected void start() &#123; System.out.println("悍马H1开启车门"); &#125; @Override protected void stepClutch() &#123; System.out.println("悍马H1踩离合器"); &#125; @Override protected void accelerate()&#123; System.out.println("悍马H1加速"); &#125;; @Override protected void stop() &#123; System.out.println("悍马H1停车"); &#125; @Override public void run() &#123; start(); stepClutch(); accelerate(); stop(); &#125;&#125; 123456789101112131415161718192021222324252627282930public class HummerH2Model extends HummerModel &#123; @Override protected void start() &#123; System.out.println(&quot;悍马H2开启车门&quot;); &#125; @Override protected void stepClutch() &#123; System.out.println(&quot;悍马H2踩离合器&quot;); &#125; @Override protected void accelerate()&#123; System.out.println(&quot;悍马H2加速&quot;); &#125;; @Override protected void stop() &#123; System.out.println(&quot;悍马H2停车&quot;); &#125; @Override public void run() &#123; start(); stepClutch(); accelerate(); stop(); &#125;&#125; 我们发现，这个是常识，不管有多少个模型，开车的顺序必须是一样的，必须是启动、踩离合，加速、停止这样的顺序，每个run()都会方法都是一样的。我们每次为了减少错误，都会复制run()方法，即使我们很不情愿。有什么办法能解决这个场景吗？有，那就是模版模式，我们改造一下抽象类。 123456789101112131415161718192021222324252627282930313233public abstract class HummerModel &#123; /** * 汽车启动 */ protected abstract void start(); /** * 踩离合 */ protected abstract void stepClutch(); /** * 停车 */ protected abstract void accelerate(); /** * 加速 */ protected abstract void stop(); public final void run()&#123; start(); stepClutch(); accelerate(); stop(); &#125;; &#125; 我们run()方法里面的顺序一样，将run()方法提到抽象类中进行实现，这样每个类继承就可以不用每个模型都重新写一样的过程了。加上final表示不可让子类覆盖？为什么，加入H2悄悄的覆盖了父类的方法，那么H2模型生产出来的全是故障车啦！！！ 我们运行一下，看看结果是否有变化。 1234public static void main(String[] args) &#123; HummerModel hummerModel= new HummerH2Model(); hummerModel.run();&#125; 后来我们发现一个问题，汽车出现自动档汽车了！！虽然自动档汽车的顺序是不变的，依旧是启动，加速，停止，但是自动档的汽车是不需要踩离合的，那怎么办，我们的设置是必须踩离合啊！！！我们只好再次修改一下我们的抽象类了，让它可以根据场景判断是否踩离合。 我们首先加一个变量，来表示是否有离合器，默认是有离合器的。 1private Boolean hasClutch=true; 写一个方法，设置汽车没有离合器。 123protected void hasNoClutch()&#123; this.hasClutch=false; &#125; 改写一下我们的run()方法，有离合器的时候我们才使用，没有的时候我们不使用离合器。 12345678public final void run()&#123; start(); if (this.hasClutch)&#123; stepClutch(); &#125; accelerate(); stop();&#125;; 假设H1模型就是自动挡（没有离合器）,H2模型是手动档（有离合器）。 12345public static void main(String[] args) &#123; HummerModel hummerModel= new HummerH1Model(); hummerModel.hasNoClutch(); hummerModel.run(); &#125; 1234public static void main(String[] args) &#123; HummerModel hummerModel= new HummerH2Model(); hummerModel.run(); &#125; 总结：使用场景：模板方法模式确实非常简单，仅仅使用了Java的继承机制，但它是一个应用非常广泛的模式。其中，AbstractClass叫做抽象模板，它的方法分为两类：● 基本方法基本方法也叫做基本操作，是由子类实现的方法，并且在模板方法被调用。● 模板方法可以有一个或几个，一般是一个具体方法，也就是一个框架，实现对基本方法的调度，完成固定的逻辑。 注意：为了防止恶意的操作，一般模板方法都加上final关键字，不允许被覆写。 优点：● 封装不变部分，扩展可变部分把认为是不变部分的算法封装到父类实现，而可变部分的则可以通过继承来继续扩展。在悍马模型例子中，是不是就非常容易扩展？例如增加一个H3型号的悍马模型，很容易呀，增加一个子类，实现父类的基本方法就可以了。● 提取公共部分代码，便于维护我们例子中刚刚走过的弯路就是最好的证明，如果我们不抽取到父类中，任由这种散乱的代码发生，想想后果是什么样子？维护人员为了修正一个缺陷，需要到处查找类似的代码！]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-工厂模式、简单工厂模式、抽象工厂模式]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F05%2F24%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%81%E7%AE%80%E5%8D%95%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%E3%80%81%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[现在在看《设计模式之禅(第二版)》，想让自己对设计模式有着更深入的理解。 工厂模式 现在人工智能越来越火爆，为了我们的生活中会出现很多机器人。假设以后机器人将根据颜色进行分类，每个机器人我们都有颜色以及他的工作。 接口Robot是对所有机器人的总称。 1234567public interface Robot &#123; public void getColor(); public void work(); &#125; 我们来定义一下黑色机器人，黄色机器人。 12345678910111213public class BlackRobot implements Robot &#123; @Override public void getColor() &#123; System.out.println("我的颜色是黑色的"); &#125; @Override public void work() &#123; System.out.println("黑色机器人可以开车"); &#125; &#125; 12345678910111213public class YellowRobot implements Robot &#123; @Override public void getColor() &#123; System.out.println("我的颜色是黄色的"); &#125; @Override public void work() &#123; System.out.println("黄色机器人可以跟人类说话"); &#125;&#125; 我们现在使用抽象类AbstractRobotFactory定义一下工厂的整体功能。一个工厂可以建造这些机器人，建造黑色机器人的时候，我们应该只说要建造黑色机器人就可以了，而不是说“要建造一个颜色为黑色，可以开车的”黑色机器人。我们发现工厂生产机器人的方法输入参数类型应该是Robot接口的实现类(也就是BlackRobot、YellowRobot)。 1234public abstract class AbstractRobotFactory &#123; public abstract &lt;T extends Robot&gt; T createRobot(Class&lt;T&gt; c);&#125; 注意，我们在这里采用了泛型（Generic），通过定义泛型对createHuman的输入参数产生两层限制：● 必须是Class类型；● 必须是Human的实现类。 我们现在有一个工厂，让他实现创造机器人的接口。 1234567891011121314public class RobotFactory extends AbstractRobotFactory &#123; @Override public &lt;T extends Robot&gt; T createRobot(Class&lt;T&gt; c) &#123; Robot robot=null; try &#123; robot= (Robot) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) robot; &#125; &#125; 工厂建立好了，我们来用工厂来造机器人吧。 1234567891011121314public class Test &#123; public static void main(String[] args) &#123; RobotFactory humanFactory=new RobotFactory(); Robot yellowMan=humanFactory.createRobot(YellowRobot.class); yellowMan.work(); yellowMan.getColor(); BlackRobot blackMan=humanFactory.createRobot(BlackRobot.class); blackMan.work(); blackMan.getColor(); &#125;&#125; 让我们来看一下生成的机器人。 简单/静态工厂模式我们之前用到了抽象类，是因为我们可能有多个工厂，使用一个抽象工厂类对工厂进行约束，如果原则上我们不考虑有多个工厂，只会有一个工厂的话，就不需要使用抽象类了。并且将在方法前面加上static静态标识。 123456789101112public class RobotFactory &#123; public static &lt;T extends Robot&gt; T createHuman(Class&lt;T&gt; c) &#123; Robot robot=null; try &#123; robot= (T) Class.forName(c.getName()).newInstance(); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return (T) robot; &#125;&#125; 1234567891011public class Test &#123; public static void main(String[] args) &#123; Robot yellowRobot= RobotFactory.createHuman(YellowRobot.class); yellowRobot.getColor(); yellowRobot.work(); Robot blacdRobot= RobotFactory.createHuman(BlackRobot.class); blacdRobot.getColor(); blacdRobot.work(); &#125;&#125; 这种模式是工厂模式的弱化，调用者进行调用的时候简单，所以叫做简单工厂模式，也叫做静态工厂模式。 抽象工厂模式我们高高兴兴的做完了之前的机器人，突然又有需求了，现在提倡新能源，而且太阳能转化率变高了，我们需要设定机器人分为白天工作和晚上工作，白天工作的供电为太阳能，晚上的需要用使用供电的。我们只能从之前的机器人上继续改造，因为推翻实在是太费资源了。 首先，每个几个机器人都需要分太阳能和电能源的，我们在接口里面增加工作时间的接口doTime()。 123456789public interface Robot &#123; public void getColor(); public void work(); public void doTime(); &#125; 因为现在黑色的机器人需要分为太阳能、电两种能源，但是他们的getColor()和work()还是一样的，所以我们将BlackRobot改造成抽象类。 1234567891011121314public abstract class AbstractBlackRobot implements Robot&#123; @Override public void getColor() &#123; System.out.println("我是一个黑色机器人"); &#125; @Override public void work() &#123; System.out.println("黑色机器人可以开车"); &#125; @Override public abstract void doTime(); &#125; 我们现在创造太阳能的黑色机器人、黄色机器人，用电的黑色机器人、黄色机器人。（黄色机器人根据黑色机器人自己创造吧。。） 太阳能黑色机器人 1234567public class SunBlackRobot extends AbstractBlackRobot&#123; @Override public void doTime() &#123; System.out.println("我使用太阳能，我在白天工作。"); &#125;&#125; 充电黑色机器人 123456789public class CellBlackRobot extends AbstractBlackRobot&#123; @Override public void doTime() &#123; System.out.println("我使用电，我在黑天工作。"); &#125;&#125; 我们现在来做黑色机器人的工厂,同理创造黄色机器人工厂。 12345678910public class BlackRobotFactory &#123; public Robot createSunBlockRobot()&#123; return new SunBlackRobot(); &#125; public Robot createCellBlackRobot()&#123; return new CellBlackRobot(); &#125;&#125; 我们来使用黑色机器人工厂来创造黑色机器人吧。 123456789101112131415161718public class Test &#123; public static void main(String[] args) &#123; BlackRobotFactory blackRobotFactory=new BlackRobotFactory(); Robot cellBlackRobot= blackRobotFactory.createCellBlackRobot(); cellBlackRobot.getColor(); cellBlackRobot.work(); cellBlackRobot.doTime(); System.out.println("------我是分割线------"); Robot sunBlockRobot=blackRobotFactory.createSunBlockRobot(); sunBlockRobot.getColor(); sunBlockRobot.work(); sunBlockRobot.doTime(); &#125;&#125; 使用场景： 1.我们系统有ios，linux，windows系统都有txt查看器，图片查看器，但是他们每个txt查看器，图片查看器的实现都不一样，这时候就需要调用不同的工厂来实现。你选择了ios的工厂，就会有自己的txt查看器和图片查看器。2.每个产品，如太阳能黑色机器人、充电黑色机器人有相同的方法，有的方法实现是一样的，又有一些方法实现是不同的，这样使用抽象工厂模式很有效。 抽象工厂的优缺点：优点：封装性，每个产品的实现类不是高层模块要关心的，我们只要知道工厂类就可以建造出一个需要的对象，省时省力。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[枚举的用法]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F04%2F16%2F%E6%9E%9A%E4%B8%BE%E7%9A%84%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[在java开发中，在数据比较少，并且不容易改变的时候，枚举是一个非常好的当字段表的方式。相对与HashMap，它更加灵活，可以根据场景自定义方法，而且没有key、value的局限性，可以定义多个属性。 以下是在实际应用中的实践。 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950public enum EmBankInfoType &#123; ICBC("001", " 中国工商银行", "工商银行"), ABC("002", " 中国农业银行", "农业银行"), BOC("003", " 中国银行", "中国银行"), CCB("004", " 中国建设银行", "建设银行"), BCM("005", " 交通银行", "交通银行"), CMB("006", " 招商银行", "招商银行"),; //银行编码 private final String code; //银行全称 private final String bankFullName; //银行名称 private final String bankName; private EmBankInfoType(String code, String bankFullName, String bankName) &#123; this.code = code; this.bankFullName = bankFullName; this.bankName = bankName; &#125; public static EmBankInfoType of(final String code) &#123; return of(code, false); &#125; public static EmBankInfoType of(final String code, boolean acceptNull) &#123; for (EmBankInfoType em : EmBankInfoType.values()) &#123; if (em.code.equals(code)) &#123; return em; &#125; &#125; if (acceptNull) &#123; return null; &#125; throw new RuntimeException("无法查找枚举值: " + EmBankInfoType.class.getSimpleName() + ", " + code); &#125; public String getCode() &#123; return code; &#125; public String getBankFullName() &#123; return bankFullName; &#125; public String getBankName() &#123; return bankName; &#125; &#125; 枚举中有一个属性是ordinal,它是返回该枚举的位置(从0开始计算),实际上比较两个枚举是否相当EmBankInfoType.of(“005”).compareTo(EmBankInfoType.of(“001”)),也就是比较的ordinal. 12345678910111213public class EnumTest &#123; public static void main(String[] args) &#123; //自定义方法 System.out.println("获取枚举名称:"+EmBankInfoType.of("005").name()); System.out.println("获取枚举名称:"+EmBankInfoType.of("005").toString()); System.out.println("获取枚举名次:"+EmBankInfoType.of("005").ordinal()); System.out.println("根据枚举名称,获取枚举名次:"+EmBankInfoType.valueOf("ICBC").getBankFullName()); System.out.println(EmBankInfoType.of("005").compareTo(EmBankInfoType.of("001"))); &#125;&#125;]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hexo-移植hexo]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F04%2F16%2Fhexo-%E7%A7%BB%E6%A4%8Dhexo%2F</url>
    <content type="text"><![CDATA[安装前言:我之前记录一下事情的时候都是在有道云笔记，17年的3月份开始写博客，后来了解到了markdown语法，并尝试用hexo/github搭建属于自己的博客。由于公司调用所以我之前写博客的电脑没有了，促成我这次博客迁移（如何新建博客挺多的）。 nodejs安装如我所愿，我有了一台新的电脑，我下载了nodejs并且安装，安装后检查是否安装成功。1node -v 1npm -v git安装安装git，查看是否安装成功1git --version hwxo安装建立hexo的根据地，我选择d盘的blog里来放我的博客文件。会出现warn警告，不用关心，像java一样… 查看hexo是否安装成功 初始化hexo，命令为 hexo init Git配置Git个人信息配置如果你之前已经配置好git个人信息，请跳过这一个步骤。 设置Git的user name和email：(如果是第一次的话) git config –global user.name “username” git config –global user.email “username@163.com“ 生成密钥 ssh-keygen -t rsa -C “username@163.com“ 在这里会在C:\Users\用户名.ssh 文件下生成三个文件，如下图。 将id_rsa.pub文件里的内容，添加到github上，这样我们就可以根据ssh key方式下载代码了。 配置Deployment 同样在_config.yml文件中，找到Deployment，然后按照如下修改（记住，在这里“：”后面一定要有空格，否则hexo是一点反应都没有，找错都不知道上哪找去。）： 1234deploy: type: git repo: git@github.com:yourname/yourname.github.io.git branch: master 修改参数，可以上传文件： hexo如果想支持文章中显示图片，需要下载插件并配置_config.yml。 post_asset_folder 设置为true npm install hexo-asset-image –save 设置上传图片的插件 这时候，使用hexo new “test”命令，如果你发现在新建一个test.md文件的同时，出现一个test的文件夹，那么说明成功了。 移植现在正式到我们的移植部分了，source是你写的文件，themes是主题。将这两个文件夹覆盖了，我们就完成了移植的部分了。我们现在做的是扩展的作用，当你使用hexo写博客的时候，其实上传到github上的是md文件生成的静态界面，而不是原始文件。如果我有两个电脑，我在B上写了文章，用hexo提交后，A电脑是无法更新到的，因为没办法转义。因为这个需求，我将真实的文件（source）也上传到github上，这样我在B写了文章，将source提交到github上，a那边更新source就会获取b更新的文件，实现同步了，同时你也起到了备份的作用。当然了，也可以使用更刺激的方法，将整个blog文件夹提交到github上也是一个不错的选择。 git 初始化（git init） git 添加关联（git remote add origin git@github.com:—–.git） 使用ssh方式下载项目 (git pull origin master) 修改、添加完文件后 使用git将改动的文件添加到本地库（git add .） 提交并写注释 (git commit -m ‘4.16 commit’) push到github上(git push origin master) 查看git状态(git status)]]></content>
      <tags>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq-8-负载均衡与故障转移]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F02%2F06%2Frabbitmq-8-%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E4%B8%8E%E6%95%85%E9%9A%9C%E8%BD%AC%E7%A7%BB%2F</url>
    <content type="text"><![CDATA[]]></content>
      <tags>
        <tag>rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq-7-设置集群]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F01%2F29%2Frabbitmq-7-%E8%AE%BE%E7%BD%AE%E9%9B%86%E7%BE%A4%2F</url>
    <content type="text"><![CDATA[之前我们已经设置了单机版的rabbitmq，并且设置了user、exchange、queue、vhost等。现在我们要在我们的电脑里设置集群啦。我使用的是虚拟机，所以很轻松的就复制了之前的rabbitmq环境来进行集群设置。 集群你要知道之前我们了解了一些rabbitmq的基础知识，包括单机版安装、rabbitmq的构成等。如果你的rabbitmq服务器遇到内存崩溃了或者断电的情况，那么我们该进行集群啦。 集群架构到目前为止，我们对于rabbitmq的内部还算不上了解。确实，我们知道队列和交换器的含义，以及如何将它们绑定在一起。也知道该使用哪种类型的交换器。但是背后发生了什么，这是我们不知道的。Rabbitmq是如何记录所有你使用的各种基础构件，同时它们又如何装配成一个消息通讯服务器的呢？ Rabbitmq会始终记录一下四种类型的内部元数据： 队列元数据——队列名称和它们的属性(是否可持久化，是否自动删除？) 交换器元数据——交换器名称、类型和属性(可持久化等) 绑定元数据——一张简单的表格展示了如何将消息路由到队列 vhost——为vhost内的队列、交换器和绑定提供命名空间和安全属性 注意！！队列的元数据不包括队列里面的内容，队列中的消息在重启之后还是会消失的。rabbitmq存储数据有两种方式，一种为disc(硬盘)存储，一种为(ram)内存存储 在单一节点内，rabbitmq会将所有的这些信息存储在内存中，同时将哪些标记为可持久化的队列和交换器(以及他们的绑定)存储到硬盘上。存储到硬盘上可以确保队列和交换器在重启Rabbitmq节点后重新创建。当你引入集群时，rabbitmq需要追踪新的元数据类型：集群节点位置，以及节点与已记录的其它类型元数据的关系。集群也提供了选择：将元数据存储到磁盘上(独立节点的默认设置)，或者仅存储在ram中。但是在我们深入到集群节点和他们如何存储元数据前，我们首先理解在集群环境中队列和交换器的行为。 集群中的队列在将两个节点组成集群的那一刻，事情发生了巨大的变化：不是没一个节点都有所有队列的完全拷贝。在单一节点设置中，所有关于队列的的信息(元数据、状态和内容)都完全的存储在该节点上。但是如果在集群中创建队列的话，集群只会在单个节点而不是在所有节点上创建完整的队列信息(元数据、状态和内容)。所以，只有队列的所有者节点知道有关这个队列的所有信息。所有其他非所有者节点指挥知道队列的元数据和指向该队列存在的那个节点的指针。因此，在集群崩溃时，该节点的队列和关联的绑定就都消失了。附加在那些队列上的消费者丢失了其订阅信息，并且任何匹配该队列绑定信息的新消息也都丢失了。 别担心，你可以让你的消费者重新连到集群并重新创建队列。这种做法仅当队列最开始没有设置成可持久化的时候才是可行的。如果重新创建的队列被标记为持久化了，那么在其他节点上重新声明他们的话会得到一个难看的404 NOT FOUND错误。这样确保了当失败节点恢复后加入集群，该节点上的队列消息不会丢失。想要该制定队列重回集群的唯一方法是恢复故障节点。但是如果消费者尝试重建的队列不是可持久化的，那么重新声明就会成功，你可以准备重新绑定他们并传输数据。 这样设置队列的原因： 存储空间——如果每个集群节点都拥有所有队列的完成拷贝，那么添加新的节点不会给你带来更多的存储空间。举个例子，如果一个节点可以存储1GB的消息，那么添加两个节点只会给你带来两个一模一样的1GB的信息的拷贝。也就是说，两个节点里面存储的内容是一样的。 性能——消息的发布需要将消息复制到每一个集群节点。对于持久化消息来说，每一个消息都会触发磁盘活动。每次新增节点，网络和磁盘负载都会增加，最终只能保持集群性能的平稳，或者更糟，不会使性能更近一步。 通过设置集群中的唯一节点来负责任何特定的队列，只有负责该节点才会因队列消息而遭受磁盘活动的影响。所有其他节点需要将接收的该队列的消息传递给该队列的所有者节点。因此，往rabbit集群添加更多的节点意味着你将拥有更多的节点来传播队列，这些新增节点为你带来了性能的提升。当负载增加时，rabbitmq集群是性能扩展的最佳方案。 分布式交换器到目前为止，我们一直把交换器描述得如同队列那样是一个活生生的实体。事实上，不同于队列那样拥有自己的进程，交换器说到底只是一个名称和一个队列绑定的列表。当你将消息发布到交换器上的时，实际上是由你所连接的信道将消息上的路由键同交换器的绑定列表进行比较，然后路有消息。正事信道按照绑定匹配的结果，将消息路由到队列。所以信道才是真正的路由器。 将每个队列想象成节点上运行的进程，每个进程拥有自己的PID。交换器只不过是由路有模式列表和匹配消息应发往的队列进程ID列表。当发布的消息匹配了交换器中的绑定时，实际上是由信道完成了匹配工作，并在匹配之后建立了队列PID的睑裂，然后将消息传递过去。队列的进程ID本质上是其在集群中的Erlang地址 由于交换器只不过是一张查询表，而非实际上的消息路由器，因此将交换器在整个集群中进行复制会更加简单。举例来说，当创建一个新的交换器时，rabbitmq所要做的是将查询表添加到集群中的所有节点上。这时，每个节点上的每条信道都可以访问新的交换器了。因此。对于默认情况下队列的完整信息存在集群中的单一节点来说，集群中的每个节点拥有每个交换器的所有信息。就可用性来讲，这非常棒，这意味着你不用担心在节点故障时重新声明交换器。只需让故障节点上的生产者重新连接到集群上，它们立即就能开始往交换器上发布消息了。 内存节点和磁盘节点每个rabbitmq节点，不管是单一节点系统或者是庞大的集群的一部分，要么是内存节点(ram),要么是磁盘节点(disc)。内存节点将所有的队列、交换器、绑定、用户和vhost的元数据定义都仅存储在内存中。而磁盘节点则将元数据存储在磁盘中。单节点系统只允许磁盘类型的节点；否则，每次你重启rabbitmq之后，所有关于系统的配置信息都会失效。不过在集群中，你可以选择配置部分节点为内存节点。为什么想要选择将元数据仅存储在内存中？因为它使得相对列和交换器声明之类的操作更加快速。 当在集群中声明队列、交换器或者绑定的时候，这些操作会知道所有的集群节点都成功提交元数据变更后才返回。对于内存节点来说，这意味着将变更写入内存；而对于磁盘节点来说，这意味着昂贵的磁盘写入操作，直到完成之后，节点才能说“完事了”。假设你有五个节点的集群，并且所有的节点都是磁盘节点，则你必须得等待所有这五个节点将元数据写入磁盘后，队列声明才做还能返回。对于队列长存的服务器来说这没有什么大不了的。但是如果在处理繁重的RPC，如果每个RPC客户端正在创建和销毁每秒数以万计的应答队列，那么就会明白磁盘节点会降低性能。内存节点可以提供出色的性能，和磁盘节点能够保障集群配置信息幸免于重启，如何平衡两者。 rabbitmq只要求在集群中至少有一个磁盘节点。所有其他节点可以是内存节点。记住，当节点加入或者离开集群时，他们必须要将该变更通知至少一个磁盘节点。如果只有一个磁盘节点，而且不凑巧的是他刚好又崩溃，那么集群可以继续路由消息，但是不能做一下操作了： 创建队列 创建交换器 创建绑定 添加用户 更改权限 添加或删除集群节点 换句话说，如果集群中唯一的磁盘节点崩溃的话，集群仍然可以保持运行，但是在该节点恢复到集群前，你无法更改任何东西。解决方案是在集群中设置两个磁盘节点，因此他们中至少有一个是可用的，能在任何时候保存元数据的变更。只要一个需要所有的磁盘节点必须在线的操作是添加或者删除节点。当内存节点重启后，它们会连接到预先配置的磁盘节点，下载当前集群的元数据拷贝。如果你只将两个磁盘节点中的一个告诉该内存节点，而不凑巧的是当内存节点供电中断该磁盘节点也发生故障的话，那么内存节点在重启之后就无法找到集群了。所以添加内存节点时，确保要告知其所有的磁盘节点(内存节点唯一存储到磁盘的元数据信息是集群中的磁盘节点的地址)。只要内存节点可以找到至少一个磁盘节点，那么她就能在重启后重新加入集群。 在一台电脑上设置集群 关闭Management插件 我们在设置集群的时候，需要将management插件进行关闭，因为在你启用的management的时候，在同一台电脑启动多个rabbitmq的节点的时候，management的端口会冲突，management的默认端口号是15672。日志会显示端口号15672端口已被占用。初次设置集群的时候，最好不要用守护进程方式开启rabbitmq(-detached),如果你使用守护进程的方式开启rabbitmq，需要查看日志，因为rabbitmq默认守护进程，不会显示错误信息的。日志路径：rabbitmq所在目录下的/var/log/rabbitmq/rabbit_5673.log(5673是对应的端口) 关闭Management插件 1./rabbitmq-plugins disable rabbitmq_management 启动三个节点首先先启动三个rabbitmq的应用程序，这里我们需要设置rabbitmq的端口号和节点名称，否则都使用默认的会发生端口、节点名称已被使用的异常。首先进入rabbitmq的安装目录下 123456RABBITMQ_NODE_PORT=5672 RABBITMQ_NODENAME=rabbit \./sbin/rabbitmq-server RABBITMQ_NODE_PORT=5673 RABBITMQ_NODENAME=rabbit_5673 \./sbin/rabbitmq-server RABBITMQ_NODE_PORT=5674 RABBITMQ_NODENAME=rabbit_5674 \./sbin/rabbitmq-server 好了，我们现在启动了三个rabbitmq节点，分别是rabbit、rabbit_5673、rabbit_5674(每个节点后都有系统的主机名，添加在@后)。但是每一个节点都是独立的节点，拥有自己的元数据，并且不知道其他节点的存在。集群中的第一个节点将初始化数据带入集群中，并且无须被告知加入。而第二个和之后的节点将加入它并且获得他的元数据。要加入第二个和第三个节点，首先需要停止Erlang节点上运行的RabbitMQ应用程序，并重设(清空)他们的元数据。这样他们才可以被加入并获取集群的元数据。rabbitmqctl工具会帮你和每个节点通信并完成以上任务。 停止端口号为5673的应用程序。 1./rabbitmqctl -n rabbit_5673@localhost stop_app 将重设第二个节点的元数据和状态为清空的状态： 1./rabbitmqctl -n rabbit_5673@localhost reset 将其加入集群 1./rabbitmqctl -n rabbit_5673@localhost join_cluster rabbit@localhost 重新启动第二个节点的应用程序，它就变成集群中的一元了 1./rabbitmqctl -n rabbit_5673@localhost start_app 查看集群信息 1./rabbitmqctl cluster_status 我们可以看到，集群中有两个节点，而且都是运行状态。 我们在将第三个节点添加进来。 设置节点类型我们通过./rabbitmqctl cluster_status命令查看了有关于节点的信息，我们发现我们添加的节点都是disc的，也就是数据都存储在硬盘上的。如何设置节点存储的信息在ram(内存中)呢。 首先我们先停止我们刚才加进来的5674节点，重新将它配制成ram节点，命令也非常简单。为什么我要先配置5672节点为disc之后，在设置为ram呢，其实没有前后关系，只是自己尝试去停止节点之后，再应用节点。 1./rabbitmqctl -n rabbit_5674@localhost join_cluster --ram rabbit@localhost 我们这就可以看到集群5674节点为ram节点了。 多服务器集群之前我们在一台机器上设置了集群，现在我们在试试在多台机器上设置集群，我们这里使用虚拟机建立三个服务器。集群需要rabbitmq、erlang的版本最好是一模一样，否则可能发生错误。 首先，我们需要知道rabbitmq集群对延迟非常敏感，应当指在本地局域网内使用。使用集群来提供地理可用性或者通过WAN来路由消息，都会导致超时和怪异的集群行为，因此这是不明智的。 我们虚拟机的ip地址分别为192.168.14.128，192.168.14.132，192.168.14.133。 因为我们是一台服务器一个rabbitmq服务，那么我们就不用在此之前停止management插件了。 修改Erlang cookie多服务器集群(一个服务器一个rabbitmq服务)与单机集群(一个服务器多个rabbitmq服务)。使每个节点的Erlang cookie相同，他们就可以互相通信。如果节点的Erlang cookie字符串不相同，那么当Erlang cookie节点尝试相互认证时会导致集群失败。 那么Erlang cookie在哪呢，官网上有介绍，当然也有最简单的办法，就是在先运行一下rabbitmq，然后查看日志，里面有你想要的信息。 在日志中可以看到我们的节点名称、home路径、日志路径等。我们根据home路径可知，.erlang.cookie文件就在root下。 修改一下.erlang.cookie的内容吧，做为测试，我将.erlang.cookie的内容改成AAAAAAAAAAAAAAAAAAAAAAAAA。 因为.erlang.cookie是只读的，修改之前我们应该有修改权限 1chmod 775 -R .erlang.cookie 修改里面的内容 一定要将.erlang.cookie的权限改回只读文件，否则启动的时候rabbitmq会提示你.erlang.cookie的权限不是只读的，保险起见，我们将.erlang.cookie的权限改回与之前一模一样。 1chmod 400 -R .erlang.cookie 同样的方法，将其他两台服务器的.erlang.cookie也改为AAAAAAAAAAAAAAAAAAAAAAAAA。我们的第一步就算是做完了。 注意！！修改.erlang.cookie的时候，需要先将rabbitmq的服务停掉，修改过后之后，你会发现你无法使用rabbitmqctl stop的命令停止和rabbitmqctl status命令查看服务状态，都会提示你找不到之前的.erlang.cookie。如果遇到这种情况，可以根据rabbitmq的端口号来结束进程。 1kill -9 $(netstat -nlp | grep :5672 | awk '&#123;print $7&#125;' | awk -F"/" '&#123; print $1 &#125;') 修改hostname因为rabbitmq的hostname不能是系统默认的，所以我们在做集群之前需要先改一下hostname。 查看hostname命令，然后可以可以在/etc/hostname下修改。 1hostname 修改hostname之后需要重新启动，重启后生效。 然后进行与单服务器集群一样的设置。 123./rabbitmq-server ./rabbitmqctl stop_app./rabbitmqctl reset 但是进行添加节点的时候，发现出问题了，问题如下 1./rabbitmqctl join_cluster rabbit@guo128 这是因为两个节点需要相互解析，所以最好在每个服务器上都记录一下服务器的ip以及名称。 设置好以后继续执行。 12./rabbitmqctl join_cluster rabbit@guo128./rabbitmqctl start_app 最后查看一下集群状态，成功！]]></content>
      <tags>
        <tag>rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq-5-生产者和消费着的简单实现]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F01%2F26%2Frabbitmq-5-%E7%94%9F%E4%BA%A7%E8%80%85%E5%92%8C%E6%B6%88%E8%B4%B9%E7%9D%80%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[在之前介绍这么多之后，我们也需要进行一下java代码的实现。 direct交换器direct生产者123456789101112131415161718192021222324252627282930313233343536373839404142434445import com.rabbitmq.client.AMQP;import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class DirectSender &#123; private final static String QUEUE_NAME = "log-direct"; public static void main(String[] args) throws Exception &#123; ConnectionFactory factory=new ConnectionFactory(); factory.setHost("192.168.14.128"); factory.setUsername("admin"); factory.setPassword("admin"); factory.setPort(5672); //设置vhost factory.setVirtualHost("test_vhost"); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); /** * String queue:声明的队列名称 * boolean durable：是否队列持久化 * boolean exclusive：是否为私有 * boolean autoDelete：最后一个消费者取消订阅的时候，对列是否自动移出 * Map&lt;String,Object&gt; arguments */ channel.queueDeclare(QUEUE_NAME, false, false, false, null); /** *定义交换器的类型 */ channel.exchangeDeclare(QUEUE_NAME,"direct"); for (int i=0;i&lt;=20;i++)&#123; String message = "Hello World"+i+"!"; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); &#125; channel.close(); connection.close(); &#125;&#125; direct消费者123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import com.rabbitmq.client.*;import java.io.IOException;import java.util.concurrent.TimeoutException;public class DirectCustomer &#123; private final static String QUEUE_NAME="log-direct"; public static void main(String[] args) throws IOException, TimeoutException &#123; ConnectionFactory factory=new ConnectionFactory(); factory.setHost("192.168.14.128"); factory.setPort(5672); factory.setUsername("admin"); factory.setPassword("admin"); factory.setVirtualHost("test_vhost"); Connection connection=factory.newConnection(); final Channel channel = connection.createChannel(); /** * String queue:声明的队列名称 * boolean durable：是否队列持久化 * boolean exclusive：是否为私有 * boolean autoDelete：最后一个消费者取消订阅的时候，对列是否自动移出 * Map&lt;String,Object&gt; arguments */ channel.queueDeclare(QUEUE_NAME, false,false,false,null); /** *定义交换器的类型 */ channel.exchangeDeclare(QUEUE_NAME,"direct"); // 告诉服务器我们需要那个频道的消息，如果频道中有消息，就会执行回调函数 Consumer consumer=new DefaultConsumer(channel)&#123; @Override public void handleDelivery(String consumerTag, Envelope envelope, AMQP.BasicProperties properties, byte[] body) throws IOException &#123; String message=new String(body,"utf-8"); System.out.println("Customer Received '" + message + "'"); &#125; &#125;; //订阅队列 channel.basicConsume(QUEUE_NAME, true, consumer); &#125;&#125; 我们这里在消费者和生产者都定义了队列和交换器，如果定义的队列信息一致，那么rabbitmq不会做出任何改变。如果你在运行消费者的时候定义了队列需要持久化，而在生产者的时候定义队列不需要持久化，那么就会出现错误。为了验证我们之前说过的，订阅到rabbitmq队列的多个消费者是顺序接收消息的，所以我们先启动两个消费者，再启动生产者。 生产了创建了21条数据，并被两个消费者依次消费]]></content>
      <tags>
        <tag>rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq-4-rabbitmq中常用设置语句]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F01%2F24%2Frabbitmq-4-rabbitmq%E4%B8%AD%E5%B8%B8%E7%94%A8%E8%AE%BE%E7%BD%AE%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[我们在之前讲解了很多关于rabbitmq的构成以及设置语句，其实也很多，所以单独写一篇来记录。 启动/关闭rabbitmq启动服务 ./rabbitmq-server 守护程序启动服务 ./rabbitmq-server -detached 启动守护进程会显示警告：Warning: PID file not written; -detached was passed.在后台启动服务器进程。请注意，这将导致pid不被写入到pid文件中。 停止服务 ./rabbitmqctl stop 停止远程节点 ./rabbitmqctl stop -n rabbit@192.168.14.130 用户添加用户和密码： ./rabbitmqctl add_user admin admin 查看用户列表： ./rabbitmqctl list_users 修改用户密码： ./rabbitmqctl change_password admin admintest 设置/修改用户在test_vhost的权限(配置、写、读)：1./rabbitmqctl set_permissions -p test_vhost \admin ".*" ".*" ".*" vhost添加vhost: ./rabbitmqctl add_vhost test_vhost 查看vhost列表: ./rabbitmqctl list_vhosts 查看test_vhost下的用户权限：./rabbitmqctl list_permissions -p test_vhost 删除用户权限：./rabbitmqctl clear_permissions -p test_vhost admin 队列显示test_vhost下的队列：./rabbitmqctl list_queues -p test_vhost 交换器显示test_vhost下的交换器及其绑定：./rabbitmqctl list_exchanges -p test_vhost 查看交换器与队列的绑定关系: ./rabbitmqctl list_bindings -p test_vhost]]></content>
      <tags>
        <tag>rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq-3-运行和管理]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F01%2F18%2Frabbitmq-3-%E8%BF%90%E8%A1%8C%E5%92%8C%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[服务器管理启动服务 ./rabbitmq-server 守护程序启动服务 ./rabbitmq-server -detached 启动守护进程会显示警告：Warning: PID file not written; -detached was passed.在后台启动服务器进程。请注意，这将导致pid不被写入到pid文件中。 停止服务 ./rabbitmqctl stop 停止远程节点 ./rabbitmqctl stop -n rabbit@192.168.14.130 管理用户添加一个账户为admin,密码为admin的用户 ./rabbitmqctl add_user admin admin 查看用户列表 ./rabbitmqctl list_users 修改用户密码 将admin用户的密码修改为admintest ./rabbitmqctl change_password admin admintest rabbitMQ权限系统rabbitMQ创建用户，然后为其赋予权限。rabbitmq的权限分为读、写、配置三个方面。RabbitMQ用户一个好的地方就是在于单个用户可以跨越多个vhost用户进行授权。当应用程序需要跨越多个安全域进行通信时(使用虚拟机进行隔离)，这会极大地方便访问控制的管理。 读-有关消费信息的任何操作，包括”清除”整个队列(同样需要绑定操作成功)。 写-发布消息(同样需要绑定操作成功)。 配置-队列和交换器的创建和删除。 每一个访问条目由一下四部分组成： 被授予访问权限的用户。 权限控制应用的vhost。 需要手语的读/写/配置权限的组合。 权限范围-权限控制仅应用于客户端命名的队列和交换器呢，还是仅用于服务器端的命名的队列/队列呢？抑或者两者兼顾？客服端命名意味着由你的应用程序设置交换器/队列的名称;服务器端命名意味着你的应用程序不提供名字而是让服务器随机指派。 谨记：访问控制条目是无法跨越vhost的。举例来说，如果你想要给用户admin在vhost A和vhost B上赋予相同的权限，那么你必须创建两份访问控制目录(每一个vhost一份)。 之前我们创建了一个vhost名为test_vhost,如果想让admin用户赋予完全的访问权限(读、写、配置)。 添加-p test_vhost 为那个vhost设置权限\admin 哪个用户“.“ 所有的权限“check-.“ 只匹配名字以”check-“开头的队列和交换器。“” 不匹配队列和交换器（这就是如何对用户拒绝指定的权限） “.“ “.“ “.*” 配置的顺序依次为配置、写、读。 1./rabbitmqctl set_permissions -p test_vhost \admin ".*" ".*" ".*" 查看检查一下vhost（以test_vhost）下的用户权限。 1./rabbitmqctl list_permissions -p test_vhost 如果在vhost_test下，允许admin用户对任何队列或者交换器可执行读操作，同时限制其只能对名字以”check-“开始的队列和交换器可执行读操作，同时限制这个用户不能进行配置。根据上面的介绍，你应该如此配置。 删除删除test_vhost下的admin的权限设置。 1./rabbitmqctl clear_permissions -p test_vhost admin 修改其实修改就是跟添加是一个语法啦，会覆盖之前的。 检查队列列出默认的vhost(只是默认的vhost而不是所有的vhost的队列)队列信息和数量1./rabbitmqctl list_queues 列出vhost名为test_vhost队列信息和数量：1./rabbitmqctl list_queues -p test_vhost 查看队列的更多信息，举几个比较常用的name:名称messages：数量consumers：附加的消费者数目memory：占用的内存durable:队列是否持久化auto_delete:队列消息没有时是否删除队列 1./rabbitmqctl list_queues -p test_vhost name messages consumers memory durable auto_delete 交换器和绑定查看默认vhost：1./rabbitmqctl list_exchanges 列出vhost名为test_vhost：1./rabbitmqctl list_exchanges -p test_vhost 当然你也可以输出更详细的 must be a member of the list [name, type, durable, auto_delete, internal, arguments, policy].]]></content>
      <tags>
        <tag>rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitmq-2-理解消息通讯及构造]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F01%2F15%2Frabbitmq-2-%E7%90%86%E8%A7%A3%E6%B6%88%E6%81%AF%E9%80%9A%E8%AE%AF%E5%8F%8A%E6%9E%84%E9%80%A0%2F</url>
    <content type="text"><![CDATA[在rabbitmq-1这篇博客里，是介绍如何安装erlang以及rabbitmq，和远程客户端的连接。但是我们还没理解什么是rabbitmq以及它其中的构造，这篇博客是我看完部分《RabbitMQ实战》这本书的理解。 生产者和消费者模式我们正常接触到的都是B/S或者C/S架构，都是一端发送请求，另一端处理数据。消息队列实现模式并不是这样的，举个例子来讲，我们都吃过自助餐，有一个自助餐桌，用来放厨师做出来的菜，厨师就相当于生产者，而消息就相当于放在自助餐桌里的菜，顾客就是消费者，消费者在自助餐桌上拿了一道菜，他甚至不知道这道菜是谁做的。这就起到了应用程序间解耦的作用。 消息生产者创建消息，然后发布到代理服务器(rabbitmq)。消息分为两部分：有效载荷(payload)和标签(label)。有效载荷就是你想要发送的数据，它可以是任何内容。标签描述了有效载荷，并且RabbitMQ用来它来决定谁将获得信息的拷贝。举例来说，不同于TCP协议来说，当你明确了指定的发送方和接收方时，AMQP只会用标签来表述这条信息（一个交换器的名称和可选的主题标记），然后把消息交给rabbitmq。rabbit会根据标记把信息发送给感兴趣的接收方。这种通讯方式是一种”发后即忘”的单项模式。生产者会创建消息并且设置标签。 消费者连接到代理服务器上，并订阅到队列(queue)上。每当一个消息到达队列后，rabbitmq会将其发送给其中一个订阅的/监听的消费者。当消费者接收消息的时候，只会接收有效载荷。所以rabbitmq不会告诉你是谁生产了/发送了信息。就想我们刚才举得例子，顾客根本不知道这道菜是哪个厨师做的，如果想知道这道菜是谁做的，就是他在他的菜品上写了自己的名字。如果需要明确知道是谁生产的AMQP消息的话，就要看生产了是否把发送方的信息放到有效载荷中。 传输方式：信道生产者生产消息，并且发送给rabbitmq；消费者从rabbitmq哪里接收消息。那么生产者是如何将信息发送给rabbitmq，消费者又怎样接收的呢，靠的是就是信道，英文名字为Channel，是不是觉得有点熟悉，NIO里面也有Channel，多个Channel被一个Selector包含。其实rabbit信道同样也是，多个channel对一个TCP连接。无论是发布消息、订阅队列或者接收消息，都是通过信道完成的。为什么不直接用TCP连接？因为对于操作系统来说，建立和销毁TCP会话是非常昂贵的开销，操作系统每秒也就能建立不多数量的TCP连接，这样如果每秒的请求有千万级的话，这种方式很快就成为性能瓶颈了。信道的好处，是建立一个TCP连接，然后里面建立成百上千的信道也不会影响操作系统，而且线程之间还能保持私密性。相当于每条电缆中有多条光纤束一样都可以传输，允许所有连接的线程通过多条光钎束同时进行传输和接收。 java中创建信道我们需要在连接工厂来创建一个连接，根据这个连接我们来获取信道。 1234567ConnectionFactory factory=new ConnectionFactory(); factory.setHost("192.168.14.128"); factory.setUsername("test"); factory.setPassword("test"); factory.setPort(5672); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); 队列首先，要确定的是，AMQP路由有三部分组成：交换器、队列和绑定。 队列的订阅方式（1）通过AMQP的basic.consume命令订阅，这样会将信道设置为接收模式，直到取消对队列的订阅为止。订阅了消息之后，消费者在消费（或者拒绝）最近接收的消息后，就能从队列（可用的）自动接收下一条消息，如果消费者处理队列消息，并且/或者需要在信息一达到队列时就自动接受的话，你应该使用basic.consume。 （2）某些时候，你只想从队列获得单条消息而不是持续订阅。向队列请求单挑消息通过AMQP的basic.get命令实现的。这样做可以让消费者接收队列的下一条信息。如果要获得更多的信息的话，需要再次发送basic.get命令。不要将basic.get写进循环里代替basic.consume，那会影响rabbitmq的性能。 队列处理消息如果至少有一个消费者订阅了队列的话，消息会立即发送给这些订阅的消费者。如果消息到达了一个无人订阅的队列，那么消息就会在队列里一直进行等待消费。 当消息有多个消费者的时候，队列收到的消息会以循环的方式发送给消费者。每条消息只会发送给一个消费者。如果有消费者A，B同时订阅了seed队列的话，消息分发是这样的。 消息one到达seed队列 rabbitmq将信息发送给消费者A 消费者确认接收到了消息one rabbitmq把消息one从seed队列移除 消息two到达seed队列 rabbitmq把消息two发送给消费者B 消费者B确认接收到了消息two rabbitmq把消息two从seed队列中移除 我们看到消费者A和消费者B都对消息进行了确认。消费者接收到的每一条消息都必须进行确认。消费者必须通过AMQP的basic.ack命令显示地想RabbitMQ发送一个确认，或者在订阅到队列的时候就将auto_ack命令设置为true。当设置了auto_ack时，一旦消费者接收消息，RabbitMQ会自动视其确认了消息。需要记住的是，消费者对消息的确认和告诉生产者消息已经被接收了这两件事毫无关联。因此，消费者通过命令告诉RabbitMQ它已经正确地接收到了消息，同时RabbitMQ才能安全地把消息从队列中删除。 如果消费者收到一条消息，然后确认之前从Rabbit断开连接（或者从队列取消订阅），RabbitMQ会认为这条消息没有分发，然后重新分发给下一个订阅的消费者。如果你的应用程序崩溃了，这样做可以确保消息会被发送给另一个消费者进行处理。另一方面，如果应用程序有bug而忘记确认的话，RabbitMQ将不会给该消费者发送更多的信息了。这是因为在上一条消息确认之前，RabbitMQ会认为这个消费者没有准备好接收下一条消息。我们可以好好利用这一点，如果处理消息的内容非常耗时，则你得应用程序可以延迟确认该消息，知道消息处理完成。这样可以防止RabbitMQ持续不断的消息涌向你的应用而导致过载。 java中创建队列在java可以使用信道来创建队列。 12345678/*** String queue:声明的队列名称* boolean durable：是否队列持久化* boolean exclusive：是否为私有* boolean autoDelete：最后一个消费者取消订阅的时候，对列是否自动移出* Map&lt;String,Object&gt; arguments**/channel.queueDeclare(QUEUE_NAME, false, false, false, null); 交换器和绑定根据我们之前说的那样，消费者从队列中获取消息，可以消息是怎么样传到队列里的呢？是通过交换器和绑定。当你想将消息传递给队列的时候，需要通过消息发送给交换器来完成。然后，根据确定的规则，RabbitMQ会决定消息该投递给哪个队列。这个规则被称为路由键。队列通过路由器绑定到交换器。当你把消息发动给代理服务器时，消息将拥有一个路由键，即使是空的，RabbitMQ也会将其和绑定使用的路由器进行匹配。如果想匹配的话，那么消息就会进入队列中。如果路由的消息不匹配任何绑定模式的话，消息将进入黑洞。 交换器服务器会根据路由键消息从交换器路由队列，但是它如何处理投递到多个队列的情况的呢？协议中定义的不同类型的交换器发挥了作用。一共有四种类型：direct、fanout、topic和headers。每一种类型实现了不同的路由算法。由于我是看《RabbitMQ实战》这本书进行学习，作者提到headers交换器允许你匹配AMQP消息的header而非路由键。除此之外，headers交换器和direct交换器完全一样，但是性能会差很多。因此它不太实用，并且现在几乎再也用不到了，那么我们就不介绍了。 direct交换器如果路由键匹配的话，消息就被投递到对应的队列。 direct交换器就是路由键匹配的话，消息就被投递到对应的队列。服务器必须实现direct类型的交换器，并且包含了一个空白字符串的默认交换器。当你声明一个队列的时候，他就自动绑定到这个默认的交换器上，并以队列名称作为路由键。 队列与交换器进行绑定，并且向发送消息 1234567/*** String exchange:交换器名称* String routingKey：路由键* AMQP.BasicProperties props：* byte[] body：发送的消息的内容**/basicPublish(String exchange, String routingKey, AMQP.BasicProperties props, byte[] body) 向默认的交换器,以及路由键发送消息，因为direct交换器中，路由键与队列是一对一的，路由键的名称就是队列的名称。所以在在这个发送消息的时候虽然没有体现队列，但是已经制定了你的数据传给了哪个队列，这是redict交换器中特有的，需要注意一下。 1channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); 如果想更换交换器，我们可以设置自己的交换器。使用 123456 /** * String exchange:交换器名称 * BuiltinExchangeType type：交换器类型 * **/exchangeDeclare(String exchange, BuiltinExchangeType type) fanout交换器这个类型的交换器将收到的信息广播绑定到队列上。当你发送一条信息到fanout交换器的时候，他会把消息投递给所有附加在此交换器上的队列。 这个交换器我觉得应用场景会很多。假如说现实生活中，你有一张银行卡，你开通了手机银行，同时你的银行卡也绑定了支付宝、微信。当你使用这张卡完成支付后，那么需要手机银行给你发送一条短信，我支付了多少钱。同时支付宝、微信也会在自己的软件中进行通知。这就可以使用fanout交换器，让三个队列分别与fanout的交换器进行绑定，不用改生产者的任何代码，就可以解决这个问题。 topic交换器topic交换器允许你实现有趣的消息通讯场景，它使得来自不同源头的消息能够到达同一队列。如果拿Web应用程序作为示例。我们拥有不同的日志级别，error、info、warning等。于此同时，你的应用程序分为一下几个模块，users、product、org等。如果你在对用户模块进行操作的时候，你想报告一个error的话，则可以这样写。 1channel.basicpublic("logs-exchanges","error-users",null,message); 加入你声明了一个user-errors的队列，你可以将其绑定到交换器上来接收消息，如下所示。 1queueBind(String queue, String exchange, String routingKey) 1channel.queueBind("user-errors","logs-exchanges","error-users"); 到目前为止，这看起来跟direct交换器很像。但是如果你想用一个队列监听users模块的所有错误级别呢，这就这需要使用topic交换器了。 1channel.queueBind("user-logs","logs-exchanges","*.-users"); user-logs这个队列可以接收所有从users模块接收模块发来的所有error,warning和info的日志。如果要是一个队列接收所有模块的所有的错误的信息。 1channel.queueBind("all-logs","logs-exchanges","#"); 这样all-logs就可以接收所有传入logs-exchanges的消息了。这时候可能会问，那岂不是不是日志的消息也会放入all-logs吗？我们建立了一个logs-exchanges这个交换器，就是专门放日志的。所以对于交换器来说，不仅要选对类型，还要根据名字来来决定他的功能性。 虚拟主机vhost每一个RabbitMQ都会创建一个虚拟消息服务器，我们称之为虚拟主机(vhost)。每一个vhost本质上是一个mini版的RabbitMQ服务器，拥有自己的队列、绑定、交换器。最重要的是，它拥有自己的权限控制。他们通过在各个实例间提供逻辑上分离，允许你为不同的应用程序安全保密地运行数据。这很有用，它既能将同一Rabbit的众多客户区分开来，又可以避免队列和交换器命名的冲突。负责你可能不得不运行多个Rabbit，并忍受随之而来头疼的管理问题。相反，你可以只运行一个Rabbit，然后按需启动和关闭vhost。 vhost是AMQP概念的基础，你必须在连接时指定。由于RabbitMQ包含了开箱即用的默认的vhost:”/“，因此使用起来非常简单。如果你不需要多个vhost的话，那么就使用默认的吧。通过使用缺省的guest用户名和密码guest就可以访问默认vhost。 当你在RabbitMQ里创建一个用户，用户通常会被制定给至少一个vhost，并且只能访问被指派的vhost内的队列、交换器和绑定。当你设计消息通讯架构时，记住vhost之间是绝对隔离的。你无法将vhost A上的交换器绑定到 vhost B上的队列中。这既保证了安全性，又保证了可移植性。当你在RabbitMQ集群上创建vhost时，整个集群上都会创建该vhost。vhost不仅消除了为基础架构中的每一层运行一个RabbitMQ服务器的需要，同样也避免了每一层创建不同集群。 vhost的创建和权限控制非常独特，他们是AMQP中无法通过AMQP协议创建的基元(不同于队列，交换器和绑定)。对于RabbitMQ来说，你需要通过RabbitMQ的安装路径下的./sbin/目录中的rabbitmqctl工具来创建。 新建一个名为test_vhost的vhost 1./rabbitmqctl add_vhost test_vhost 查看当前vhost列表 1./rabbitmqctl list_vhosts]]></content>
      <tags>
        <tag>rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[rabbitMQ-1-cenotOS7下erlang、rabbitMQ安装]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F01%2F11%2FrabbitMQ-1-cenotOS7%E4%B8%8Berlang%E3%80%81rabbitMQ%E5%AE%89%E8%A3%85%2F</url>
    <content type="text"><![CDATA[首先应在rabbitMQ官网查看需要下载的版本，我们选择的是3.7.2，根据rabbitMQ的版本在erlang选择支持的版本，这里我们选择的是erlang是20.1。我是新建一个虚拟机进行配置，所以使用的root用户进行文件的安装。 安装erlang首先现在官网下载erlang1wget http://www.erlang.org/download/otp_src_20.1.tar.gz 安装erlang依赖包 1yum install -y gcc gcc-c++ unixODBC-devel openssl-devel ncurses-devel 解压压缩包 1tar -zxvf otp_src_20.1.tar.gz 将解压文件修改名字，并移动到自己的软件安装目录下 1mv otp_src_20.1 erlang20.1 进入erlang20.1目录下 1./configure --prefix=/usr/local/erlang20.1 -with-ssl -enable-rhreads -enable-smp-support -enable-kernel-poll -enable-hipe -without-javac 如果提示以上界面，说明erlang的配置项没有问题，再进行编译 1make &amp;&amp; make install 验证是否安装成功，进入bin/目录下，查看是否存在erl文件 ./erl 使用halt().退出 我们为了能让erl全局使用，需设置环境变量，我如果只想在guojian用户下使用环境变量，就需要修改.bash_profile。 1PATH=$PATH:/usr/local/erlang20.1/bin 保存退出后，直接使.bash_profile生效1source .bash_profile 安装rabbitMQrabbit安装部分我们首先下载下来的文件包rabbitmq-server-generic-unix-3.7.2.tar.xz 首先它是一个XXX.tar.xz的格式，我们先要给他解压成tar格式的 1xz -d rabbitmq-server-generic-unix-3.7.2.tar.xz 然后再解压tar包 1tar -xvf rabbitmq-server-generic-unix-3.7.2.tar 移动rabbitmq 到软件的目录 1mv rabbitmq_server-3.7.2/ /usr/local/rabbitmq-3.7.2 进入rabbitmq-3.7.2的sbin目录下 执行 ./rabbitmq-server start 如果出现rabbitmq的版本信息，说明你的rabbitmq已经启动了。 查看rabbitmq的状态./rabbitmqctl status 如果你输入显示的是如下图所示，说明你没有配置erlang的环境变量，上面有。 客户端连接查看用户 我们可以看到有一个用户是guest，权限是administrator。这个地方是什么我们下一章会总体说明。因为guest是默认用户，所以它没有外网访问的权限，我们需要新建一个用户，才能完成不是非本地的连接。 添加一个用户，名为test，密码为test 1./rabbitmqctl add_user test test 为用户test赋予权限 1./rabbitmqctl set_permissions -p / test ".*" ".*" ".*" 在centos7开放端口，rabbitmq的默认端口是5672 1firewall-cmd --zone=public --add-port=5672/tcp --permanent 重启生效1firewall-cmd --reload 远程客户端访问一下试试吧。 所依赖的jar包 12345&lt;dependency&gt; &lt;groupId&gt;com.rabbitmq&lt;/groupId&gt; &lt;artifactId&gt;amqp-client&lt;/artifactId&gt; &lt;version&gt;5.1.1&lt;/version&gt;&lt;/dependency&gt; 123456789101112131415161718192021222324import com.rabbitmq.client.Channel;import com.rabbitmq.client.Connection;import com.rabbitmq.client.ConnectionFactory;public class Send &#123; private final static String QUEUE_NAME = "hello"; public static void main(String[] argv) throws Exception &#123; ConnectionFactory factory=new ConnectionFactory(); factory.setHost("192.168.14.128"); factory.setUsername("test"); factory.setPassword("test"); factory.setPort(5672); Connection connection = factory.newConnection(); Channel channel = connection.createChannel(); channel.queueDeclare(QUEUE_NAME, false, false, false, null); String message = "Hello World!"; channel.basicPublish("", QUEUE_NAME, null, message.getBytes()); System.out.println(" [x] Sent '" + message + "'"); channel.close(); connection.close(); &#125;&#125; 输出：]]></content>
      <tags>
        <tag>rabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[springBoot-1-简单实例]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F01%2F09%2FspringBoot-1-%E7%AE%80%E5%8D%95%E5%AE%9E%E4%BE%8B%2F</url>
    <content type="text"><![CDATA[使用idea构建Maven项目 idea-构建maven web项目 pom.xml123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;demo.msa&lt;/groupId&gt; &lt;artifactId&gt;msa-hello&lt;/artifactId&gt; &lt;!-- 步骤5 --&gt; &lt;packaging&gt;jar&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;msa-hello Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;!-- 步骤1 --&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;1.3.3.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!-- 步骤2 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!-- 步骤3 --&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-actuator&lt;/artifactId&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;3.8.1&lt;/version&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;msa-hello&lt;/finalName&gt; &lt;plugins&gt; &lt;!-- 步骤4 --&gt; &lt;plugin&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-maven-plugin&lt;/artifactId&gt; &lt;/plugin&gt; &lt;/plugins&gt; &lt;/build&gt;&lt;/project&gt; 步骤1：这样设置后，应用才是SpringBoot应用，该配置会继承大量的SpringBoot插件，但是这些插件都未启动。步骤2：spring boot集成了servlet容器，当我们在pom文件中增加spring-boot-starter-web的maven依赖时，不做任何web相关的配置便能提供web服务。步骤3：提供大量的生产机特性。步骤4：添加Maven插件。步骤5：将maven打包成jar包。 springBoot程序12345678910111213141516import org.springframework.boot.SpringApplication;import org.springframework.boot.autoconfigure.SpringBootApplication;/** * @author guojian * 简单的一个SpringBoot实例 */@SpringBootApplicationpublic class HelloAppalication &#123; public static void main(String[] args) &#123; SpringApplication.run(HelloAppalication.class,args); &#125;&#125; 在类中使用@SpringBootApplication注解，表示它是Spring Boot应用 在main()方法中通过SpringApplication的run()方法去运行该类 对外发布RESTAPI1234567891011121314151617import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import org.springframework.web.bind.annotation.RestController;/** * @author guojian * 一个简单的 控制层 */@RestControllerpublic class HelloController &#123; @RequestMapping(method = RequestMethod.GET,path = "/hello") public String hello()&#123; return "Hello"; &#125;&#125; 我们发现其实控制层与之前区别并不是很大，只是将@Controller换成了@RestController，@RestController表示它具备发布REST API的能力，并且将每个REST API的返回值自动序列化JSON格式。 注意控制层需要与你使用@SpringBootApplication注解的类在同一包下，负责无法找到这个controller。如果有疑问，可以看一下我之前写的有关spring全注解开发。 运行SpringBoot应用程序1、IDEA上直接运行 直接启动main函数就好了 2、打成jar包，使用java命令运行 首先将pom.xml中的步骤1改为jar包，然后在如图所示 运行过后会在项目的target目录下生成jar包，然后进入target目录下执行命令 java -jar msa-hello.jar 3、使用maven运行 mvn spring-boot:run 这就需要使用pom.xml中步骤4的插件了，如果你没有，那么就无法执行了 登录浏览器访问一下 这是因为我们找不到路径为空的方法，所以就返回的错误界面。如果出现这个界面说明我们的springBoot发布成功了。 给了指定的路径，我们可以访问到我们想要的内容了]]></content>
      <tags>
        <tag>微服务</tag>
        <tag>springBoot</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[微服务-1-了解微服务]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F01%2F08%2F%E5%BE%AE%E6%9C%8D%E5%8A%A1-1-%E4%BA%86%E8%A7%A3%E5%BE%AE%E6%9C%8D%E5%8A%A1%2F</url>
    <content type="text"><![CDATA[有关微服务的相关知识我是看《轻量级微服务架构》这本书作为我的微服务启蒙老师。 微服务解决哪些问题1、传统的架构，是当服务端发出请求后，一个应用程序会有若干个模块组成，Module A,Module B,Module C但是根据业务逻辑不同，C占用的系统资源比较高，运行一段时间，C就会成为整个系统的瓶颈。我们如何解决呢，就会使用分布式来将请求分流，来降低服务器的压力，使每个服务器的都能正常负载，叫做负载均衡。问题是得到了解决，但是相对于A，B来说，两个占用系统资源小，也同样因为C的原因进行了水平扩展，就会造成系统浪费。假设一下，一个互联网产品，每秒可能一个功能模块会被访问十多万次，水平扩展很有必要，项目中同样有一个模块只有管理员身份才能操作，而具有管理员权限的只有不到50人。那么管理员模块就没必要扩展这么多次，造成不必要的浪费。 2、越大的项目部署起来就需要越长的时间，加入你只改了一段代码，但是却要部署整个应用，部署效率太低。3、将单个模块服务可能有更适合的语言，就可以使用，而不是想传统项目一样必须都使用java，造成技术选型单一。 微服务架构要求：1、根据业务模块划分服务类型。2、每个服务可独立部署并且相互隔离。3、通过轻量级API调用服务。4、服务需保证良好的高可用性。 我们需要根据业务的模块进行划分，就基金系统来说来书用户模块、产品模块、订单模块等。其中，每个模块都可以独立的部署，且相互隔离，每个服务可以独立的启动，不会依赖于其他服务。项目应该少耦合，但是不可能没有耦合，那样就是毫不相关的两个事，如果想根据用户id获取他之前所有的订单，就是耦合，我们应该通过HTTP或RPC的方式来调用，目的是为了降低调用所产生的性能开销。高可用性，就是每个服务都是分布式的，不可能只有一个，当这个服务无法响应时，可以调用没有发生故障的服务。 微服务的特点1、服务颗粒化服务之间的颗粒度要尽可能的小，但是服务之间又不能有过多的依赖。 2、责任单一化用户模块只负责用户相关的功能，做到”单一职责原则”。什么是”单一职责原则”，我们平常做项目的时候，会有User类，以及他的功能类来处理相关逻辑，为什么不把他们放在一起呢，就是因为”单一职责原则”，POJO类只负责管理属性，功能类只负责处理逻辑。 3、运行隔离化 每个服务相互隔离，互不影响。每个服务都运行在自己的进程中，一个进程内部资源是共享的，不同的进程资源是不共享的，一个服务出现了问题，不会影响到其他的服务。 4、管理自动化 随着业务越来越多，服务的数量越来越多，需要对服务提供自动化部署与监控预警的能力。 微服务技术选型1、通过SpringBoot开发服务2、使用Docker封装服务3、使用Zookeeper注册服务4、使用Node.js调用服务5、使用Jenkins部署服务]]></content>
      <tags>
        <tag>微服务</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[设计模式-单例模式]]></title>
    <url>%2Fguojian731.github.io%2F2018%2F01%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F-%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[单例模式饿汉模式1234567891011121314public class Singleton &#123; private Singleton&#123; &#125; private static Singleton instance=new Singleton(); public static Singleton getInstance()&#123; return instace; &#125; &#125; 饿汉模式是一种简单并且有效的一种单例模式的实现方法，当Singleton类被装载的时候就会创建新的对象。构造器创建为私有的，这样外部就不能新建这个类。它唯一一点让人觉得不好的，就是不知道什么时候对象实例被创建出来，当然我们这个例子只有调用getInstance()的时候这个类才会被装载。但是如果我们在Singleton类中加上public static String type=”type-1”;这句话的时候，在其他类中调用Singleton.type的时候，Singleton的类就会装载，在初始化的时候就会调用了new Singleton()。如果对类什么时候被装载有疑问，送你一张飞机票 JVM-4-装载（加载、连接、初始化） 懒汉模式12345678910111213141516public class Singleton &#123; private Singleton()&#123; &#125; private static Singleton instance; public static synchronized Singleton getInstace()&#123; if (instance==null)&#123; instance=new Singleton(); &#125; return instance; &#125;&#125; 懒汉模式就是当Singleton被装载时，instance为null，只有调用getInstace()的时候判断instance是否为null，为null的时候在进行创建。因为考虑可能是多线程一起调用getInstace()，所以前面方法用synchronized修饰，防止对象多次被创建的情况。这种场景在竞争比较激烈的情况下，会对效率产生一定的影响。 使用内部类还有一种双重检查策略，但是并不推荐，因为它在低版本的JDK中不能保证准确性。有一种方式结合了第一种和第二种的有点，就是使用内部类创建单例模式。 12345678910111213141516public class Singleton &#123; private Singleton()&#123; &#125; private static class SingleHander&#123; private static Singleton instance=new Singleton(); &#125; public static Singleton getInstace()&#123; return SingleHander.instance; &#125;&#125; 首先将内部类SingleHander设置为private的，让外部无法访问到SingleHander类。那么只有调用Singleton.getInstace()才会创建Singleton对象，首先getInstace()方法没有synchronized修饰，所以它不会有线程多线程竞争的情况，而根据JVM装载的特性，只有第一个调用SingleHander.instanc才会创建Singleton实例。]]></content>
      <tags>
        <tag>设计模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程-并发包]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F26%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E5%B9%B6%E5%8F%91%E5%8C%85%2F</url>
    <content type="text"><![CDATA[因为本人的知识有限，并发包里我指挥记录一些我个人理解相对比较深的，之后会在慢慢的学习和实践中继续更近我的博客。 重入锁重入锁完全可以代替synchronized关键字。在jdk1.5以前，重入锁的性能远大于synchronized，但是在jdk1.6之后，两者的性能差别不大。 核心方法lock.lock():进行上锁操作;lock.unclock():解锁操作;lock.lockInterruptibly()：获得锁，但是优先相应中断。lock.tryLock(): 判断当前锁是否被占用，如果没有被占用，返回true，并且占有锁。如果被占用，返回false，那么直接退出。lock.tryLock(Long time,TimeUnit unit):time是代表时间，unit代表单位，在设置的给定时间内获得锁。lock.isHeldByCurrentThread():判断当前线程是否占有锁，true是占有。lock.interrupt():锁中断； 简单的例子重入锁的使用java.util.concurrent.ReentrantLock类来实现。下面是一个重入锁的例子。 1234567891011121314151617181920212223242526272829import java.util.concurrent.locks.ReentrantLock;public class Test implements Runnable&#123; private int i=0; private static ReentrantLock lock =new ReentrantLock(); @Override public void run() &#123; for (int k=0;k&lt;10000;k++)&#123; lock.lock(); try&#123; i++; &#125;finally &#123; lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test test=new Test(); Thread t1=new Thread(test,"t1"); Thread t2=new Thread(test,"t2"); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(test.i); &#125;&#125; 这里使用lock锁住临界区的资源i，确保多线程对i进行操作的安全性，他还有一个好处，就是synchronized是修饰不了int的，只能修饰Integer类型，因为synchronized只能修饰对象，而int不是对象，是基本类型。 为什么ReentrantLock叫做重入锁呢，因为一个锁可以锁对象多次。但是锁住锁和释放锁的数量应该是一样的，只加锁而不释放锁，会让线程一直占有锁，从而使其他线程一直阻塞。 12345678910111213141516171819202122232425262728293031import java.util.concurrent.locks.ReentrantLock;public class Test implements Runnable&#123; private int i=0; private static ReentrantLock lock =new ReentrantLock(); @Override public void run() &#123; for (int k=0;k&lt;10000;k++)&#123; lock.lock(); lock.lock(); try &#123; i++; &#125;finally &#123; lock.unlock(); lock.unlock(); &#125; &#125; &#125; public static void main(String[] args) throws InterruptedException &#123; Test test=new Test(); Thread t1=new Thread(test,"t1"); Thread t2=new Thread(test,"t2"); t1.start(); t2.start(); t1.join(); t2.join(); System.out.println(test.i); &#125;&#125; 中断响应 我们再使用synchronized的时候，如果一个线程在等待锁，要不一直在那等待，要不获得锁继续执行，没有第二种可能。但是如果使用重入锁，那么你将会有第三种可能，就是根据需求取消对锁的请求。如果一个线程正在等待锁，那么他依然可能收到一个通知，被告知无须等待，可以停止工作了，这样就减少了死锁。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import java.util.concurrent.locks.ReentrantLock;public class LockTest implements Runnable&#123; public static ReentrantLock lock1=new ReentrantLock(); public static ReentrantLock lock2=new ReentrantLock(); int lock; public LockTest(int lock)&#123; this.lock=lock; &#125; @Override public void run() &#123; try &#123; if (lock==1)&#123; lock1.lockInterruptibly(); System.out.println(Thread.currentThread().getName()+" 持有了锁lock1"); Thread.sleep(10000); lock2.lockInterruptibly(); System.out.println(Thread.currentThread().getName()+" 持有了锁lock2"); &#125;else &#123; lock2.lockInterruptibly(); System.out.println(Thread.currentThread().getName()+" 持有了锁lock2"); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; lock1.lockInterruptibly(); System.out.println(Thread.currentThread().getName()+" 持有了锁lock1"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; if (lock1.isHeldByCurrentThread())&#123; lock1.unlock(); &#125; if (lock2.isHeldByCurrentThread())&#123; lock2.unlock(); &#125; &#125; &#125; public static void main(String[] args) &#123; LockTest test1=new LockTest(1); LockTest test2=new LockTest(2); Thread t1=new Thread(test1,"t1"); Thread t2=new Thread(test2,"t2"); t1.start(); t2.start(); try &#123; Thread.sleep(10000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t2.interrupt(); &#125;&#125; 在这个例子中，我们一个类有两个锁，线程t1先持有lock1，在持有lock2。而线程t2持有lock2，在持有lock1，因为我们使用了Thread.sleep(),确定了t1获得了lock1的锁，而t2获得了lock2的锁，这样就会产生死锁，在线程运行的十秒钟里(Thread.sleep(10000))，一直没有人释放资源，就是两个线程就会一直锁死，当主线程出来解决矛盾，让t2取消请求，t2就会释放锁lock2，这样t1就会获得了锁lock2。 给请求设置时间我们可以用tryLock()方法来给请求设置时间，它有两个参数，一个是数值，另一个是时间单位。lock.tryLock(5, TimeUnit.SECONDS)就是如果请求如果等待了5秒钟以上，就退出。如果为设置参数，那么就是请求的时候有其他线程持有锁，就退出。如果没有线程持有锁，就执行。 12345678910111213141516171819202122232425262728293031323334353637383940import java.util.concurrent.TimeUnit;import java.util.concurrent.locks.ReentrantLock;public class ThreadTimeExample implements Runnable&#123; public static ReentrantLock lock=new ReentrantLock(); @Override public void run() &#123; try &#123; if (lock.tryLock(5, TimeUnit.SECONDS)) &#123; Thread.sleep(6000); System.out.println(Thread.currentThread().getName()+"执行了"); &#125;else &#123; System.out.println(Thread.currentThread().getName()+"未执行"); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; if (lock.isHeldByCurrentThread()) lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; ThreadTimeExample t=new ThreadTimeExample(); Thread t1=new Thread(t,"t1"); Thread t2=new Thread(t,"t2"); Thread t3=new Thread(t,"t3"); t1.start(); t2.start(); try &#123; Thread.sleep(2000); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; t3.start(); &#125;&#125; 我们新建了三个线程t1，t2,t3三个线程，因为t1,t2几乎同时启动，假设t1先持有锁(因为t1，t2都有机会先获得锁)，持有了锁6s，超过了t2等待时间5s，所以t2就不会运行而是选择退出。当t1运行2s中之后，t3才开始请求锁，相对于t3而言，t1持有锁的时间为大约为4s，没超过5s，所以t3也会执行的。 我们要注意一下finally的方法，当我们把finally的方法去掉，看一下运行情况。 发现只有t1线程获得了锁，其他线程都没获得到锁，t2没有获得锁正常，是在我们的预想之内，为什么t3也没获得锁呢，这是不应该的。那是因为t1在获得锁之后，没有执行lock.unlock()来释放锁，所以它持有锁的时间并不是6s而是更长。好了，我们知道原因了，我们在finally代码快中添加lock.unlock()方法，运行看一下结果把。 我们发现竟然报错了，为什么呢？其实真正的原因就是线程t2，t2根本没有获得过锁，我们执行lock.unlock()当然报错了，之前我们就说过，锁的持有和释放必须是等对的，t2没有获得锁，却要释放锁，当然要报错了。所以我们要在释放锁之前做一下判断当前线程是否获得过锁 （lock.isHeldByCurrentThread())，如果获得过，释放。 lock设置公平锁在锁的竞争中，锁被占用并不是根据来的先后顺序来进行获得锁的，就会出现后来者居上的情况，如何对获得锁需要按照先后顺序来呢，synchronized就无法实现了，但是ReenTrantLock可以。设置起来也很简单，就是在新建Lock对象的是够，传参true。 123456789101112131415161718192021222324252627import java.util.concurrent.locks.ReentrantLock;public class FairReenTrantLock implements Runnable&#123; private static ReentrantLock lock=new ReentrantLock(true); @Override public void run() &#123; for (int i=0;i&lt;10;i++)&#123; lock.lock(); System.out.print(Thread.currentThread().getName()+" "); lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; FairReenTrantLock lock=new FairReenTrantLock(); Thread t1=new Thread(lock,"t1"); Thread t2=new Thread(lock,"t2"); Thread t3=new Thread(lock,"t3"); Thread t4=new Thread(lock,"t4"); t1.start(); t2.start(); t3.start(); t4.start(); &#125;&#125; 我们看一下结果，因为最开始的时候，有线程还处于未启动状态，当线程全部启动后，他们获取锁是有顺序的，最先得到锁的线程释放锁之后，就或在申请锁，所以轮一圈后，它依旧先获得锁。 Condition条件它的作用是在可重入锁下ReentrantLock实现wait(),notify()以及notifyAll()的功能，Object.wait()和Object.notify()必须在synchronized修饰的方法块里才能使用，同样的Condition需要与重入锁相关联，在lock.newCondition()来为重入锁绑定一个Condition实例。下面是一个Condition接口方法以及使用Condition的简单实现。 123456789101112131415public interface Condition &#123; void await() throws InterruptedException; void awaitUninterruptibly(); long awaitNanos(long var1) throws InterruptedException; boolean await(long var1, TimeUnit var3) throws InterruptedException; boolean awaitUntil(Date var1) throws InterruptedException; void signal(); void signalAll();&#125; 12345678910111213141516171819202122232425262728293031323334353637import java.util.concurrent.locks.Condition;import java.util.concurrent.locks.ReentrantLock;public class ReentranctLockConditine implements Runnable&#123; public static ReentrantLock lock =new ReentrantLock(); public static Condition condition=lock.newCondition(); @Override public void run() &#123; lock.lock(); try &#123; condition.await(); System.out.println(Thread.currentThread().getName()+"线程继续运行"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; lock.unlock(); &#125; &#125; public static void main(String[] args) &#123; try &#123; ReentranctLockConditine reentranctLockConditine=new ReentranctLockConditine(); Thread t=new Thread(reentranctLockConditine,"t1"); t.start(); Thread.sleep(2000); lock.lock(); condition.signalAll(); lock.unlock(); System.out.println("主线程结束了"); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 首先我们在main()方法中建立一个线程并启动，线程获得锁后，执行 condition.await();，要求condition在这个对象上进行等待，这时候线程会释放锁和资源，当condition.signalAll();会唤醒所有的资源，之前的锁又会尝试绑定之前的锁，这期间，需要获得锁的线程(也就是现在的主线程main方法)释放锁，要不然线程t1就会只与锁进行绑定，而不会获得锁。如果你讲33行的代码注掉的话，你会发现t1是无法执行到输入的语句的。 Condition优点其实Condition对比wait()有自己的优势， 首先是它的await(long var1, TimeUnit var3)，返回true的时候，说明是其他线程唤醒它的，返回false是因为达到了超时时间自己唤醒的。还有awaitUntil(Date var1)可以设置时间点，在现实场景中应用也是比较广泛的。 一个ReentrantLock下可以有多个Condition对象，我们在做业务处理时，可以根据共享变量场景不同，使用不同的Condition，然后避免过早唤醒问题(即一些线程不满足条件依然被唤醒之后，发现条件不符合之后，再次将状态变成等待)。下面我们开始举个例子 Q：现在有一个房地产开发商发放礼物，总共有十个柜台，如果柜台有空余的话，买房的人(vip)和没买房的人(normal)都可以领取礼物，当时一旦发放礼物的柜台都满的情况下，当空出柜台的时候，优先给vip办理，normal只能在没有vip等待的时候才能过去领取奖励。 A： 柜台代表类：123456789101112131415161718192021222324252627282930313233343536373839404142public class Counter &#123; private static Lock lock=new ReentrantLock(); private static Condition vipCondition=lock.newCondition();//vip的Condition private static Condition normalCondition=lock.newCondition();//普通用户的Condition private ConcurrentHashMap vipWaitMap=new ConcurrentHashMap();//记录等待的vip用户 private AtomicInteger amout=new AtomicInteger(10);//柜台数 public void take(String type,int i) throws InterruptedException &#123; lock.lock(); try &#123; while (amout.get()&lt;=0)&#123; if (type.equals("vip"))&#123; vipWaitMap.put(i,i);//记录等待的vip用户 System.out.println(new StringBuffer("vip，号码为:").append(i).append("进行等待")); vipCondition.await(); &#125; if (type.equals("normal"))&#123; System.out.println(new StringBuffer("normal，号码为:").append(i).append("进行等待")); normalCondition.await(); &#125; &#125; System.out.println(new StringBuffer("正在处理，客户类型为：").append(type) .append("，序号为：").append(i).append("的客户")); amout.decrementAndGet();//处理业务，需要占用一个柜台 &#125;finally &#123; lock.unlock(); &#125; Thread.sleep(2000);//模拟业务处理耗时 amout.incrementAndGet();//业务处理完，柜台空余出来 vipWaitMap.remove(i);//如果这个号码之前被记录过vip等待，移除。 lock.lock(); vipCondition.signalAll();//为了更好展现，释放所有vip等待线程 if (vipWaitMap.size()==0)&#123; normalCondition.signalAll();//如果vipWaitMap为0，说明没有vip进行等待，唤醒所有普通用户。 &#125; lock.unlock(); &#125;&#125; 封装线程： 12345678910111213141516171819public class CounterThread implements Runnable &#123; private Counter counter; private String type; private int i; public CounterThread(Counter counter,String type,int i)&#123; this.counter=counter; this.type=type; this.i=i; &#125; @Override public void run() &#123; try &#123; counter.take(type,i); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125;&#125; 客户端： 1234567891011121314151617public class Client &#123; public static void main(String[] args) &#123; String [] table=&#123;"normal","vip","normal","vip", "normal","vip","normal","vip", "normal","vip","normal","vip", "normal","vip","normal","vip", "normal","vip","normal","vip", "normal","vip","normal","vip", "normal","vip","normal","vip", "normal","vip","normal","vip"&#125;; Counter counter=new Counter(); for (int i=0;i&lt;table.length;i++)&#123; Thread thread=new Thread(new CounterThread(counter,table[i],i)); thread.start(); &#125; &#125;&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273正在处理，客户类型为：normal，序号为：0的客户正在处理，客户类型为：vip，序号为：1的客户正在处理，客户类型为：normal，序号为：2的客户正在处理，客户类型为：vip，序号为：3的客户正在处理，客户类型为：normal，序号为：4的客户正在处理，客户类型为：vip，序号为：5的客户正在处理，客户类型为：normal，序号为：6的客户正在处理，客户类型为：vip，序号为：7的客户正在处理，客户类型为：normal，序号为：8的客户正在处理，客户类型为：vip，序号为：9的客户normal，号码为:10进行等待vip，号码为:11进行等待normal，号码为:12进行等待normal，号码为:14进行等待vip，号码为:15进行等待normal，号码为:16进行等待vip，号码为:17进行等待normal，号码为:18进行等待vip，号码为:19进行等待normal，号码为:20进行等待vip，号码为:21进行等待normal，号码为:22进行等待vip，号码为:23进行等待normal，号码为:24进行等待vip，号码为:25进行等待normal，号码为:26进行等待vip，号码为:27进行等待normal，号码为:28进行等待vip，号码为:13进行等待normal，号码为:30进行等待vip，号码为:29进行等待vip，号码为:31进行等待正在处理，客户类型为：vip，序号为：11的客户vip，号码为:15进行等待vip，号码为:17进行等待vip，号码为:19进行等待vip，号码为:21进行等待vip，号码为:23进行等待vip，号码为:25进行等待vip，号码为:27进行等待vip，号码为:13进行等待vip，号码为:29进行等待vip，号码为:31进行等待正在处理，客户类型为：vip，序号为：15的客户vip，号码为:17进行等待vip，号码为:19进行等待正在处理，客户类型为：vip，序号为：21的客户vip，号码为:23进行等待正在处理，客户类型为：vip，序号为：25的客户正在处理，客户类型为：vip，序号为：27的客户正在处理，客户类型为：vip，序号为：13的客户vip，号码为:29进行等待vip，号码为:31进行等待vip，号码为:17进行等待正在处理，客户类型为：vip，序号为：19的客户正在处理，客户类型为：vip，序号为：23的客户vip，号码为:29进行等待正在处理，客户类型为：vip，序号为：31的客户正在处理，客户类型为：vip，序号为：17的客户vip，号码为:29进行等待正在处理，客户类型为：vip，序号为：29的客户正在处理，客户类型为：normal，序号为：10的客户正在处理，客户类型为：normal，序号为：12的客户正在处理，客户类型为：normal，序号为：14的客户正在处理，客户类型为：normal，序号为：16的客户正在处理，客户类型为：normal，序号为：18的客户正在处理，客户类型为：normal，序号为：20的客户正在处理，客户类型为：normal，序号为：22的客户正在处理，客户类型为：normal，序号为：24的客户正在处理，客户类型为：normal，序号为：26的客户正在处理，客户类型为：normal，序号为：28的客户normal，号码为:30进行等待正在处理，客户类型为：normal，序号为：30的客户 CountDownLatch:倒计时协调器Thread.join()的实现是一个线程等待另一个线程结束，但是有时候一个线程做到中间的一个关键步骤，就可以使其他线程线程继续运行，而不必等在这个线程终止。我们可以使用代码来执行，但是我们可以使用java.util.concurrent.CountDownLatch来解决。 public CountDownLatch(int i)在创建一个CountDownLatch对象时要传入一个数字作为计数器，CountDownLatch.countDown()每次执行一次就会使计数器-1。CountDownLatch.wait()的方法保护条件，执行的时候判断一下计数器的值是否为0，当不为0的时候，线程将变成等待状态，等到计数器为0的时候，线程被唤醒。CountDownLatch的使用是一次性的，一个CountDownLatch实例只能够实现一次等待和唤醒。 CountDownLatch内部实现了对”全部先决操作已执行完毕”(计数器值为0)这个保护条件的等待和通知的逻辑，所以它在使用await、coutDown的时候都无须加锁，不需要加锁，不需要加锁，不需要加锁！！！ Q:一个项目有n个服务器，启动命令后，服务开始启动，当每个服务器均启动成功了，才算真正的启动成功，如果有任何一个服务器没有成功，将作为失败，如何实现？ A： 不管我们启动服务成功或者失败，我们都必须调用countDownLatch.countDown()，否则CountDownLatch的计数器会一直无法达到0，就会一直处于等待状态。 服务器类： 12345678910111213141516171819202122232425262728293031public class ComputerServer implements Runnable&#123; private CountDownLatch countDownLatch; private Boolean isStarted =false; public ComputerServer(CountDownLatch countDownLatch) &#123; this.countDownLatch = countDownLatch; &#125; @Override public void run() &#123; try&#123; doStart(); isStarted=true; &#125;catch (Exception e)&#123; //异常的时候进行处理 &#125;finally &#123; countDownLatch.countDown(); &#125; &#125; private void doStart() &#123; //服务启动方法 &#125; public Boolean isStarted()&#123; return isStarted; &#125; &#125; 1234567891011121314151617181920212223242526272829303132333435363738public class Client &#123; private static CountDownLatch countDownLatch; public static void main(String[] args) &#123; Boolean isAllOk=true; List&lt;ComputerServer&gt;list= servicesStart(); try &#123; countDownLatch.await(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; for (ComputerServer computerServer:list)&#123; if (!computerServer.isStarted())&#123; isAllOk=false; break; &#125;else &#123; System.out.println("服务器启动成功"); &#125; &#125; &#125; private static List servicesStart() &#123; countDownLatch=new CountDownLatch(3); List&lt;ComputerServer&gt; list =new ArrayList&lt;&gt;(); list.add(new ComputerServer(countDownLatch)); list.add(new ComputerServer(countDownLatch)); list.add(new ComputerServer(countDownLatch)); for (ComputerServer computterServer:list)&#123; Thread thread=new Thread(computterServer); thread.start(); &#125; return list; &#125; &#125;]]></content>
      <tags>
        <tag>java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程-线程状态]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F26%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B-%E7%BA%BF%E7%A8%8B%E7%8A%B6%E6%80%81%2F</url>
    <content type="text"></content>
      <tags>
        <tag>java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础-AIO、BIO、NIO]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F19%2Fjava%E5%9F%BA%E7%A1%80-AIO%E3%80%81BIO%E3%80%81NIO%2F</url>
    <content type="text"><![CDATA[基础概念同步与异步同步（Synchronous）和异步（Asynchronous）通常用来形容一次方法的调用。同步方法一旦调用，调用者必须等到方法调用返回后，才能进行后续的操作。就像我们普通的java程序一样，在一个线程内有顺序的方法A，B，C。程序在A执行完返回后才能执行B，B执行完返回后才能执行C；而异步是更像是消息传递，当线程调用A的时候，就会立即返回，不会等A执行过，调用者就会进行后续的操作。而A方法会在另一个线程下继续工作。整个过程不影响调用者的工作，对于调用者来说，调用方法A()相当于一瞬间完成的。如果A方法完成并且有结果的时候，后通知调用者。我们经常用到的ajax默认就是异步的呢，我曾经遇到过这种情况，在一个function下，创建一个变量var ss=””,然后调用ajax向后台进行业务逻辑，返回ss的值。然后function下在对ss进行操作，但是发生了一种情况，在debug时，发现ss已经在后台赋予了非空的值，但是接收的时候ss还是为空，那就是因为ajax是异步实现的方式，使用了另一个线程在运行线程，而function还会往下进行，这时候ajax还没有返回值，ss依旧是空。 阻塞和非阻塞阻塞（Blocking）和非阻塞（Non-Blocking）通常用来多线程的相互影响，比如一个线程占用了临界区资源，那个其他所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程的挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行，所有的线程都会尝试不断向前执行。 IO比较IO操作分为两种，一种是文件IO，另一种是网络IO；那么从网络IO中进行比较，这篇文章是看《实战Java高并发程序设计》中作为启蒙，很推荐这本书，也非常感谢。 BIOBIO就是使用IO包进行操作，它的意思是”Blocking-IO”,也就是（同步）阻塞IO。服务端在接收信息时，需要等客户端执行过后才能进行下面的操作，如果客户端存在网络延迟，那么服务器端就会一直等待。网络IO分为服务器端和客户端进行通讯，一般情况下，服务器端一直运行等待客服端的连接，而服务器端是创建一个连接，处理完成够客户端就进行关闭。在java中，服务器端使用ServerSocket，而客户端使用Socket，它们都在java.net包下。在下面的介绍中，如果我说的是socket那么代表的就是客户端，如果是服务器端，我会进行特殊说明。 BIO Server1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586package io;import java.io.*;import java.net.ServerSocket;import java.net.Socket;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;public class MultiThreadEchoServer &#123; //创建一个线程池 private static ExecutorService tp= Executors.newCachedThreadPool(); static class HandleMsg implements Runnable&#123; Socket clientSocket; public HandleMsg(Socket clientSocket)&#123; this.clientSocket=clientSocket; &#125; public void run() &#123; BufferedReader is=null; PrintWriter os=null; try &#123; is =new BufferedReader(new InputStreamReader(clientSocket.getInputStream())); os=new PrintWriter(clientSocket.getOutputStream(),true); //从InputStream当中读取客户端所发送的数据 String inputLine=null; long b=System.currentTimeMillis(); while ((inputLine=is.readLine())!=null)&#123; System.out.println("服务器进来了"); os.println(inputLine); &#125; long e=System.currentTimeMillis(); System.out.println("spend:"+(e-b)+"ms"); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (is!=null) is.close(); if (os!=null) os.close(); clientSocket.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; ServerSocket echoServer=null; Socket clientSocket=null; try &#123; echoServer=new ServerSocket(8000); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; while (true)&#123; try &#123; clientSocket=echoServer.accept(); System.out.println(clientSocket.getRemoteSocketAddress()+"connect!"); tp.execute(new HandleMsg(clientSocket)); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 我们开始从main函数开始讲解。在main()函数我们先建立ServerSocket并设置端口号8000和客户端socket，客户端的socket需要从echoServer.accept()中获取，这个方法是阻塞的，如果这里没有连接进行连接，那么就会一直被阻塞，主线程会一直运行，并且你在控制台永远看不到输出的”connect”。当有客户端进行连接并成功后，那么就会输出客户端的地址连接。我们使用线程池来处理客户端每一个连接，这样的好处就是服务器端支持多线程，在相同的可支持的的线程范围内，可以尽量多的支持客户端的数量。我们定义的是HandleMsg线程，它的构造器要求它传入一个客户端socket，它的任务是读取socket的内容并将其返回，任务成功后，客户端的socket就会正常关闭。在HandleMsg中，我们记录了服务器线程处理客户端一次请求所使用的时间。在HandleMsg的run()方法中，我们设计是从客户端获取数据并且向客户端返回数据，在输入流和输出流都指向客户端，所以我们在输入流和输出流定义时，要赋值客户端的socket。 BIO 简单的客户端123456789101112131415161718192021222324252627282930313233343536373839404142package io;import java.io.*;import java.net.InetSocketAddress;import java.net.Socket;/** * io客户端 同步阻塞 */public class IOSocketClient &#123; public static void main(String[] args) throws IOException&#123; Socket client=null; PrintWriter writer=null; BufferedReader reader=null; try &#123; client=new Socket(); client.connect(new InetSocketAddress("localhost",8000)); writer=new PrintWriter(client.getOutputStream(),true); writer.println("hello"); writer.flush(); reader=new BufferedReader(new InputStreamReader(client.getInputStream())); System.out.println("from server " +reader.readLine()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (client!=null) client.close(); if (writer!=null) writer.close(); if (reader!=null) reader.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125;&#125; 我们测试一下我们的服务端是否能够正常启动，运行main()函数，查看一下运行结果，发现的确一直在阻塞状态。 启动客户端。 查看服务器端控制台。 BIOClient 存在网络延迟前面的例子，发现速度很快完成了客服端和服务器端的交互，但是会出现一种情况，就是客户端存在网络延迟，那么客户端运行了多长时间，那么服务器端就会在处理这个线程的时候被阻塞多长时间。我们在测试的时候，会用到Thread.sleep()来模拟网络延迟，我们看一下效果。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package io;import java.io.*;import java.net.InetSocketAddress;import java.net.Socket;import java.net.SocketAddress;import java.util.concurrent.Executor;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors;/** * 客户端存在网络延迟 */public class HeavySocketClient &#123; private static ExecutorService tp= Executors.newCachedThreadPool(); private final static int sleep_time=1000; public static class EchoClient implements Runnable&#123; public void run() &#123; synchronized (this)&#123; &#125; Socket client=null; PrintWriter writer=null; BufferedReader reader=null; try &#123; client=new Socket(); client.connect(new InetSocketAddress("localhost",8000)); writer=new PrintWriter(client.getOutputStream(),true); writer.print("h"); Thread.sleep(sleep_time); writer.print("e"); Thread.sleep(sleep_time); writer.print("l"); Thread.sleep(sleep_time); writer.print("l"); Thread.sleep(sleep_time); writer.print("o"); Thread.sleep(sleep_time); writer.println(); writer.flush(); reader=new BufferedReader(new InputStreamReader(client.getInputStream())); System.out.println("form server : "+reader.readLine()); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; if (writer!=null) writer.close(); if (reader!=null) reader.close(); if (client!=null) client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; EchoClient echoClient=new EchoClient(); //for (int i=0;i&lt;=5;i++) &#123; tp.execute(echoClient); //&#125; &#125;&#125; 可以看到,服务器端耗费了比较长的时间。因为服务器要先读入客户端的输入，而客户端缓慢的处理速度使的服务器花费了更多的时间。在这个案例中，我们可以将main函数的for循环打开，就会有产生五个线程。但是我们有100线程同时请求，假设我们线程池里面只有10个线程可供使用，那么其他的90个就会等待线程池里的线程里可以使用的线程，那么这样服务器因为客户端的缓慢势必会影响到并发。在这个案例中，服务器请求缓慢不是因为服务器端有多少繁重的任务，而是因为服务器线程在等待IO。 让告诉运转的CPU去等待效率低下的网络IO是极其不合算的。我们如何使用一种方式，使网络IO的等待时间从线程中分离出来。 NIO上述的问题，使用NIO就可以将网络IO的等待时间从线程中分离出来。NIO中一个关键组件是channel()，他的意思是管道。channel类似于流，一个channel可以跟一个文件或者网络Socket对应。如果一个channel对应一个文件和网络Socket，那么往这个channel中写数据，就相当于往Socket中写数据。和channel结合使用的是另一个组件Buffer，Buffer相当于一个内存区域或者byte数组。数据需要包装成Buffer形式才能与channel进行交互(写入或者读取)。另外一个与channel组件相关的是Selector(选择器)。在channel的众多实现中，有一个SelectableChannel的实现，表示可以被选择的通道。任何一个SelectableChannel都可以注册到一个selector中。这样，这个channel就会被selector管理。而一个selector可以管理多个channel。当SelectableChannel的数据准备好之后，Selector就会接到通知，得到那些已经准备好的数据。而SocketChannel就是SelectableChannel的一种。 我们创建一个线程Selector来管理channel，而一个SocketChannel代表一个客户端的连接，因此是selector处理多个客户端连接，当客户端的数据没有准备好的时候，selector处于准备状态，一旦有任何一个SocketChannel准备好数据之后，Selector就能立即得到通知，获取数据进行处理。 NIO Serverpackage io; import java.io.IOException;import java.net.InetAddress;import java.net.InetSocketAddress;import java.net.Socket;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.ServerSocketChannel;import java.nio.channels.SocketChannel;import java.nio.channels.spi.SelectorProvider;import java.util.*;import java.util.concurrent.ExecutorService;import java.util.concurrent.Executors; 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175public class NioServer &#123; private Selector selector; private ExecutorService tp= Executors.newCachedThreadPool(); public static Map&lt;Socket,Long&gt; time_stat=new HashMap&lt;Socket, Long&gt;(10240); private void startServer()&#123; try &#123; //通过工厂创建一个selector selector= SelectorProvider.provider().openSelector(); //获得一个服务器端channel的实例 ServerSocketChannel scc=ServerSocketChannel.open(); //将服务器端设置为非阻塞模式 scc.configureBlocking(false); InetSocketAddress isa=new InetSocketAddress(8000); //为服务器channel绑定地址和端口号 scc.socket().bind(isa); //注释1 将服务器channel绑定到selector上，并且将selector感兴趣的事件记录为"accept" SelectionKey acceptkey=scc.register(selector,SelectionKey.OP_ACCEPT); //for循环，它的任务就是等待-分发网络消息 for (;;)&#123; /** *select()方法是一个阻塞的方法，当没有任何数据准备的时候，他就会等待。 *一旦有数据，他就会立即返回。他的返回值是已经准备就绪的selectionKey。 **/ selector.select(); /** *获取准备好的selectionKey，因为Selector为多个Channel服务，所以 *已经就绪的Channel可能是多个，所以是一个集合。 **/ Set readyKeys = selector.selectedKeys(); Iterator i = readyKeys.iterator(); long e=0; while(i.hasNext())&#123; SelectionKey sk= (SelectionKey) i.next(); //将SelectionKey移除，如果不移除，就会重复处理相同的SelectionKey i.remove(); //判断selectionKey的状态是否是可接收状态，如果是，就执行doAccept()方法。 if (sk.isAcceptable())&#123; doAccept(sk); &#125; else if(sk.isValid() &amp;&amp; sk.isReadable())&#123; if (!time_stat.containsKey( ((SocketChannel)sk.channel()).socket()))&#123; time_stat.put(((SocketChannel)sk.channel()).socket(),System.currentTimeMillis()); &#125; doRead(sk); &#125; else if(sk.isValid() &amp;&amp; sk.isWritable())&#123; doWrite(sk); e=System.currentTimeMillis(); long b=time_stat.remove(((SocketChannel)sk.channel()).socket()); System.out.println("spend="+(e-b)+"ms"); &#125; &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void doRead(SelectionKey sk) &#123; SocketChannel channel=(SocketChannel) sk.channel(); ByteBuffer bb=ByteBuffer.allocate(8192); int len; try &#123; len =channel.read(bb); if (len&lt;0) &#123; disconnect(sk); return; &#125; &#125; catch (IOException e) &#123; System.out.println("Failed to read form client !!"); e.printStackTrace(); disconnect(sk); return; &#125; bb.flip(); tp.execute(new HandleMsg(sk,bb)); &#125; private void disconnect(SelectionKey sk) &#123; &#125; private void doWrite(SelectionKey sk) &#123; SocketChannel channel= (SocketChannel) sk.channel(); EchoClient echoClient= (EchoClient) sk.attachment(); LinkedList&lt;ByteBuffer&gt; outq=echoClient.getOutputQueue(); ByteBuffer bb= outq.getLast(); try &#123; int len=channel.write(bb); if (len == -1)&#123; disconnect(sk); return; &#125; if (bb.remaining()==0)&#123; outq.removeLast(); &#125; &#125; catch (IOException e) &#123; System.out.println("Failed to write client."); e.printStackTrace(); disconnect(sk); &#125; if (outq.size()==0)&#123; sk.interestOps(SelectionKey.OP_READ); &#125; &#125; private void doAccept(SelectionKey sk) &#123; //System.out.println("doAccept"); ServerSocketChannel server=(ServerSocketChannel) sk.channel(); SocketChannel clientChannel; try &#123; //根据ServerSocketChannel获取clientChannel clientChannel= server.accept(); clientChannel.configureBlocking(false); SelectionKey clientKey=clientChannel.register(selector,SelectionKey.OP_READ); EchoClient echoClient=new EchoClient(); clientKey.attach(echoClient); InetAddress clientAddress=clientChannel.socket().getInetAddress(); System.out.println("Accepted connection from "+clientAddress.getHostAddress()); &#125; catch (IOException e) &#123; System.out.println("fail to accept new client."); e.printStackTrace(); &#125; &#125; class HandleMsg implements Runnable&#123; SelectionKey sk; ByteBuffer bb; public HandleMsg(SelectionKey sk,ByteBuffer bb)&#123; this.sk=sk; this.bb=bb; &#125; public void run() &#123; EchoClient echoClient= (EchoClient) sk.attachment(); echoClient.enqueue(bb); sk.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE); selector.wakeup(); &#125; &#125; public static void main(String[] args) &#123; NioServer nioServer=new NioServer(); nioServer.startServer(); &#125;&#125; 我们先创建一个选择器Selector和连接池。连接池是为客户端建立线程，每一个请求都会委托线程池中的线程来进行实际的处理。为了能够统计一个线程在服务器中所话费的时间，我们定义了与时间有关的类： 1public static Map&lt;Socket,Long&gt; time_stat=new HashMap&lt;Socket, Long&gt;(10240); 他是一个hashMap，key是一个socket，value是代表服务器端处理该请求处理的时间。 注释1：因为我们设置selector感兴趣的事件为SelectionKey.OP_ACCEPT，那么只要当客户端进行连接时，就会通知ServerSocketChannel进行处理。register()的返回值是一个SelectionKey，SelectionKey代表这selector和channel的一种关系。当channel注册到selector上时，就已经确立了两者的服务关系。那么selector就是这个契约，如果selector或者channel被关闭时，他们对应的selectionKey就会失效。 NIO Client123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596package io;import java.io.IOException;import java.net.InetSocketAddress;import java.net.SocketAddress;import java.nio.ByteBuffer;import java.nio.channels.SelectionKey;import java.nio.channels.Selector;import java.nio.channels.SocketChannel;import java.nio.channels.spi.SelectorProvider;import java.util.Iterator;public class NioClient &#123; private Selector selector; public void init (String ip,int port)&#123; try &#123; SocketChannel channel=SocketChannel.open(); channel.configureBlocking(false); this.selector= SelectorProvider.provider().openSelector(); channel.connect(new InetSocketAddress(ip, port)); channel.register(selector, SelectionKey.OP_CONNECT); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; public void working()&#123; while (true)&#123; if (!selector.isOpen())&#123; break; &#125; try &#123; selector.select(); Iterator&lt;SelectionKey&gt; iterator= this.selector.selectedKeys().iterator(); while (iterator.hasNext())&#123; SelectionKey key=iterator.next(); iterator.remove(); if (key.isConnectable())&#123; connect(key); &#125;else if(key.isReadable())&#123; read(key); &#125; &#125; &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; private void read(SelectionKey key) &#123; try &#123; SocketChannel channel= (SocketChannel) key.channel(); ByteBuffer buffer=ByteBuffer.allocate(100); channel.read(buffer); byte[] data=buffer.array(); String msg=new String(data).trim(); System.out.println("客户端收到消息"+msg); channel.close(); key.selector().close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; private void connect(SelectionKey key) &#123; SocketChannel channel= (SocketChannel) key.channel(); try &#123; if (channel.isConnectionPending())&#123; channel.finishConnect(); &#125; Thread.sleep(10000); channel.configureBlocking(false); channel.write(ByteBuffer.wrap(new String("hello server!\r\n").getBytes())); channel.register(this.selector,SelectionKey.OP_READ); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125;catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; public static void main(String[] args) &#123; NioClient client=new NioClient(); client.init("localhost" ,8000); client.working(); &#125;&#125; AIOAIO中的”A”代表这ASynchronized，就是异步的意思，我们在用AIO的时候，解决了阻塞的问题，但是NIO中的IO操作还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好的时候，得到通知，接着由这个线程自行进行IO操作，IO操作本身依旧是同步的。对于AIO来说，则更近一步，他不是在IO准备好时通知线程，而是在IO操作已经完成后通知线程。因此，AIO是完全不阻塞的。此时，我们的业务逻辑变成了一个回调函数，等待IO操作结束后系统自动触发。 AIO Server异步的IO使用异步通道ASynchronousServerSocketChannel。 1234567891011121314151617181920212223public abstract &lt;A&gt; void accept(A attachment, CompletionHandler&lt;AsynchronousSocketChannel,? super A&gt; handler);/** * Invoked when an operation has completed. * * @param result * The result of the I/O operation. * @param attachment * The object attached to the I/O operation when it was initiated. */ void completed(V result, A attachment); /** * Invoked when an operation fails. * * @param exc * The exception to indicate why the I/O operation failed * @param attachment * The object attached to the I/O operation when it was initiated. */ void failed(Throwable exc, A attachment); ASynchronousServerSocketChannel.accept()方法会立即返回，它并不会真正的等待客户端的到来。它的第一个参数是一个附件，可以是任意一个类型，作用是让当前线程和后续的回调方法共享信息。他会在后续的调用用，传递给handler。第二个参数是CompletionHandler接口，我们需要实现他的两个方法completed和failed，completed是连接成功后执行的方法，failed是连接失败的时候执行的方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172package io;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousServerSocketChannel;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;import java.util.concurrent.ExecutionException;import java.util.concurrent.Future;import java.util.concurrent.TimeUnit;import java.util.concurrent.TimeoutException;public class AioServer &#123; public final Integer port=8000; private AsynchronousServerSocketChannel server; public AioServer() throws IOException&#123; server =AsynchronousServerSocketChannel.open().bind(new InetSocketAddress(port)); &#125; public void start()&#123; System.out.println("server listen on "+port); server.accept(null, new CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123; final ByteBuffer buffer=ByteBuffer.allocate(1024); @Override public void completed(AsynchronousSocketChannel result, Object attachment) &#123; System.out.println(Thread.currentThread().getName()); Future&lt;Integer&gt; writeResult=null; try &#123; buffer.clear(); result.read(buffer).get(100, TimeUnit.SECONDS); buffer.flip(); writeResult=result.write(buffer); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125; catch (TimeoutException e) &#123; e.printStackTrace(); &#125;finally &#123; try &#123; server.accept(null,this); writeResult.get(); result.close(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; catch (ExecutionException e) &#123; e.printStackTrace(); &#125;catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; &#125; @Override public void failed(Throwable exc, Object attachment) &#123; System.out.println("failed :"+exc); &#125; &#125;); &#125; public static void main(String[] args) throws InterruptedException, IOException &#123; new AioServer().start(); while (true)&#123; Thread.sleep(1000); &#125; &#125;&#125; AIO Client123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657package io;import java.io.IOException;import java.net.InetSocketAddress;import java.nio.ByteBuffer;import java.nio.channels.AsynchronousSocketChannel;import java.nio.channels.CompletionHandler;public class AioClient &#123; public static void main(String[] args) throws IOException, InterruptedException &#123; final AsynchronousSocketChannel client=AsynchronousSocketChannel.open(); client.connect(new InetSocketAddress("localhost",8000), null, new CompletionHandler&lt;Void, Object&gt;() &#123; @Override public void completed(Void result, Object attachment) &#123; client.write(ByteBuffer.wrap("hello".getBytes()), null, new CompletionHandler&lt;Integer, Object&gt;() &#123; @Override public void completed(Integer result, Object attachment) &#123; final ByteBuffer buffer=ByteBuffer.allocate(1024); client.read(buffer, buffer, new CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123; @Override public void completed(Integer result, ByteBuffer attachment) &#123; System.out.println("jinlailema"); buffer.flip(); System.out.println(new String(buffer.array())); try &#123; client.close(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; &#125; @Override public void failed(Throwable exc, ByteBuffer attachment) &#123; &#125; &#125;); &#125; @Override public void failed(Throwable exc, Object attachment) &#123; &#125; &#125;); &#125; @Override public void failed(Throwable exc, Object attachment) &#123; &#125; &#125;); Thread.sleep(1000); &#125;&#125; 应用场景BIO:BIO服务器端有一个连接，那么我们就要在服务器端建立一个线程来处理，进行一对一的处理。需要等待客户端的准备过程，对服务器的资源占用是很明显的，是一个连接一个线程。NIO:NIO是使用一个selector选择器来进行轮询，当发现请求的时候，selector才会启动一个线程进行处理。属于一个请求一个线程，所以很适合高并发的场景。但是，当你接收之后，可能会写入数据库的操作，也就是请求应用的资源，但是现在数据库内的连接都是满的，那就需要一直等待连接池内的等待。是一个请求一个线程。AIO：AIO的出现就解决了NIO应用资源占用的这个问题，通过调用操作系统以及并发操作解决这类问题。属于一个有效的请求一个线程。 总结再看完这些之后，可能会对同步异步、阻塞非阻塞还有一些疑问，在学习的期间我也很困惑，常常纠结了很久，但是总会有柳暗花明的一天，我想通了期间的差别，它可能是错误的，但是即使是错误的，也是我这段时间学习的结晶。 BIO操作，当客户端与服务器端进行连接的时候，服务器端accept()就会阻塞，这时候服务器端在准备数据(写hello)，这段客服端准备数据的时候，服务器端就会被阻塞；这就像一个或者很多集装箱一样，他负责传输货物的，但是BIO相当于把货物的开膛、清洗、消毒、冷冻、传输等所有的操作都在集装箱进行，就会占用一个集装箱很长时间，如果集装箱满了，其他的货物就进不来；NIO呢，就是货物的开膛、清洗、消毒、冷冻这样的事不应该放在集装箱上进行，我这是负责传输的，你的这些操作应该事先准备好后，然后给我进行传输。那么BIO呢，我们接收到了数据之后，我们还要处理数据（读写操作），我们的读操作和写操作也会耗费一些时间，因为单线程是同步的么。如果货物到了集装箱，我们还要对货物进行检验，重量是否对应，检测是否有流感；我们在进行这些操作的时候，那么火车就不能开动。AIO就是相当于让集装箱开动了，并抽出两个人在同时做货物的检验。 最后在说一下，对于服务器端来说，阻塞非阻塞是相对与客户端来说，而同步异步是从客户端接收完数据之后，自己对数据的操作而言的。]]></content>
      <tags>
        <tag>JVM</tag>
        <tag>java多线程</tag>
        <tag>IO</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-全注解项目构建]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F13%2FSpring-%E5%85%A8%E6%B3%A8%E8%A7%A3%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[首先将包依赖导入。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;project xmlns="http://maven.apache.org/POM/4.0.0" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance" xsi:schemaLocation="http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.test&lt;/groupId&gt; &lt;artifactId&gt;test3&lt;/artifactId&gt; &lt;packaging&gt;war&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;name&gt;test3 Maven Webapp&lt;/name&gt; &lt;url&gt;http://maven.apache.org&lt;/url&gt; &lt;properties&gt; &lt;project.build.sourceEncoding&gt;UTF-8&lt;/project.build.sourceEncoding&gt; &lt;maven.build.timestamp.format&gt;yyyyMMddHHmmss&lt;/maven.build.timestamp.format&gt; &lt;spring.version&gt;3.2.9.RELEASE&lt;/spring.version&gt; &lt;/properties&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-webmvc&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt; &lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;javax.servlet&lt;/groupId&gt; &lt;artifactId&gt;javax.servlet-api&lt;/artifactId&gt; &lt;version&gt;4.0.0-b07&lt;/version&gt; &lt;scope&gt;provided&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;build&gt; &lt;finalName&gt;test3&lt;/finalName&gt; &lt;/build&gt;&lt;/project&gt; 注意：一定要引servlet-api包，因为SpringMVC的关键dispatcherservlet是需要继承Servlet的。 SpringMVC配置配置DispatcherServlet和ContextLoaderListener1234567891011121314151617181920212223242526272829303132package config;import org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;public class SpitterWebAppInitializer extends AbstractAnnotationConfigDispatcherServletInitializer&#123; /** * 创建ContextLoaderListener（Servlet监听器） * @return */ protected Class&lt;?&gt;[] getRootConfigClasses() &#123; //System.out.println("加载rootconfig"); return new Class&lt;?&gt;[]&#123;RootConfig.class&#125;; &#125; /** * 创建DispacherServlet * @return */ protected Class&lt;?&gt;[] getServletConfigClasses() &#123; //System.out.println("加载ServletConfigClasses"); return new Class&lt;?&gt;[]&#123;WebConfig.class&#125;; &#125; protected String[] getServletMappings() &#123; //System.out.println("加载getServletMappings"); return new String[]&#123;"/"&#125;; &#125;&#125; 我在java下建立一个包config，这个包用来装java的配置来。 在这里我们新建一个类什么名字都无所谓，在这里我们使用了SpitterWebAppInitializer这个名字，使它继承 AbstractAnnotationConfigDispatcherServletInitializer类。 我们不需要任何配置，只要项目启动，那么Spring就会找谁扩展了AbstractAnnotationConfigDispatcherServletInitializer，就会自动配置DispacherSevlet和Spring应用上下文，spring的应用上下文位于应用程序的Servlet上下文之中。 getServletMappings()方法它将一个或多个路径映射到DispacherServlet上，我们设置的是”/“,它会处理进入应用的所有请求。如果设置为”/*.do”，那么它只会处理以”.do”结尾的请求，起到了过滤的作用。 DispatcherServlet和ContextLoaderListener的区别当DispatcherServlet启动的时候，它会创建Spring应用上下文，并加载配置或配置类中所生命的bean（即getServletConfigClasses()中所需要干的事)。 除了DispatcherServlet创建的应用上下文，还有另外一个应用上下文。它是由ContextLoaderListener创建的（即getRootConfigClasses()干的事）。它也叫做Servlet监听器 我们希望DispatcherServlet加载包含Web组件的bean，如控制器，试图解析器，以及处理器映射,而ContextLoaderListener要加载应用中的其他bean，这些bean通常是驱动应用后端的中间层和数据层的组件。简单的说，DispatcherServlet配置的都是与springMVC请求和流程有关的bean。而ContextLoaderListener是配置项目支撑的bean。 DispatcherServlet和ContextLoaderListener加载顺序看到我们注掉的东西了么，这是为了哪个容器需要先加载，项目运行，看控制台的输出，发现ContextLoaderListener先被加载，之后是DispatcherServlet。 配置DispacherServlet12345678910111213141516171819202122232425262728293031323334353637383940package config;import org.springframework.context.annotation.Bean;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.web.servlet.ViewResolver;import org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;import org.springframework.web.servlet.config.annotation.EnableWebMvc;import org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;import org.springframework.web.servlet.view.InternalResourceViewResolver;@Configuration@EnableWebMvc@ComponentScan("action")public class WebConfig extends WebMvcConfigurerAdapter&#123; /** * 配置jsp视图解析器 * @return */ @Bean public ViewResolver viewResolver()&#123; InternalResourceViewResolver resolver=new InternalResourceViewResolver(); resolver.setPrefix("/WEB-INF/views/"); resolver.setSuffix(".jsp"); resolver.setExposeContextBeansAsAttributes(true); return resolver; &#125; /** * 配置静态资源的处理 * @return */ @Override public void configureDefaultServletHandling(DefaultServletHandlerConfigurer configurer)&#123; configurer.enable(); &#125;&#125; 配置ContextLoaderListener1234567891011121314package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.FilterType;import org.springframework.web.servlet.config.annotation.EnableWebMvc;@Configuration@ComponentScan(basePackages = &#123;"config"&#125;,excludeFilters = &#123; @ComponentScan.Filter(type = FilterType.ANNOTATION,value= EnableWebMvc.class)&#125;)public class RootConfig &#123;&#125; 刚才对ContextLoaderListener有过介绍，这模块主要是对SpringMVC进行配置，这个以后涉及到数据库连接池等的时候，我们再详细配置。 @Configuration:之前说过，让spring知道你这个是java配置类。 @EnableWebMvc：启动SpringMVC注解,这个注解相当于xml中的”mvc:annotation-driven“ @ComponentScan(“action”)：启动组件扫描，这样SpringMVC就会寻找action中带有@Controller中的注解了。 为什么要继承WebMvcConfigurerAdapter因为我们有时候要处理对静态资源的请求，但是DispatcherServlet会处理所有的请求，所以我们继承WebMvcConfigurerAdapter类，当处理静态资源的时候，将请求交给默认的servlet。 测试控制器12345678910111213package action.pay;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;@Controllerpublic class DoAction &#123; @RequestMapping(value = "/test",method = RequestMethod.GET) public String home()&#123; return "home"; &#125;&#125; 首页index.jsp123456&lt;html&gt;&lt;body&gt;&lt;h2&gt;Hello World!&lt;/h2&gt; &lt;a href="/test"&gt;test&lt;/a&gt;&lt;/body&gt;&lt;/html&gt; 跳转页面home.jspWEB-INF/views/下新建一个就可以了，看看能否跳转成功。 至此，springmvc的全注解配置就结束了。 Spring配置之前已经介绍过Spring的配置了，那么我在这里就不在累赘了。 配置javaConfigjavaConfig是用来告诉spring哪些类需要进行加载的。 1234567891011package config;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackages = "impl")public class JavaConfig &#123;｝ @Configuration:告诉spring自己的java配置类 @ComponentScan(basePackages = “impl”)：将哪些文件进行spring的装配 注意：这个文件一定要放在之前配置RootConfig所指定的包下，即config，否则spring是不会找到这个配置类的。 如果你用的工具是idea，那么当你配置正确的时候，就会出现下图的标记。 点进去可以查看他们的映射关系 所以我们也可以看到ContextLoaderListener和DispacherServlet各司其职。 编写接口12345678package service.pay;public interface Payservice &#123; void pay(Integer num);&#125; 编写实现类12345678910package impl.pay;import org.springframework.stereotype.Component;import service.pay.Payservice;public class ComputerPayServiceImpl implements Payservice&#123; public void pay(Integer num) &#123; System.out.println("使用电脑支付了"+num); &#125;&#125; 修改action123456789101112131415161718192021package action.pay;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.stereotype.Controller;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RequestMethod;import service.pay.Payservice;@Controllerpublic class DoAction &#123; @Autowired private Payservice payservice; @RequestMapping(value = "/test",method = RequestMethod.GET) public String home()&#123; payservice.pay(100); return "home"; &#125;&#125;]]></content>
      <tags>
        <tag>spring</tag>
        <tag>springMVC</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[spring-2-自动化装配]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F13%2Fspring-2-%E8%87%AA%E5%8A%A8%E5%8C%96%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Spring Context负责创建bean，又使用DI（依赖注入）满足bean之间的依赖。接下来我们谈如何使用。 环境： 所需manven包1234567891011121314151617&lt;dependency&gt; &lt;groupId&gt;junit&lt;/groupId&gt; &lt;artifactId&gt;junit&lt;/artifactId&gt; &lt;version&gt;4.10&lt;/version&gt; &lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-core&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.springframework&lt;/groupId&gt; &lt;artifactId&gt;spring-test&lt;/artifactId&gt; &lt;version&gt;$&#123;spring.version&#125;&lt;/version&gt;&lt;/dependency&gt; 使用的spring.version 是3.2.9 我们注意到junit 的下面有一个test，是什么意思呢。说明这个jar只会在你测试的resourse 下才会被使用，正常的代码区域是不会被引用的。所以，在做测试的情况下如果没有建立测试的resourse的话，需要把这个注掉。 使用注解形式：之前我们一定接触过Spring，多数是用Spring xml的配置进行的。我们这次使用注解方式进行使用。 Spring从两个角度来实现自动化装配： 组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的bean。 自动装配(autowiring)：Spring自动满足bean之间的依赖。 举个例子： 如图所示，在java文件夹下建立action包逻辑处理，config 配置文件包，service接口包，以及impl实现类包。然后我们像做项目一样，需要一个支付的模块，分别建立一个pay子包。 先介绍几个spring用到的注解 @Configuration:spring将这个类设置为config @ComponentScan:这个注解在spring中启动扫描 @Component：使用这个注解，就可以使类能够让spring扫描到。 先看我们的支付接口Payservice，它只有一个方法，就是支付。 123456package service.pay;public interface Payservice &#123; void pay(Integer num);&#125; 然后是我们的手机支付的实现类，继承Payservice接口 我们使用@Component使这个类在spring能够发现这个类，并进行创建bean。创建的bean会有名字，如果@Component不写的话，那么就是phonePayServiceImpl，如果写了的话创建的名字就是你写的那个@Component(value = “phonePayServiceImpl”)。 12345678910package impl.pay;import org.springframework.stereotype.Component;import service.pay.Payservice;@Componentpublic class PhonePayServiceImpl implements Payservice&#123; public void pay(Integer num) &#123; System.out.println("使用手机支付了"+num); &#125;&#125; 来写我们的PayConig @Configuration Spring在启动时会寻找这个注解，知道他是config类，然后再进行相关操作。 @ComponentScan：需要扫描的包，如果不写其他的话，它会扫描的读当前包下的所有文件。我们把PayConfig放在impl.pay下就可以了。如果你想像我一样，将配置类统一管理的话，那么就明确一下包路径。当然你也可以建立一个JavaConfig类，然后设置为它的总包路径impl就可以了。 1234567891011package config.pay;import org.springframework.context.annotation.ComponentScan;import org.springframework.context.annotation.Configuration;@Configuration@ComponentScan(basePackages = "impl.pay")public class PayConfig &#123;&#125; 现在我们测试一下是否成功 @Autowired 我们完成以上的操作，spring已经发现了需要创建的bean，但是没有将需要创建的bean的其他对象进行装配，这时候使用@Autowired 就可以完成自动装配 12345678910111213141516171819202122package pay;import config.pay.PayConfig;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import service.pay.Payservice;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = PayConfig.class)public class PayTest &#123; @Autowired private Payservice payservice; @Test public void test()&#123; payservice.pay(100); &#125;&#125; 运行成功。 一个接口多个实现类问题，我们当一个接口有一个实现类的时候，装配成功了。就像之前说的，在PayTest中，我们只是调用了pay接口，它是使用电脑支付、手机支付我们都不知道，完成了解耦。但是如果两个实现类我们建立后，在PayTest会装配到底会装配哪一个实现类呢，我们做一下测试，新建一个实现类computerPayServiceImpl。1234567891011package impl.pay;import org.springframework.stereotype.Component;import service.pay.Payservice;@Component(value = "computerPayServiceImpl")public class ComputerPayServiceImpl implements Payservice&#123; public void pay(Integer num) &#123; System.out.println("使用电脑支付了"+num); &#125;&#125; 我们再调用一次。 我们发现调用失败了，spring不知道到底该调哪一个。但是这种场景经常出现，我们该怎么办？ 这个时候我们就只是单单使用@Autowired这个注解了，还应加入@Qualifier注解，并写上spring创建bean的名字。这样spring就知道应该加载哪个bean了。 1234567891011121314151617181920212223242526package pay;import config.pay.PayConfig;import org.junit.Test;import org.junit.runner.RunWith;import org.springframework.beans.factory.annotation.Qualifier;import org.springframework.test.context.ContextConfiguration;import org.springframework.test.context.junit4.SpringJUnit4ClassRunner;import service.pay.Payservice;@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = PayConfig.class)public class PayTest &#123; @Autowired @Qualifier("computerPayServiceImpl") private Payservice payservice; @Test public void test()&#123; payservice.pay(100); &#125;&#125; 显示配置Bean之java代码当我们有的时候无法为bean添加@component的方法，有时候这个类不是我们创建的，那么就无法使用自动装配的方式了，显而易见，spring就不会发现这个bean了，那么怎么办，spring有两个解决方式，分别是java显示配置和xml显示配置，现在先说一下使用java显示代码配置。 我们还是这个例子，然后把PhonePayServiceImpl实现类注掉，保证payservice先有一个实现类以便测试。然后将ComputerPayServiceImpl中的@component去掉，这样我们payconfig进行包扫描时，因为ComputerPayServiceImpl没有@component注解，那么spring就不会发现bean。我们测试一下。 测试结果为： 我们重点看到红线标记部分（如果你用的也是idea的话），可以看到要装配computerPayServiceImpl的payservice1提示无法找到这个bean，但是要装配phonePayServiceImpl却能，这就很说明问题了。 这个时候我们在javaConfig下显示的配置bean。 package config.pay; import impl.pay.ComputerPayServiceImpl; import impl.pay.PhonePayServiceImpl; import org.springframework.context.annotation.Bean; import org.springframework.context.annotation.ComponentScan; import org.springframework.context.annotation.Configuration; import service.pay.Payservice; @Configuration @ComponentScan(basePackages = "impl.pay") public class PayConfig { @Bean(name = "computerPayServiceImpl") public Payservice getComputerPayService (){ return new ComputerPayServiceImpl(); } } @bean注解：告诉spring这个方法将会返回一个对象，该对象要注册为Spring应用上下文的bean。方法体中包含了最终产生bean实例的逻辑。 默认情况下，bean的ID与带有@Bean注解的方法名是一样的，如下图的话，bean的名字就是getPayService。也可以使用@Bean的name属性指定。 我们也无用运行测试类，直接用idea观察，就会发现，computerPayServiceImpl不是醒目的红色而是绿色了，如果不是用idea，运行一下程序即可。]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-7-垃圾回收器介绍]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F12%2FJVM-7-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E5%99%A8%E4%BB%8B%E7%BB%8D%2F</url>
    <content type="text"><![CDATA[串行回收器：串行回收器可以在新生代和老年代使用，根据作用不同的堆空间，分为新生代串行回收器和老年串行回收器。 新生代串行回收器：特点： 1、它仅仅使用单线程进行垃圾回收。 2、它是独占式的垃圾回收。 在串行收集器进行垃圾回收时，java应用程序中的线程都需要暂停，等待垃圾回收的完成。应用程序停止工作，进行等待，这种现象称之为“stop-the-world”。它将造成非常糟糕的用户体验，在实时性比较高的应用场景下，是很难让人接受的。 -XX:+UseSerialGC参数可以制定虚拟机使用新生代串行收集器和老年代串行收集器。是虚拟机使用client模式下，默认的垃圾收集器。 老年代串行回收器：老年代串行收集器使用标记压缩算法，和新生代串行收集器一样，是独占式垃圾回收器。但是老年代由于存储空间大，老年代垃圾回收器会比新生代回收更长时间。 若老年代使用串行收集器，可以跟多种新生代回收器配合使用，同时它是CMS回收器的备用回收器。 -XX:+UseSerialGC:新生代、老年代均使用串行回收器 -XX:+UseParNewGC：新生代使用ParNew回收器，老年代使用串行回收器 -XX:+UseParallelGC:新生代使用ParallelGC回收器，老年代使用串行收集器。 并行回收器新生代ParNew回收器：ParNew回收器工作在新生代，它只是将串行回收器多线程化，ParNew也是独占式回收器，在收集过程中，应用程序会全部暂停。但由于是并行的，在并行能力强的CPU上，它产生的停顿时间要短于串行回收器。但是在单CPU或者并发能力弱的系统中，并行回收器效果很可能要比串行回收器差。 -XX:+UseParNewGC:新生代使用ParNew回收器，老年代使用串行回收器。 -XX:+UseConcMarkSweepGC:新生代使用ParNew回收器，老年代使用CMS回收器。 ParNew回收器工作的线程数量可以使用-XX:ParallelGCThreads参数指定。默认情况下，当CPU数量小于8个时，ParallelGCThreads的值等于CPU数量，当CPU数量大于8个时，ParallelGCThreads的值等于3+（5*CPU数量/8）。 新生代ParallelGC回收器新生代ParallelGC回收器也是使用复制算法的收集器，同ParNew回收器一样，是多线程、独占式的收集器。ParallelGC回收器有一个重要特点，他非常关注系统的吞吐量。 -XX:+UseParallelGC:新生代使用ParallelGC回收器，老年代使用串行收集器。 -XX:+UseParallelOldGC：新生代使用ParallelGC回收器，老年代使用ParallelGC回收器。 ParallelGC回收器提供了两个重要参数来控制系统的吞吐量： -XX:MaxGCPauseMilis:设置最大的垃圾收集停顿时间。他的值是大于0的整数，虚拟机会将停顿时间控制在设置的值内，如果希望停顿时间较小，那么将值设置小一些就可以了。但是这样虚拟机可能会使用一个较小的堆，因为小堆会比大堆用的时间少，但是会增加GC回收的次数，从而降低了吞吐量。 -XX:GCTimeRatio:设置吞吐量的大小。他的值在0到100之间的整数。默认值是19，以为着1/(1+19),将垃圾回收控制在总时间的5%以内。要是设置99，那么垃圾回收的时间应不超过1%。 我们可以使用-XX:UseAdaptiveSizePolicy可以打开GC自适应策略，在这个模式下，新生代大小，eden，old和suivivior的比例、晋升老年代的对象年龄等参数会被自动整理，来达到堆大小、吞吐量和停顿时间的平衡点。我们可以制定虚拟机的最大堆，目标吞吐量GCTimeRatio和停顿时间MaxGCPauseMilis，让虚拟机自己完成工作。 老年代ParallerOldGC回收器老年代ParallelOldGC是回收器也是多线程并发的收集器。它也是一个关注吞吐量的回收器，它只能和新生代ParallelGC回收器一起使用。也是使用标记压缩算法。 XX:ParallelGCThreads也可用于设置垃圾回收时的线程数量。那么我们看到新生代ParNew回收器也会使用这个参数，那么岂不是冲突了吗？不会的，因为两个收集器是不可能在一起使用的，所以参数一样的，但是并不会起到冲突。 并发垃圾回收器老年代CMS垃圾回收器与Parallel和ParallelOldGC不同，CMS回收器主要关注于系统的停顿时间。CMS是Concurrent Mark Sweep的缩写，意为并发标记清除，从名称上可以得出，它使用的是标记清除算法，同时它是一个使用多线程并行回收的垃圾收集器。 STW：停顿时间的缩写，在这个时间段应用程序的所有进程全部暂停。 我们可以看见，CMS中只有初始标记和重新标记两步需要应用程序暂停，其他步骤都是可以与应用程序一起执行的，所以说CMS不是一个独占式的垃圾回收器。初始标记、并发标记、重新标记都是为了标记出需要回收的垃圾对象，并发清理则在标记完成之后，正是回收垃圾对象。并发重置指在垃圾回收完成后，重新初始化CMS数据结构和数据，为下一次垃圾回收做准备。 在整个CMS回收过程中，默认情况下，在并发标记之后，会有一个预清理的操作（也可以关闭开关-XX:-CMSPrecleaningEnable，不进行预清理）。预清理是并发的，除了为正式做准备和检查以外，预清理还会尝试控制一次停顿时间。由于重新标记是独占CPU的，如果新生代发生GC的时候，就会立即触发一次重新标记，那么一次停顿时间可能会很长。为了避免这种情况，预处理时，会特意等待一次新生代GC的发生，然后根据历史性能数据预测下一次新生代GC可能发生的时间，然后在当前时间和预测时间的中间时刻，进行重新标记。这样，从最大程度上避免新生代GC和重新标记重合，尽可能减少一次的停顿时间。 CMS主要参数：-XX:+UseConcMarkSweepGC:新生代使用ParNew回收器，老年代使用CMS回收器。 CMS默认启动的并发线程数是（ParallelGCThreads+3）/4。我们需要查看当ParNew回收器时设置的ParallelGCThreads参数。并发线程数量也可以通过-XX:ConGCThreads或者-XX:ParallelCMSThreads参数手工设定。当CPU资源比较紧张时，收到CMS回收线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。 因为CMS不是独占式回收器，所以在进行垃圾回收时，应用系统还在运行，还会不停的创造垃圾，这些新生的垃圾是不会被清除的。同时，因为没有中断，那么在CMS回收时，应确保剩余的堆空间有足够的内存可用，所以CMS不会在堆空间饱和的时候进行垃圾回收，因为要确保有足够的空间可以支持应用程序。 这个阀值使用-XX:CMSInitiatingOccupancyFraction来指定，默认是68.当老年代使用率达到68了，就进行CMS垃圾回收。如果在执行垃圾回收的时候，内存不足了，CMS垃圾回收就会失败，就会使用串行收集器进行回收，此时应用程序会完全中断。 因为CMS使用的是标记清除算法，所以他清理后会产生内存碎片，离散内存碎片无法分配较大的对象，这种情况会被迫进行再进行一次垃圾回收来获取一块可用的连续内存，但是这对系统性能影响很严重。 使用-XX:+UseCMSCompactAtFullCollectoin开始可以使CMS在垃圾收集完成后，进行一次脆片整理，内存碎片的整理不是并发进行的。-XX:CMSFullGCsBeforeCompaction参数可以用于设定进行多少次CMS回收后，进行一次内存压缩。 可以使用CMS来回收perm区，必须要打开-XX:+CMSClassUnloadingEnable开关。条件允许的情况下，系统会使用CMS机制回收Perm区的Class数据。 未来做主的：G1回收器G1（Garbage-First）回收器是在JDK1.7中正式使用的全新的垃圾回收器。它的出现是为了取代CMS垃圾回收器。 从分代上看，G1依然属于分代垃圾回收器，它依旧区分年轻代和老年代，依旧分为新生代和老年代。但是堆的结构来看，它不要求整个eden区、年轻代、老年代都连续，它使用了分区算法，来替代CMS长期替代方案。 （关于后续部分之后在更新。）]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-6-垃圾回收概念与算法]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F12%2FJVM-6-%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6%E6%A6%82%E5%BF%B5%E4%B8%8E%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[GC中的垃圾，特指存在于内存中的、不会被使用的对象，而“回收”，相当于把垃圾桶“倒掉”。 常用的垃圾回收算法 1、引用计数法对于一个对象A，任何一个对象引用了A，则A的计数器+1，当引用失效后，引用计数器-1。只要对象A的计数器为0，那么A对象就不会被引用。 它有两个严重的问题： 无法处理循环引用的情况。因此，在Java的垃圾回收器中，没有使用这种算法。 引用计数器要求在每次因引用产生和消除时，需要伴随一次加法操作和减法操作，对系统性能呢个有一定的影响。 例子：如果A、B对象相互引用，计数器均不为0，但是没有第三个对象引用他们，A，B应该是被回收的对象，但是由于他们两个相互引用，从而使垃圾回收期无法识别，引起内存泄漏。 2、标记清除法标记清除法是现代垃圾回收算法的思想基础。标记清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一个可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法可能产生最大的为题是空间碎片。 标记清除算法先通过根节点标记所有可达对象，然后清除所有不可达对象，回收的空间是不连续的，不连续的空间的工作效率要低于连续的空间。这就是该算法最大的缺点。 3、复制算法复制算法的核心思想：将原有的空间内存分为两块，每次只使用其中一块，在垃圾回收时，将正在使用内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。 当需要回收的垃圾对象很多，需要复制的对象很少的时候，这个算法效率是很高的。此算法是不会产生空间碎片的，但是复制算法的代价就是将系统内存折半，因此单纯的复制算法让人难以接受。 在Java新生代的串行收集器中，使用了复制算法的思想。新生代分为eden空间，from区和to区三个部分。from区和to区就是两块内存大小相等，地位相等，可进行角色转换的内存块。from和to空间也被成为survivor空间，即存活者空间，用于存放未被回收的对象。 4、标记压缩法因为复制算法适合只使用于垃圾对象多，存活对象少的情况，那么老年代这种垃圾对象少，存活对象多的情况，是不适合用复制算法的。标记压缩算法也是从根节点开始，对所有可达的对象做一次标记，它并不是简单的清理未标记的对象，而是将所有存活的对象压缩到内存的另一端，然后清理边界之外的所有对象。标记压缩算法最终效果等同于标记清除法执行完成后，再进行一次内存碎片整理，因此，也可以把它成为标记清除压缩算法。 5、分代算法前面的几种算法，他们没法完全替代其他算法，都有自己的优点和缺点。根据垃圾回收对象的特性，使用合适的算法回收，才是明智的选择。分代算法就是基于这种思想，它将内存区间根据对象的特点分为几块，根据每块内存区间的特点，使用不同的回收算法，一提高垃圾回收的效率。 6、分区算法分区算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同的小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。 一般来说，在相同条件下，堆空间越大，一次GC所需要的时间越长，从而产生的停顿越长，即stop-the-world。为了更好的控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次GC的停顿。 jdk1.8中的G1垃圾回收器就是使用的这种方法。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-5-JIT编译及静态编译]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F12%2FJVM-5-JIT%E7%BC%96%E8%AF%91%E5%8F%8A%E9%9D%99%E6%80%81%E7%BC%96%E8%AF%91%2F</url>
    <content type="text"><![CDATA[对于执行的字节码会从两处进行优化。 第一，就是使用javac编译时。 第二，就是使用JIT（just-in-time）即时编译，在运行时。 编译时计算：如果在程序中出现了计算表达式，如果表达式的值能够在编译时确定，那么表达式的计算会提前到编译阶段，而不是在运行时计算。1234for(int i=0;i&lt;60*60*24*1000；i++)&#123;&#125; 我们经常会用到这样的写法606024*1000，那么是不是每次循环都都要进行一次？其实不是，因为在编译的时候，对于给定的表达式会自动计算并给出结果。 字符串相加：12345678String info1="ab";String info2=“a”+“b”；String const="a";String info3=const+"b"; 三个值的字面量都是”ab”，那么他们相等吗，info1==info2 是相等的，理由：因为在info的“+”并为在运行时进行，在编译的时候就进行了，所以不会产生新的对象。而info3有一个未知的变量，所以“+”在运行时进行，产生了新的对象。 在变量字符串连接： 例子：123456789101112public static void addString2(String ...str1)&#123; String str3=""; for(String str:str1)&#123; str3+=str1; &#125;&#125; 当变量字符串相加时，系统会先将字符串转化为StringBuilder，然后做append操作。但是在for循环中，是每一次循环都建立一个StringBuilder对象，这样很费系统资源，正确的做法是在循环外建立一个StringBuilder，然后做append(）操作。S JIT编译java虚拟机有三种执行方式，分别是解释执行(-Xint)、混合模式(-mixed mode )、编译执行(-Xcomp),默认是混合模式。 解释执行表示全部代码均解释执行，不做任何JIT编译，使用java -Xint -version来开启。 混合模式是根据是否会是热点代码，如果是，都会编译执行。 编译模式，所有代码均编译执行。 一般来说，编译模式的执行效率会远远高于解释模式。大家可以使用同一段代码根据-Xint、-Xcomp来比较。 JIT编译阀值：-client模式下，阀值是1500次 -server模式下，阀值是10000次。 使用-XX:CompileThreshold可以设置这个阀值。（-XX:CompileThreshold=500） 使用-XX:PrintCompilation可以打印出即时编译的日志。（-XX:PrintCompilation）]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-4-装载（加载、连接、初始化）]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F12%2FJVM-4-%E8%A3%85%E8%BD%BD%EF%BC%88%E5%8A%A0%E8%BD%BD%E3%80%81%E8%BF%9E%E6%8E%A5%E3%80%81%E5%88%9D%E5%A7%8B%E5%8C%96%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Class类型通常以文件的形式存在（当然，任何二进制流都可以是class类型），只有被java虚拟机装在的class类型才能在程序中使用。系统装载Class类型可以分为加载、连接和初始化3个步骤。其中连接又可分为验证、准备、解析3步。 装载类的条件：Class只有在必要的时候才会被装载，JVM虚拟机不会无条件地加载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是主动使用、主动使用只有下列几种情况。 1、当创建一个类的实例的时候，new关键字、或者通过反射、克隆、反序列化。 2、当调用类的静态方法时，即当使用了字节码invokestatic指令。 3、当使用类或接口的静态字段时（final常量外）。 4、当使用java.lang.reflect包中的方法反射类的方法时。 5、初始化子类时，要求先初始化父类。 6、作为启动虚拟机，含有main()方法的那个类。 1、创建实例12345678910111213141516171819202122public class Student &#123;public static String name ="liumou";static&#123;System.out.println("student完成装载");&#125;&#125;public class test &#123;public static void main(String[] args) &#123;Student student=new Student();&#125;&#125; 输出结果是：student完成装载，说明student已经装载完成。 2、删除main中的方法改为123456public static void main(String[] args) &#123;String name=Student.name;&#125; 输出结果：student完成装载，说明调用类的静态变量可以完成该类的装载。 3、在student类中添加静态变量方法123456public static void staticMethod()&#123;System.out.println("调用了student的静态方法");&#125; 在test类中用调用staticMethod()方法。 输出结果： student完成装载 调用了student的静态方法 说明：调用类的静态方法是可以完成类的装载。 4、同样是student类，继承Person。 public class Student extends Person{ public final static String name ="liumou"; static{ System.out.println("student完成装载"); } public static void staticMethod(){ System.out.println("调用了student的静态方法"); } public static void main(String[] args) { System.out.println("student可以被装载"); } } public class Person { static { System.out.println("父类Person完成装载"); } public static void methodStatic(){ System.out.println("父类PerSon的方法"); } } （1） 在test类中，新建student对象。 输出结果：父类Person完成装载 student完成装载 调用了student的静态方法 结论：对象装载之前需先装载其父类，然后才能装载自己。 （2）在test类中，调用子类调用父类的静态方法methodStatic（），（子类并未覆盖此方法）。 输出结果：父类Person完成装载 父类PerSon的方法 结论：当子类调用父类的静态方法，子类是不会进行装载的。此时的装载，代表的是此时的子类student并未初始化，但是已经被系统加载。使用-XX:+TraceClassLoading可以看日志装载情况。 （3）在test方法中，调用Student的name属性（final修饰的静态变量）。 输出结果：只有“liumou” 结论：说明调用类的final修饰的静态变量不会进行类的装载。此时类连加载都没有。 注：这里说明其他类调用一个类的final修饰的变量时，是不会存在类的加载的，是在编译时直接放在常量池的。 加载类加载类处于类加载的第一个阶段。在加载类时，Java虚拟机必须完成以下工作： 通过类的全名，获取类的二进制数据流 解析类的二进制数据流为方法区内的数据结构 创建java.lang.Class类的实例，表示该类型 验证验证类 准备当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置初始值。int：0 long:0L short:(short)0 char: \u000 boolean: false reference: null float: 0f double: 0f 当类中存在常量字段，分情况。在准备阶段，是不会发生字节码行为的。 public static final String constString =”const”; 当静态变量被final修饰后，该常量 constString在准备阶段被附上字符串”const” 但是如果没有final修饰过，仅仅作为普通变量： public static String cString=”const” 此时， cString的赋值在函数中发生，属于java字节码的行为，此时是在初始化中赋值（后面会说到） 解析类在准备阶段完成后，进入解析阶段。解析阶段的工作就是讲类、接口、字段和方法的符号引用转化为直接引用。符号引用就是字面量的引用。就是在class类文件中，通过常量池进行大量的符号引用。 初始化类的初始化是类的装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利的装载到系统中。此时，类才会执行java字节码。初始化阶段的重要是执行类的初始化方法。方法是由编译器自动生成的，他是有类静态成员的赋值语句以及static语句块合并产生的。由于加载一个类之前，虚拟机总是试图尝试加载该类的父类，因此父类的总是在子类之前被调用。也就是说，子类的static块优先级高于父类。 注：classLoader只负责类的加载，连接和初始化与classLoader无关。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-3-字符串的存储方式以及equals、intern、==之间的区别]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2FJVM-3-%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E5%AD%98%E5%82%A8%E6%96%B9%E5%BC%8F%E4%BB%A5%E5%8F%8Aequals%E3%80%81intern%E3%80%81-%E4%B9%8B%E9%97%B4%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[知识点：在jvm中，字符串有着非常“高等的地位”。在1.7以后，堆空间分为字符串常量池（也有叫做缓冲区）和非字符串常量池。 字符串常量池：用来存储字符串的字面量。 非字符串常量池：存储字符串对象以及其他普通的对象。 为什么要有字符串常量池：字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价。JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串池，每当代码创建字符串常量时，JVM会首先检查字符串常量池。如果字符串已经存在池中，就返回池中的实例引用。如果字符串不在池中，就会实例化一个字符串并放到池中。Java能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突进行共享。 字符串的创建方式：字符串有两种创建方式，一种是通过双引号直接赋值和通过构造器来创建。 双引号赋值：String s1=”11”;创建一个对象的时候，会判断字符串常量池是否会有”11”，没有在字符串常量池添加”11”，并在非字符串常量池创建String对象，这时s1变量是指向字符串常量的”11”的。 构造器创建：String s2=new String(“11”); 创建对象，并不会在字符串常量池进行操作，只会在非字符串常量池建立对象，s2指向指向这个对象。 所以再用“==”判断的时候是false，因为两个变量的指向是不一样的。 equals、==、intern()之间的区别equals：是父类Object的方法，String重类写了这一方法，判断是否是首先判断是否是同一对象，是的话返回true。接着判断是否是String类型、如果是再判断是否值相同。==：判断两个对象是否是同一对象，即两个对象的指向是否相同。intern()：其实并不是用来判断是否相等的用途，它是在非字符串常量池添加字面量，所以他通常和new String()结合使用，可以在非字符串常量池建立变量并且指向它。实例： 12345678910111213141516171819String s1="ab";String s2="abcd";String s3="ab"+"cd";String s4=s1+"cd"; System.out.println("----第一部分 ----");System.out.println(s2==s3);//trueSystem.out.println(s2==s3.intern());//trueSystem.out.println(s2.intern()==s3);//true System.out.println("---- 第二部分 ----");System.out.println(s2==s4);//falseSystem.out.println(s2==s4.intern());//trueSystem.out.println(s2.intern()==s4);//falseSystem.out.println("---- 第三部分 ----");System.out.println(s3==s4);//falseSystem.out.println(s3==s4.intern());//trueSystem.out.println(s3.intern()==s4);//false 第一部分解析：1、当String由两个字面量相加的时候，会判断字符串常量池，所以全是true。 第二部分解析：1、当String是变量和字面量相加的时候，不会在字符串常量池进行判断，所以两个对象指向不同，false。2、对s4这个对象进行intern()操作时，它会在字符串常量池进行判断，如果有的话，那么他不添加，没有的话就添加，所以为true。但是，记住即使s4.intern()不会改变s4的指向，他的指向还在非字符串常量池。如果想改变s4的指引的话，需要赋值。s4=s4.intern();所以说intern()应该跟new String(）结合使用，即 String s4=new String(“abcd”).intern()要不还需要有赋值的操作。3、还是如二所说，s4的指向还是非字符串常量池，所以不相等。 第三部分解析：根据第二部分自己看吧~ 注：在字符串尽量少使用 String ss=”ab”+”cd”这样的操作，因为这样的操作如同新建了StringBuilder，然后进行append，这好像并没有什么不妥，但是要记住，当你要遍历时，每次都会新建一个StringBuilder，这样很浪费资源。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-2-常用命令]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2FJVM-2-%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[堆内存设定-Xmx ：最大堆内存 -Xms ：初始堆内存 占空间设定-Xss ：指定线程最大栈空间 方法区：理解为永久区perm，在jdk1.6和1.7中存在，在1.8中剔除 -XX:PermSize：初始化方法区。 -XX:MaxPermSize:最大方法区：默认情况为64M 输出-XX:+PrintGC 打印gc日志 -XX:+PrintGCDetails 打印详细的gc日志 -XX:+PrintHeapAtGC 在每次GC前后分别打印堆的信息。 -XX:+PrintGCTimeStamps 该参数会在每个GC发生时，额外的输出GC发生的时间，该输出时间为虚拟机启动后的时间偏移量。 -XX:+PrintGCApplicationConcurrentTime 打印应用程序的执行时间 -XX:+PrintGCApplicationStoppedTime 打印应用程序由于GC而产生的停顿时间。 -XX:+PrintReferenceGC 跟踪系统中软引用、弱引用、虚引用和Finallize队列。 -Xloggc:log/gc.log 在当前目录下的log文件夹下的log文件夹下的gc.log文件中记录所有的GC日志。 类加载/卸载的跟踪-verbose:class 跟踪类的加载和卸载 -XX:+TranceClassLoading 跟踪类的加载 -XX:+TranceClassUnloading 跟踪类的卸载 Java虚拟机还允许研发人员在运行时打印、查看系统中类的分布情况。只要在系统中启动时加上-XX:+PrintClassHistogram参数，然后在Java的控制台中按下Ctrl+Break组合键，控制台上就会显示当前的类信息柱状图。 系统参数查看：-XX:+PrintVMOptions 在程序运行时，打印虚拟机接收到的命令行显示参数。 -XX:+PrintCommandLineFlags 可以打印传递给虚拟机的显示和隐示参数。 -XX:+PrintFlagsFinal 打印所有的系统参数的值（大约有500多个） 新生代配置：-Xmn 用于设置新生代的大小。新生代大小一般设置为整个堆空间的1/3到1/4之间。(-Xmn1m) -XX:SurvivorRatio=eden/from=eden/to 设置新生代中eden空间和from/to空间的比例关系。 （-XX:SurvivorRatio=2 新生代内存有10m，那么eden区的内存即为5m） -XX:NewRatio=老年代/新生代 设置新生代和老年代的比例（与-Xmn区别是一个是设置新生代绝对大小，一个是根据比例设置） 堆溢出处理：-XX:+HeapDumpOnOutOfMemoryError 在内存溢出时到处整个堆信息。 -XX:+HeapDumpPath:d:/a.dmp 和-XX:+HeapDumpOnOutOfMemoryError配合使用，导出堆的存放路径。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JVM-1-内部构成]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2FJVM-1-%E5%86%85%E9%83%A8%E6%9E%84%E6%88%90%2F</url>
    <content type="text"><![CDATA[类加载子系统：类加载子系统是负责从文件系统或者网络中加载class信息。（class信息，是已经编译过的java文件，所以这也就是为什么我们在linux系统上，需要上传WebRoot文件或者用ant编译工具进行编译） 方法区：加载的类信息放在方法区中的内存空间中，除了类的基本信息之外，还保存了运行时常量池信息，包括字符串字面量和数字常量。 java堆：java堆是在虚拟机启动的时候建立，是java程序中最主要的内存工作区域。几乎所有的java对象都会放在java堆中。堆空间所有线程共享。 直接内存：java的NIO库允许java程序使用直接内存，直接内存是在java堆外、直接向系统申请的内存空间，所以它的大小不会直接受限于Xmx指定的最大堆大小。但是系统的内存是有限的，所以java堆内存和直接内存的总和受限于操作系统内存的大小。 java栈：每一个虚拟机线程都会有一个私有的java栈。一个线程的java栈在线程创建的时候被创建，java栈中保存着帧信息，java栈中保存着局部变量、方法参数、同时与方法的调用、返回密切相关。 PC寄存器：也是每个线程的私有空间，java虚拟机会为每一个java线程穿件PC寄存器。在任意时刻，一个java线程总是执行一个方法，这个正在被执行的方法成为当前方法。如果当前方法不是本地方法，PC寄存器就会指向当前正在被执行的指令。如果当前方法是本地方法，那么PC寄存器的值就是undifined。 执行引擎：是java虚拟机最核心的组件之一，它负责执行虚拟机的字节码。现代虚拟机为了提高执行效率，会使用即使编译技术讲方法编译成机器码后再执行。]]></content>
      <tags>
        <tag>JVM</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java-利用注解完成字典表对应数据]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2Fjava-%E5%88%A9%E7%94%A8%E6%B3%A8%E8%A7%A3%E5%AE%8C%E6%88%90%E5%AD%97%E5%85%B8%E8%A1%A8%E5%AF%B9%E5%BA%94%E6%95%B0%E6%8D%AE%2F</url>
    <content type="text"><![CDATA[设计思路：1、首先将字典表的数据以Map的形式进行初始化，key格式为type+”@”+code,value值为正常回显的值，如”ta_sex”+”@”+”1”, “男” 2、建立DictAcc注解，code代表是数据库字段还是需要回显的标识，type存储类型如ta_sex1234567@Target(ElementType.FIELD)@Retention(RetentionPolicy.RUNTIME)public @interface DictACC &#123; public String code(); public String type();&#125; 3.建立一个类BV，code表示数据库存储的名字，name表示需要回显的名字1234567public class BV &#123; public final static String code="code"; public final static String name="name"; &#125; 4.在pojo中字段sex，再建立sex_n表示要回显的字段（_n必须对应）1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859public class User &#123; @DictACC(code = BV.code, type = "ta_orgType") public String orgType="1"; @DictACC(code = BV.name, type = "ta_orgType") public String orgType_n; @DictACC(code = BV.code, type = "ta_sex") public String sex="1"; @DictACC(code = BV.name, type = "ta_sex") public String sex_n; public String getOrgType() &#123; return orgType; &#125; public void setOrgType(String orgType) &#123; this.orgType = orgType; &#125; public String getOrgType_n() &#123; return orgType_n; &#125; public void setOrgType_n(String orgType_n) &#123; this.orgType_n = orgType_n; &#125; public String getSex() &#123; return sex; &#125; public void setSex(String sex) &#123; this.sex = sex; &#125; public String getSex_n() &#123; return sex_n; &#125; public void setSex_n(String sex_n) &#123; this.sex_n = sex_n; &#125; &#125; 5.代码如下：map相当与数据库中取出来的数据库字典表12345678910111213141516171819202122232425public class MainTest &#123; public static void main(String[] args) throws IllegalArgumentException, IllegalAccessException &#123; HashMap&lt;String, String&gt; map=new HashMap&lt;String, String&gt;(); map.put("ta_orgType"+"@"+"1", "部门1"); map.put("ta_orgType"+"@"+"2", "部门2"); map.put("ta_orgType"+"@"+"3", "部门3"); map.put("ta_sex"+"@"+"1", "男"); map.put("ta_sex"+"@"+"2", "女"); User user=new User(); User user1=new User(); List&lt;User&gt; userList=new ArrayList&lt;User&gt;(); userList.add(user); userList.add(user1); Doaction.fill(userList,map); for (int i = 0; i &lt; userList.size(); i++) &#123; System.out.println(userList.get(0).getOrgType_n()); &#125; &#125;&#125; 6.利用反射完成对sex_n等赋值1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public class Doaction &#123; public static &lt;T&gt; void fill(List&lt;T&gt; pojoList, HashMap&lt;String, String&gt; dictmap) throws IllegalArgumentException, IllegalAccessException &#123; Map&lt;String, Map&lt;String, Field&gt;&gt; map = getDictMap(pojoList.get(0)); Map&lt;String, Field&gt; codeMap = map.get("codeMap"); Map&lt;String, Field&gt; nameMap = map.get("nameMap"); for (T pojo:pojoList) &#123; fillname(pojo, codeMap, nameMap, dictmap); &#125; &#125; /** * 获取带DictACC字典注解的字段，并拼接成Map * @param t * @return */ public static &lt;T&gt; Map&lt;String, Map&lt;String, Field&gt;&gt; getDictMap(T t) &#123; //字典code值组成的Map Map&lt;String, Field&gt; codeMap = new HashMap&lt;String, Field&gt;(); //需要从code值转成value组成的Map Map&lt;String, Field&gt; nameMap = new HashMap&lt;String, Field&gt;(); List&lt;Field&gt; fieldlist =new ArrayList&lt;Field&gt;(); //获取父类的所有field fieldlist.addAll(Arrays.asList(t.getClass().getSuperclass().getDeclaredFields())); //获取本类的所有field fieldlist.addAll(Arrays.asList(t.getClass().getDeclaredFields())); for (Field field : fieldlist) &#123; if (field.getAnnotation(DictACC.class) != null) &#123; DictACC ann = field.getAnnotation(DictACC.class); if (ann.code().equals(BV.code)) &#123; codeMap.put(ann.type() + "@" + field.getName(), field); &#125; else if (ann.code().equals(BV.name)) &#123; nameMap.put(ann.type() + "@" + field.getName(), field); &#125; &#125; &#125; Map&lt;String, Map&lt;String, Field&gt;&gt; map = new HashMap&lt;String, Map&lt;String, Field&gt;&gt;(); map.put("codeMap", codeMap); map.put("nameMap", nameMap); return map; &#125; public static &lt;T&gt; void fillname(T t, Map&lt;String, Field&gt; codeMap, Map&lt;String, Field&gt; nameMap, HashMap&lt;String, String&gt; dictmap) throws IllegalArgumentException, IllegalAccessException &#123; for (Entry&lt;String, Field&gt; entry : nameMap.entrySet()) &#123; //获取codekey String codeKey = entry.getKey().substring(0, entry.getKey().length() - 2); if (codeMap.get(codeKey) != null) &#123; Field field = codeMap.get(codeKey); //获取code的值 String value = String.valueOf(field.get(t)); String targetKey = codeKey.split("@")[0] + "@" + value; if (dictmap.containsKey(targetKey)) &#123; //从字典表获取那么中应该存的值 String targetValue = dictmap.get(targetKey); Field targetField = entry.getValue(); targetField.setAccessible(true); //给name赋值 targetField.set(t, targetValue); &#125; &#125; &#125; &#125;&#125;]]></content>
      <tags>
        <tag>java基础</tag>
        <tag>注解</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mybatis-xml文件解释]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2Fmybatis-xml%E6%96%87%E4%BB%B6%E8%A7%A3%E9%87%8A%2F</url>
    <content type="text"><![CDATA[mybatis将表的属性用resultMap表示1234567891011121314151617181920212223242526272829303132333435363738&lt;resultMap id="BaseResultMap" type="com.model.TMarine" &gt;&lt;id column="ID" property="id" jdbcType="INTEGER" /&gt;&lt;result column="ADDRESS" property="address" jdbcType="VARCHAR" /&gt;&lt;result column="AREA_ID" property="areaId" jdbcType="INTEGER" /&gt;&lt;result column="CONTACT" property="contact" jdbcType="VARCHAR" /&gt;&lt;result column="CREATE_TIME" property="createTime" jdbcType="TIMESTAMP" /&gt;&lt;result column="FAX" property="fax" jdbcType="VARCHAR" /&gt;&lt;result column="FIRST_LETTER" property="firstLetter" jdbcType="VARCHAR" /&gt;&lt;result column="IS_DEL" property="isDel" jdbcType="INTEGER" /&gt;&lt;result column="IS_MODABLE" property="isModable" jdbcType="INTEGER" /&gt;&lt;result column="IS_ORGAN" property="isOrgan" jdbcType="INTEGER" /&gt;&lt;result column="LEVEL_ID" property="levelId" jdbcType="INTEGER" /&gt;&lt;result column="MARINE_CODE" property="marineCode" jdbcType="VARCHAR" /&gt;&lt;result column="MARINE_NAME" property="marineName" jdbcType="VARCHAR" /&gt;&lt;result column="PHONE" property="phone" jdbcType="VARCHAR" /&gt;&lt;result column="POSTCODE" property="postcode" jdbcType="VARCHAR" /&gt;&lt;result column="UPDATE_TIME" property="updateTime" jdbcType="TIMESTAMP" /&gt;&lt;result column="PID" property="pid" jdbcType="INTEGER" /&gt;&lt;/resultMap&gt; resultMap中的id标签，作为唯一表示。 套用sql，常将表的属性分隔。 &lt;sql id="Base_Column_List" &gt; ID, ADDRESS, AREA_ID, CONTACT, CREATE_TIME, FAX, FIRST_LETTER, IS_DEL, IS_MODABLE, IS_ORGAN, LEVEL_ID, MARINE_CODE, MARINE_NAME, PHONE, POSTCODE, UPDATE_TIME, PID &lt;/sql&gt; &lt;select id="selectByPrimaryKey" resultMap="BaseResultMap" parameterType="java.lang.Integer" &gt; select &lt;include refid="Base_Column_List" /&gt; from t_marine where ID = #{id,jdbcType=INTEGER} &lt;/select&gt; #{}，${} 的区别#{} JDBC preparedstatement参数的占位符标志，可以防止sql注入 ${} 仅仅是字符串替换，而且有sql注入的危险 prepareStatement会先初始化SQL，先把这个SQL提交到数据库中进行预处理，多次使用可提高效率。 createStatement不会初始化，没有预处理，没次都是从0开始执行SQL 有时查询有条件，有时没有条件，用where可以根据情况判断是否用where，并删除多余的and 用根据判断，可以设定update具体修改哪些字段，而不需要全部修改，比如用户表里有creatTime表示添加时间并且有值，但是在修改的表单提交没有将creatTime添加进去，这样整体update就会将createTime变成空。使用标签还可以自动去掉修改最后的逗号。 实例： &lt;trim prefix="(" suffix=")" suffixOverrides=","&gt; &lt;/trim&gt; 在语句之前加入“(”,在末尾加入”)”,并去掉最后一个逗号。 resultMap 和 resultType 的区别resultType和resultMap 均指返回类型，resultType是直接表示返回类型的，而resultMap则是对外部ResultMap的引用，但是resultType跟resultMap不能同时存在。 个人理解：当你的数据只是想单纯的返回一个map，用resultType=”java.util.HashMap”,如果想返回一个对象或者一个对象的列表，resultMap=”BaseResultMap”,BaseResultMap是一个映射，即表的属性。]]></content>
      <tags>
        <tag>mybatis</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Linux-安装tomcat7时遇到的情况]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2FLinux-%E5%AE%89%E8%A3%85tomcat7%E6%97%B6%E9%81%87%E5%88%B0%E7%9A%84%E6%83%85%E5%86%B5%2F</url>
    <content type="text"><![CDATA[首先我们需要在linux上安装jdk，linux-centOS7下安装jdk1.8。 解压文件很简单，这里主要是我分享一下我遇到的问题 1、下载apache-tomcat-8.0.47.tar.gz包并且解压，命令为tar-zxvf apache-tomcat-8.0.47.tar.gz 2、在解压的文件下，新建目录logs(与bin目录平级)，这个目录是用来记录日志的。不建的话，tomcat会提示你的。 3、因为我用的是centos7，因为防火墙的原因是不会在外网访问的。所以我们要讲8080端口写入到防火墙了。 注意：防火墙操作需要root用户，所以不是root用户先切换到root用户。 firewall-cmd –zone=public(作用域) –add-port=80/tcp(端口和访问类型) –permanent(永久生效) 添加端口：firewall-cmd –zone=public –add-port=8080/tcp –permanent 重启防火墙：firewall-cmd –reload 检查8080端口是否添加到：firewall-cmd –list-ports 如果以后想删除,命令为firewall-cmd –zone= public –remove-port=8080/tcp –permanent（这句话现在就不要执行了）。 4、将bin目录下的权限都改一下，否则无法执行。 在bin的目录下 chmod 775 * 5、在logs目录下查看日志catalina.out Error: Could not find or load main class org.apache.catalina.startup.Bootstrap 我在官网上重新下了不同版本的包，均是这个错误。然后在资料上查询是jvm的版本低于tomcat支持的版本，即tomcat的版本过高，所以我尝试用了版本较低的tomcat版本，错误消失。 6、进行访问192.168.14.172:8080 访问成功，我们linux上安装tomcat就结束了。]]></content>
      <tags>
        <tag>linux</tag>
        <tag>tomcat</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-centOS7下安装jdk1.8]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2Flinux-%E5%AE%89%E8%A3%85jdk1-8%2F</url>
    <content type="text"><![CDATA[准备准备环境：centos7 jdk1.8的压缩包：jdk-8u144-linux-x64.tar.gz 在新建的centos7下，我新建了一个用户guojian(我的名字)。 卸载OpenJDK自带的linux下会自带OpenJDK，有时候我们并不了解，所以建议删除它。 使用rpm -qa|grep jdk；检查一下。 发现确实存在两个版本1.7和1.8，使用yum -y remove java java* 进行批量卸载。 提示我们必须使用root用户才能卸载，我们登录root用户执行即可。 yum -y remove java copy-java* 把copy-jdk开头的也卸载掉。 卸载完成后，使用exit退出root用户。 安装jdk1.8查看一下自己目录的位置：$HOME 我们进入/home/guojian下使用mkdir 分别两个文件夹download(用下上传下载用),usr(作为安装软件的目录)。 用ftp软件工具将下载好的压缩包上传到download下。 然后进行解压。tar-zxvf jdk-8u144-linux-x64.tar.gz 使用ll命令检查一下，发现解压成功。然后将文件夹更名为jdk1.8 mv jdk1.8.0_144 jdk1.8 将文件夹移动到/home/guojian/usr下 mv jdk1.8 /home/guojian/usr 设置环境变量：在用户guojian的根目录下，即/home/guojian cat .bash_profile 检查文件是否存在 或者使用ls -a 查看（ .bash_profile是隐藏文件） 使用vim .bash_profile 进行添加或者新建 JAVA_HOME=/home/guojian/usr/jdk1.8 CLASSPATH=$JAVA_HOME/lib/ PATH=$PATH:$JAVA_HOME/bin export PATH JAVA_HOME CLASSPATH 保存退出。 我们使用java -version检查一下是否配置成功。发现没有，原因是.bash_profile文件的原因，是用户下的配置文件，每次用户登录的时候自动载入，所以我们需要重新登录一次或者使用source .bash_profile;进行加载。 再次使用java -version 配置结束。]]></content>
      <tags>
        <tag>linux</tag>
        <tag>jdk</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux-权限管理]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2Flinux-%E6%9D%83%E9%99%90%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[在linux下我们ll的时候就会看见相应文件的权限，总共有十位。 第一位：代表着当前文件的类型。如果是-代表的就是文件，如果是d就代表这文件夹。 第2-9位：根据上图描述，其实是分为三组的，分别是所有者、用户组、其他。每个组都有三个权限分别是可读、可写、可执行。 平常我们会用 chmod 775 test.txt来修改权限，这个775代表的是什么意思呢。 每个组的有三个权限，用二进制来表示，即r：4，w：2，x：1。如果该位置没有权限用“-”（0）来代替。 775的含义就是：所有者和所有者的用户组有可读、可写、可执行的权限，其他用户只有可读和可执行的权限。 注意这个可执行权限（X）： 作用于文件夹：当使用 chmod -R 776 WebRoot时，其他用户是无法进入WebRoot文件夹的，因为没有为他配置可执行的权限，此时X相当于文件夹的钥匙，你没有这个权限，你就访问不了。 作用于文件：当使用chmod 774 start.sh，当文件是可执行文件，其他用户只能查看文件，而不能执行.sh的可执行文件。 现实操作中，需要将文件夹和里面的文件进行分别配置可能达到最好的效果。]]></content>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[log4j2配置详解]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2Flog4j2%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[输出规则：标签是控制台，表示在控制台进行输出。 Log4j由三个重要的组成的构建组成：记录器(Loggers)、输出源（Appenders）、 和布局(Layouts) 记录器的Level是日志记录的优先级：debug&lt;info&lt;warn&lt;error 记录器的level级别为info，那么这个记录器记录的级别就是&gt;= info,即info、warn、error。 输出源：org.apache.log4j.ConsoleAppender(控制台) org.apache.log4j.FileAppender(文件) org.apache.log4j.DailyRollingFileAppender(每天产生一个日志文件) org.apache.log4j.RollingFileAppender(文件大小到达指定尺寸的时候产生一个新的文件) org.apache.log4j.WriterAppender(将日志信息以流的格式发送到任意指定的地方) org.apache.log4j.SocketAppender(socket) org.apache.log4j.NtEventLogAppender(NT的Event Log) org.apache.log4j.JMSAppender(电子邮件) layout(布局)布局种类org.apache.log4j.HTMLLayout（以HTML表格形式布局） org.apache.log4j.PatternLayout(可以灵活地指定布局模式) org.apache.log4j.SimpleLayout(包含日志信息的级别和信息字符串) org.apache.log4j.TTCCLayout(包含日志产生的时间、线程、类别等等信息) 如果使用了PatternLayout，则Log4j采用类似C语言中println函数的打印格式格式化日志信息 %m 输出代码中的指定消息 %P 输出优先级，即debug、info、warn、error、fatal %r 输出自应用启动到输出该log信息耗费的毫秒数 %c 输出所属的类目，通常就是所在类的全名 %t 输出产生该日志事件的线程名 %n 输出一个回车换行符,Windows平台下为”/n/r”，Unix平台为“/n” %d 输出日志时间点的日期或事件，默认格式为ISO8601，也可以在其后制定格式。 %l 输出日志事件的发生位置，包括类目名、发生的线程，以及在代码中的行数。 Configuration标签 Status属性：有八种，可以检测log4j2的配置文件是否有错，也可以检测到死循环的logger。 monitorInterval：自动检测配置文件的事件间隔，单位是秒，最小间隔是5秒。Log4j2检测到配置文件有变化，会重新配置自己。 输出源标签：是将日志输出到控制台上。 Filename:日志存放路径 bufferedIO：是否有缓存IO bufferSize：bufferSize内存大小 filePattern：压缩后的路径 PatternLayout下的pattern：日志输出的内容 SizeBasedTriggeringPolicy：容量达到多少进行压缩 Loggers： Additivity：false 避免重复打印 log4j2.xml样本12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182&lt;?xml version="1.0" encoding="UTF-8"?&gt; &lt;Configuration status="OFF" &gt; &lt;Appenders&gt;&lt;Console name="console" target="SYSTEM_OUT"&gt;&lt;PatternLayout pattern="[%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;][%p][%c&#123;1&#125;][Line:%L] %m%n" /&gt;&lt;/Console&gt; &lt;RollingFile name="clearcontrolLog" fileName="/amots/appfiles/logs/clearcontrol/clearcontrolLog.log" bufferedIO="true"bufferSize="8192" filePattern="/amots/appfiles/logs/clearcontrol/clearcontrolLog-%d&#123;yyyy-MM-dd-HH&#125;-%i.log.gz"&gt;&lt;PatternLayout pattern="[%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;][%p][%c&#123;1&#125;][Line:%L] %m%n" /&gt;&lt;Policies&gt;&lt;TimeBasedTriggeringPolicy interval="24" /&gt;&lt;SizeBasedTriggeringPolicy size="30MB" /&gt;&lt;/Policies&gt;&lt;/RollingFile&gt; &lt;RollingFile name="clearofbaseLog" fileName="/amots/appfiles/logs/clearofbase/clearofbaseLog.log" bufferedIO="true"bufferSize="8192" filePattern="/amots/appfiles/logs/clearofbase/clearofbaseLog-%d&#123;yyyy-MM-dd-HH&#125;-%i.log.gz"&gt;&lt;PatternLayout pattern="[%d&#123;yyyy-MM-dd HH:mm:ss,SSS&#125;][%p][%c&#123;1&#125;][Line:%L] %m%n" /&gt;&lt;Policies&gt;&lt;TimeBasedTriggeringPolicy interval="24" /&gt;&lt;SizeBasedTriggeringPolicy size="30MB" /&gt;&lt;/Policies&gt;&lt;/RollingFile&gt;&lt;/Appenders&gt; &lt;Loggers&gt; &lt;!-- amots --&gt;&lt;Logger name="clearcontrol" level="INFO" additivity="false"&gt;&lt;!-- &lt;AppenderRef ref="console" /&gt; --&gt;&lt;AppenderRef ref="clearcontrolLog" /&gt;&lt;/Logger&gt;&lt;Logger name="clearofbase" level="INFO" additivity="false"&gt;&lt;!-- &lt;AppenderRef ref="console" /&gt; --&gt;&lt;AppenderRef ref="clearcontrolLog" /&gt;&lt;/Logger&gt;&lt;/Loggers&gt;&lt;/Configuration&gt; 注： 1、应用中不可直接使用日志系统(log4j、Logback)中的api，而应依赖使用日志框架的SLF4J中的框架，使用门面模式的日志模式的框架、有利于维护和各个类的日志处理方式统一。 12345import org.slf4j.Logger;import org.slf4j.LoggerFactory;private static final Logger logger=LoggerFactory.getLogger(ABC.class); 2、对trace/debug/ingo级别的日志输出，必须使用条件形式或者使用占位符的方式。在使用logger输出时，如果配置级别为info，那么在输出日志时，如果不加，日志不会打印，但是会执行字符串拼接。对象会执行toString()方法，浪费系统资源，执行了操作，还没有打印日志。 应加123456if(logger.isDebugEnacled())&#123; logger.debug("");&#125; 或者12logger.debug("processing debug with id:&#123;&#125; symbol:&#123;&#125;",id,symbol)]]></content>
      <tags>
        <tag>log4j2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ的简单实现]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2FActiveMQ%E7%9A%84%E7%AE%80%E5%8D%95%E5%AE%9E%E7%8E%B0%2F</url>
    <content type="text"><![CDATA[环境jdk1.8 ActiveMQ环境并启动 ActiveMQ的依赖包 &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.apache.activemq&lt;/groupId&gt; &lt;artifactId&gt;activemq-all&lt;/artifactId&gt; &lt;version&gt;5.9.0&lt;/version&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 队列模式新建类队列模式生产者 123456789101112131415161718192021222324252627public class QueueProducer &#123; private static final String queneName = "qqueue-test"; public static void main(String[] args) throws JMSException &#123; //创建连接工厂 ConnectionFactory connectionFactory=new ActiveMQConnectionFactory(ActiveMQConnection.DEFAULT_USER, ActiveMQConnection.DEFAULT_PASSWORD, ActiveMQConnection.DEFAULT_BROKER_URL); //创建连接 Connection connection= connectionFactory.createConnection(); //启动连接 connection.start(); //创建会话 Session session=connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建一个目标 Destination destination= session.createQueue(queneName); //创建一个生产者 MessageProducer producer=session.createProducer(destination); for (int i = 0; i &lt;10 ; i++) &#123; TextMessage textMessage=session.createTextMessage("test"+i); producer.send(textMessage); System.out.println("发送消息:"+textMessage.getText()); &#125; //关闭连接 connection.close(); &#125;&#125; 因为是默认启动，所以连接工厂的用户名、密码以及ip均是默认。 然后我们输入默认网址：127.0.0.1:8161 初始帐号密码是admin/admin 可以查看队列的详细信息。 我们可以在这里看一下信息： name：名称 Number Of Pending Messages ：被挂起的消息，指的是还未被消费的信息。 Number Of Consumers ：连接的消费者，0代表当前连接的消费者为0. Messages Enqueued ：发送消息的总数。 Messages Dequeued：消息出队，已经被消费的消息。 然后我们创建消费者进行消费 1234567891011121314151617181920212223242526272829303132public class QueueConsumer &#123; private static final String queneName = "qqueue-test"; public static void main(String[] args) throws JMSException &#123; //创建工厂 ConnectionFactory connectionFactory=new ActiveMQConnectionFactory("admin","admin","failover://tcp://localhost:61616"); //新建连接 Connection connection=connectionFactory.createConnection(); //启动连接 connection.start(); //创建会话，并且设置会话的模式 Session session=connection.createSession(false, Session.AUTO_ACKNOWLEDGE); //创建一个目标 Destination destination=session.createQueue(queneName); //创建一个消费者 MessageConsumer consumer=session.createConsumer(destination); //创建一个监听 consumer.setMessageListener(new MessageListener() &#123; @Override public void onMessage(Message message) &#123; TextMessage textMessage= (TextMessage) message; try &#123; System.out.printf("接收消息："+textMessage.getText()); &#125; catch (JMSException e) &#123; e.printStackTrace(); &#125; &#125; &#125;); //连接不能在这里关闭，可以让监听一直启动，因为lisener是异步的，当线程还没执行完任务时，连接就已经关闭了。 //connection.close(); &#125;&#125; 然后我们运行QueueConsumer，那么十条信息会被消费者消费。然后我们再启动一个消费者，即有两个消费者时，在运行QueueProducer，两个消费者会依次消费信息]]></content>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ActiveMQ概述]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2FActiveMQ%E6%A6%82%E8%BF%B0%2F</url>
    <content type="text"><![CDATA[ActiveMQ是一个消息中间件。 什么是消息中间件？关注于数据的发送和接收，利用高效可靠的异步消息传递机制集成分布式系统。 为什么使用消息中间件？解耦、安全可靠、异步、顺序保证、横向扩展等。 什么是JMS？java消息服务（Java Message Service）即JMS，是一个java平台中关于面向消息中间件的API，用于在两个程序之间，或分布式系统中发送消息，进行异步通信。 什么是AMQP？AMQP（advanced message queuing protocol）是一个提供统一消息服务的应用层标准协议，基于此协议的客户端与消息中间件可传递消息，并不受客户端/中间件不同产品，不同开发语言等条件的限制。 JMS和AMQP的区别：JMS是规范，相当于提供接口，然后每个厂商根据规范来进行自己的实现，而AMQP不从API层进行限定，而是直接定义网络交换的数据格式。这使得实现了AMQP的provider天然性就是跨平台的。 JMS规范：ConnectionFactory：用于创建连接到消息中间件的工厂。 Connection：代表了应用程序和消息服务之间的通信链路。 Destination：指消息发布和接收的地点，包括队列和主题两种模式。 Session：表示一个单线程的上下文，用于发送和接收消息。 MessageConsumer：由会话创建，用于接受发送到目标的消息。 MessageProducer：由会话创建，用于发送消息到目标。 Message：是在消费者和生产者之间传送的对象，消息头，一组消息属性，一个消息体。]]></content>
      <tags>
        <tag>ActiveMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java多线程-join()]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2Fjava%E5%A4%9A%E7%BA%BF%E7%A8%8B-join%2F</url>
    <content type="text"><![CDATA[join()使用介绍join()方法是使线程强制执行，在线程A中，创建了线程b，b.start(）的时候，那么a，b两个线程都会运行。但是如果b线程使用了b.join()，那么就会强制执行b线程，并且将A线程挂起。 场景1：三个线程t1,t2,t3三个线程，确保运行t1结束后运行t2，在t2运行结束后运行t3。 12345678910111213141516171819202122232425262728293031323334353637383940414243public class ThreadTest &#123; public static void main(String[] args) &#123; Thread t1=new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;,"t1"); try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread t2=new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); &#125; &#125;,"t2"); Thread t3=new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; t2.join(); System.out.println(Thread.currentThread().getName()); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); &#125; &#125;,"t3"); t3.start(); t2.start(); t1.start(); &#125;&#125; 输出结果：t1,t2,t3 三个线程使用启动后，如果t3先一步执行，那么在t3的run()方法里使用了t2.join(),强迫t2执行并使t3阻塞，当t2运行结束后，t3才会进行修改。 延伸：假如我们想在这个基础上三个线程都运行后在运行主线程。 即在t1.start()方法后在加一个1System.out.println("主线程运行结束"); 单纯的加，结果为：主线程结束t1t2t3 说明了主线程是先运行结束的（当然结果也可能是其他的，主线程也可能是后结束的），我们如何保证他的顺序呢。 我们可以在 t1.start();和”主线程运行结束”之间加上t1.join()呢？我们想到，那么当运行t1.join()的时候，确保了先执行t1()，之后再执行主线程，所以保证了t1和主线程的顺序，但是t2，t3我们是没有办法确保他们与主线程之间的先后顺序。所以在加上t2,t3的join方法就会确保三个线程都执行完毕后在执行主线程。不过有更好的方法，因为我们再以上的方法中已经确定了t1,t2,t3的执行顺序，那么只要是确保t3线程能够阻塞主线程，那么就可以完成t1-t2-t3-“主线程运行结束”这个顺序了。代码如下：1234567891011121314151617181920212223242526272829303132333435363738394041424344454647public class ThreadTest &#123; public static void main(String[] args) &#123; Thread t1=new Thread(new Runnable() &#123; @Override public void run() &#123; System.out.println(Thread.currentThread().getName()); &#125; &#125;,"t1"); try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; Thread t2=new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; t1.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); &#125; &#125;,"t2"); Thread t3=new Thread(new Runnable() &#123; @Override public void run() &#123; try &#123; t2.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println(Thread.currentThread().getName()); &#125; &#125;,"t3"); t3.start(); t2.start(); t1.start(); try &#123; t3.join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; System.out.println("主线程结束"); &#125;&#125; 场景2：假如我们有一个很大的arrayList，里面存放的User类型，要对list进行操作，那么如果不用多线程，执行时间很长，我们可以用join()方法来解决。假设我们要讲User的value都执行*10操作。 创建User类12345678910111213141516171819202122public class User &#123; private String name; private Integer value; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Integer getValue() &#123; return value; &#125; public void setValue(Integer value) &#123; this.value = value; &#125;&#125; 创建线程类1234567891011121314151617public class ThreadT implements Runnable&#123; private List&lt;User&gt; list; ThreadT(List&lt;User&gt; list)&#123; this.list=list; &#125; @Override public void run() &#123; for (User user:list) &#123; System.out.println("执行线程为"+Thread.currentThread().getName()); user.setValue(user.getValue()*10); &#125; &#125;&#125; 测试类：123456789101112131415161718192021222324252627public static void main(String[] args) &#123; System.out.println("主线程开始"); List&lt;User&gt; list=new ArrayList&lt;User&gt;(); for (int i=0;i&lt;500;i++)&#123; User user=new User(); user.setName("user"+i); user.setValue(i); list.add(user); &#125; Thread [] threads=new Thread[5]; for (int i = 0; i &lt; threads.length; i++) &#123; threads[i]=new Thread(new ThreadT(list.subList(i*100,(i+1)*100)),"t"+i); threads[i].start(); &#125; for (int i = 0; i &lt; threads.length; i++) &#123; try &#123; threads[i].join(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; for (User user:list) &#123; System.out.println(user.getName()+"-----"+user.getValue()); &#125; System.out.println("主线程结束"); &#125; 根据打印的输出语句：我们是并发执行了四个线程，四个线程都join(),所以当四个线程都运行结束后，主线程才会循环list，数据均是正确的。 疑问：为什么threads[i].join()不写在threads[i].start()后呢，为什么还要重新写一个for循环呢，这样不是很麻烦么？ 原因：如果threads[i].join()放在threads[i].start()后，当程序运行到threads[i].start()时，只启动了t1，然后t1.join(),这样主线程就被阻塞了，所以等到t1线程运行之后，才运行t2，然后又阻塞了主线程….没有达到t1~t4同步执行。]]></content>
      <tags>
        <tag>java多线程</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[idea-构建maven web项目]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F11%2Fidea-%E6%9E%84%E5%BB%BAmaven-web%E9%A1%B9%E7%9B%AE%2F</url>
    <content type="text"><![CDATA[idea配置maven在File-OtherSettings-Default Settings…下进行maven配置 选择maven进行maven项目配置。 然后设置maven下的runner 新建项目点击File-new…-project groupId 是组，ArtifactId是项目名称。 然后进行项目构建，当maven显示构建成功，完成后，说明我们的项目构建成功了。构建完成的标志就是下图所示 期间错误： 有时候会显示maven一直在下载，浪费很长时间也没有下载下来，这个时候可以修改一下maven的Settings.xml的配置文件，增加一个国内的镜像，我添加的是阿里巴巴的镜像。 建议：期间先使用mvn -v 命令查看maven和jdk版本，最好与idea配置的maven一致。 配置项目在main下新建一个java文件，并设置为Sources用来存放java文件，将resources设置为Resources。配置完成后是样子。 设置Artfacts，这个是设置输出目录，如果这个不设置，之后就算是配置了tomcat也无法启动项目，因为tomcat找不到相应的目录。 配置Tomcat 然后选择Deployment选项，选择我们刚才设置的Artfacts。Application Context是设置项目名称，不设置就是没有。 然后启动tomcat，配置完成]]></content>
      <tags>
        <tag>idea</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Spring-1-基础概念之依赖装配]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F10%2FSpring-1-%E5%9F%BA%E7%A1%80%E6%A6%82%E5%BF%B5%E4%B9%8B%E4%BE%9D%E8%B5%96%E8%A3%85%E9%85%8D%2F</url>
    <content type="text"><![CDATA[Spring的核心就是简化java开发，为了降低java开发的复杂性，当一个类中调用另一个类的时候，会存在耦合，不利于理解和测试。正常情况下，每个对象负责管理和与自己相互协作的对象(即它所依赖的对象)，这将会导致高度耦合和难以测试的代码。Spring采取了以下4中策略。 基于pojo的轻量级和最小侵入性策略Spring通过应用上下文(Application Context)装载bean的定义并把他们组装起来。Spring应用上下文全权负责对象的创建和组装。 通过依赖注入和面向接口实现松耦合依赖注入（DI）现在属于一种策略模式，它的作用是让相互协作的软件组件保持松散耦合。 通过切面和惯例进行声明式编程面向切面编程（AOP）允许你把遍历应用各处的功能分离出来形成可重用性组件。（例如事务和日志） 通过切面和模版减少样式代码spring跟很多软件进行集成，包括mybatis，hibernate，redis等等。 例子：我们现在有一个支付接口Payservice ，他只有一个方法就是支付。 public interface Payservice { void pay(Integer num); } 现在我们有一个实现类PhonePayServiceImpl通过手机进行支付操作 public class PhonePayServiceImpl implements Payservice{ public void pay(Integer num) { System.out.println(&quot;使用手机支付了&quot;+num); } } 那么我们现在有一个类是支付入口PayEntrance，正常情况下，我们会这么写 public class PayEntrance { private Payservice payservice=new PhonePayServiceImpl(); public void doPay(){ payservice.pay(100); } } 或者使用构造器 public PayEntrance(){ this.payservice=new PhonePayServiceImpl(); } 我们的支付入口PayEntrance与支付接口payservice、手机支付实现PhonePayServiceImpl紧紧的耦合在了一起，那么如果我们支付入口还需要验证密码、发送验证码等功能呢，那么依赖的对象会非常多，而且这样的代码无法进行测试。 依赖注入依赖注入就是控制反转的核心，每一个对象不负责创建和管理与它合作的对象，在spring中，交给spring容器负责。 构造器注入：public PayEntrance(Payservice payservice){ this.payservice=payservice; } 现在我们发现，我们的支付入口并没有创建手机支付实现类，对于支付入口来说，只要我实现了payservice接口，那么我甚至不知道我具体使用了哪种支付方式（假设我们还有一个支付实现类为电脑端），支付方式对于支付入口来说无关紧要了，这就是DI最大的优点，松耦合。 setter方法：public void setPayservice(Payservice payservice) { this.payservice = payservice; } 接口注入：需要新建一个接口 public interface InjectPayService { public void injectPayService(Payservice payservice); } 然后继承这个接口 public class PayEntrance implements InjectPayService{ private Payservice payservice; public void injectPayService(Payservice payservice) { this.payservice=payservice; } }]]></content>
      <tags>
        <tag>spring</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深复制和浅复制]]></title>
    <url>%2Fguojian731.github.io%2F2017%2F12%2F05%2F%E6%B7%B1%E5%A4%8D%E5%88%B6%E5%92%8C%E6%B5%85%E5%A4%8D%E5%88%B6%2F</url>
    <content type="text"><![CDATA[我们在正常编写代码的时候，经常会有复制对象的需求。我们会使用=进行赋值，但是没有人说过=可以复制，为什么呐。因为有个对象student，将student1=student，你再修改student里的属性place的时候，student1的place也会改变。那是因为这两个对象的在jvm中的指向是同一个，并没有新建对象，这样在代码处理上就会出现问题。 首先，看一下源码： 123public class Object &#123; protected native Object clone() throws CloneNotSupportedException;&#125; 第一：Object类的clone()方法是一个native方法，native方法的效率一般来说都是远高于Java中的非native方法。这也解释了为什么要用Object中clone()方法而不是先new一个类，然后把原始对象中的信息复制到新对象中，虽然这也实现了clone功能。（JNI是Java Native Interface的 缩写。从Java 1.1开始，Java Native Interface (JNI)标准成为java平台的一部分，它允许Java代码和其他语言写的代码进行交互。JNI一开始是为了本地已编译语言，尤其是C和C++而设计的，但是它并不妨碍你使用其他语言，只要调用约定受支持就可以了。使用java与本地已编译的代码交互，通常会丧失平台可移植性。但是，有些情况下这样做是可以接受的，甚至是必须的，比如，使用一些旧的库，与硬件、操作系统进行交互，或者为了提高程序的性能。JNI标准至少保证本地代码能工作在任何Java 虚拟机实现下。） 第二：Object类中的 clone()方法被protected修饰符修饰。这也意味着如果要应用 clone()方 法，必须继承Object类，在 Java中所有的类是缺省继承 Object类的，也就不用关心这点了。然后重载 clone()方法。还有一点要考虑的是为了让其它类能调用这个 clone类的 clone()方法，重载之后要把 clone()方法的属性设置为 public。 第三：Object.clone()方法返回一个Object对象。我们必须进行强制类型转换才能得到我们需要的类型。 实现Cloneable接口 首先，看一下源码： public interface Cloneable {}Cloneable接口仅仅是一个标志，而且这个标志也仅仅是针对 Object类中 clone()方法的，如果 clone 类没有实现 Cloneable 接口，并调用了 Object 的 clone() 方法（也就是调用了 super.Clone() 方法），那么Object 的 clone() 方法就会抛出 CloneNotSupportedException 异常。 什么是浅复制和深复制：我们知道了复制的本质是克隆，那什么是浅复制和深复制呢？我们来举个例子。 12345678910111213141516171819202122232425262728293031323334public class User implements Cloneable&#123; private String name; private Place place; public User(String name, Place place)&#123; this.name=name; this.place=place; &#125; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public Place getPlace() &#123; return place; &#125; public void setPlace(Place place) &#123; this.place = place; &#125; @Override public User clone()&#123; try &#123; return (User)super.clone(); &#125; catch (CloneNotSupportedException e) &#123; e.printStackTrace(); &#125; return null; &#125;;&#125; 我们来运行测试一下。 12345678910public class Test &#123; public static void main(String[] args) &#123; Place place=new Place(); place.setPname("地方"); User user=new User("test", place); User user1=user.clone(); user1.getPlace().setPname("地方1"); System.out.println(user.getPlace().getPname()); &#125;&#125; 我们的user，进行了克隆生成了user1，修改user1中Place对象中的pname属性。正常情况下，user中Place对象中的pname属性是不应该改变的，但是我们看一下运行结果却也改变了，变成了”地方”。这就是浅复制，object.clone()的方法其实就是浅复制，user对象本身确实是克隆出来的，但是里面的对象place对象还是之前的对象，并没有新建，所以就会出现这种情况。 其实重写clone()方法的时候，不一定只允许super.clone()。官网说，重写后的clone方法 X.clone()!=X;复制的对象不能与之前的对象相等。 X.clone().getClass()==X.getClass() 复制的对象必须和之前的对象类型相同。 我们要考虑到浅复制给我们带来的风险是什么，如果有风险，我们要不替换方案，要不使用深复制，如何使用深复制呢？ 现在我有两个办法： 1、用序列化的方式，将对象序列化再反序列化，返回之后是深度复制 2、第二种用jackson将类转成josn格式，再转回来也可以进行深度复制。]]></content>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
</search>
