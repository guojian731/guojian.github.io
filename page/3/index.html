<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/guojian731.github.io/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/guojian731.github.io/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/guojian731.github.io/css/main.css?v=5.1.3" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/guojian731.github.io/images/apple-touch-icon.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="32x32" href="/guojian731.github.io/images/favicon-32x32.png?v=5.1.3">


  <link rel="icon" type="image/png" sizes="16x16" href="/guojian731.github.io/images/favicon-16x16.png?v=5.1.3">


  <link rel="mask-icon" href="/guojian731.github.io/images/logo.svg?v=5.1.3" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta property="og:type" content="website">
<meta property="og:title" content="Notes">
<meta property="og:url" content="https://guojian731.github.io/guojian731.github.io/page/3/index.html">
<meta property="og:site_name" content="Notes">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Notes">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/guojian731.github.io/',
    scheme: 'Gemini',
    version: '5.1.3',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://guojian731.github.io/guojian731.github.io/page/3/"/>





  <title>Notes</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/guojian731.github.io/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Notes</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/guojian731.github.io/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/guojian731.github.io/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/guojian731.github.io/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/guojian731.github.io/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojian731.github.io/guojian731.github.io/guojian731.github.io/2017/12/26/java多线程-线程状态/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Guo Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/guojian731.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/guojian731.github.io/2017/12/26/java多线程-线程状态/" itemprop="url">java多线程-线程状态</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-26T19:25:46+08:00">
                2017-12-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojian731.github.io/guojian731.github.io/guojian731.github.io/2017/12/19/java基础-AIO、BIO、NIO/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Guo Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/guojian731.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/guojian731.github.io/2017/12/19/java基础-AIO、BIO、NIO/" itemprop="url">java基础-AIO、BIO、NIO</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-19T20:32:21+08:00">
                2017-12-19
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="基础概念"><a href="#基础概念" class="headerlink" title="基础概念"></a>基础概念</h1><h2 id="同步与异步"><a href="#同步与异步" class="headerlink" title="同步与异步"></a>同步与异步</h2><p><strong>同步（Synchronous）和异步（Asynchronous）通常用来形容一次方法的调用。同步方法一旦调用，调用者必须等到方法调用返回后，才能进行后续的操作。就像我们普通的java程序一样，在一个线程内有顺序的方法A，B，C。程序在A执行完返回后才能执行B，B执行完返回后才能执行C；而异步是更像是消息传递，当线程调用A的时候，就会立即返回，不会等A执行过，调用者就会进行后续的操作。而A方法会在另一个线程下继续工作。整个过程不影响调用者的工作，对于调用者来说，调用方法A()相当于一瞬间完成的。如果A方法完成并且有结果的时候，后通知调用者。我们经常用到的ajax默认就是异步的呢，我曾经遇到过这种情况，在一个function下，创建一个变量var ss=””,然后调用ajax向后台进行业务逻辑，返回ss的值。然后function下在对ss进行操作，但是发生了一种情况，在debug时，发现ss已经在后台赋予了非空的值，但是接收的时候ss还是为空，那就是因为ajax是异步实现的方式，使用了另一个线程在运行线程，而function还会往下进行，这时候ajax还没有返回值，ss依旧是空。</strong></p>
<h2 id="阻塞和非阻塞"><a href="#阻塞和非阻塞" class="headerlink" title="阻塞和非阻塞"></a>阻塞和非阻塞</h2><p><strong>阻塞（Blocking）和非阻塞（Non-Blocking）通常用来多线程的相互影响，比如一个线程占用了临界区资源，那个其他所有需要这个资源的线程就必须在这个临界区中进行等待。等待会导致线程的挂起，这种情况就是阻塞。此时，如果占用资源的线程一直不愿意释放资源，那么其他所有阻塞在这个临界区上的线程都不能工作。非阻塞的意思与之相反，它强调没有一个线程可以妨碍其他线程执行，所有的线程都会尝试不断向前执行。</strong></p>
<h1 id="IO比较"><a href="#IO比较" class="headerlink" title="IO比较"></a>IO比较</h1><p><strong>IO操作分为两种，一种是文件IO，另一种是网络IO；那么从网络IO中进行比较，这篇文章是看《实战Java高并发程序设计》中作为启蒙，很推荐这本书，也非常感谢。</strong></p>
<h2 id="BIO"><a href="#BIO" class="headerlink" title="BIO"></a>BIO</h2><p>BIO就是使用IO包进行操作，它的意思是”Blocking-IO”,也就是（同步）阻塞IO。服务端在接收信息时，需要等客户端执行过后才能进行下面的操作，如果客户端存在网络延迟，那么服务器端就会一直等待。<br>网络IO分为服务器端和客户端进行通讯，一般情况下，服务器端一直运行等待客服端的连接，而服务器端是创建一个连接，处理完成够客户端就进行关闭。在java中，服务器端使用ServerSocket，而客户端使用Socket，它们都在java.net包下。在下面的介绍中，如果我说的是socket那么代表的就是客户端，如果是服务器端，我会进行特殊说明。</p>
<h3 id="BIO-Server"><a href="#BIO-Server" class="headerlink" title="BIO Server"></a>BIO Server</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.ServerSocket;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MultiThreadEchoServer</span> </span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">//创建一个线程池</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService tp= Executors.newCachedThreadPool();</span><br><span class="line">	</span><br><span class="line">	</span><br><span class="line">    <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span>  <span class="title">HandleMsg</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        Socket clientSocket;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HandleMsg</span><span class="params">(Socket clientSocket)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.clientSocket=clientSocket;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            BufferedReader is=<span class="keyword">null</span>;</span><br><span class="line">            PrintWriter os=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                is =<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(clientSocket.getInputStream()));</span><br><span class="line">                os=<span class="keyword">new</span> PrintWriter(clientSocket.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">                <span class="comment">//从InputStream当中读取客户端所发送的数据</span></span><br><span class="line">                String inputLine=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">long</span> b=System.currentTimeMillis();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span> ((inputLine=is.readLine())!=<span class="keyword">null</span>)&#123;</span><br><span class="line">                    System.out.println(<span class="string">"服务器进来了"</span>);</span><br><span class="line">                    os.println(inputLine);</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> e=System.currentTimeMillis();</span><br><span class="line">                System.out.println(<span class="string">"spend:"</span>+(e-b)+<span class="string">"ms"</span>);</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (is!=<span class="keyword">null</span>) is.close();</span><br><span class="line"></span><br><span class="line">                        <span class="keyword">if</span> (os!=<span class="keyword">null</span>) os.close();</span><br><span class="line"></span><br><span class="line">                        clientSocket.close();</span><br><span class="line"></span><br><span class="line">                    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        ServerSocket echoServer=<span class="keyword">null</span>;</span><br><span class="line">        Socket clientSocket=<span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            echoServer=<span class="keyword">new</span> ServerSocket(<span class="number">8000</span>);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                clientSocket=echoServer.accept();</span><br><span class="line">                System.out.println(clientSocket.getRemoteSocketAddress()+<span class="string">"connect!"</span>);</span><br><span class="line">                tp.execute(<span class="keyword">new</span> HandleMsg(clientSocket));</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们开始从main函数开始讲解。<br>在main()函数我们先建立ServerSocket并设置端口号8000和客户端socket，客户端的socket需要从echoServer.accept()中获取，这个方法是阻塞的，如果这里没有连接进行连接，那么就会一直被阻塞，主线程会一直运行，并且你在控制台永远看不到输出的”connect”。当有客户端进行连接并成功后，那么就会输出客户端的地址连接。<br>我们使用线程池来处理客户端每一个连接，这样的好处就是服务器端支持多线程，在相同的可支持的的线程范围内，可以尽量多的支持客户端的数量。我们定义的是HandleMsg线程，它的构造器要求它传入一个客户端socket，它的任务是读取socket的内容并将其返回，任务成功后，客户端的socket就会正常关闭。在HandleMsg中，我们记录了服务器线程处理客户端一次请求所使用的时间。<br>在HandleMsg的run()方法中，我们设计是从客户端获取数据并且向客户端返回数据，在输入流和输出流都指向客户端，所以我们在输入流和输出流定义时，要赋值客户端的socket。</p>
<h3 id="BIO-简单的客户端"><a href="#BIO-简单的客户端" class="headerlink" title="BIO 简单的客户端"></a>BIO 简单的客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * io客户端 同步阻塞</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">IOSocketClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException</span>&#123;</span><br><span class="line"></span><br><span class="line">        Socket client=<span class="keyword">null</span>;</span><br><span class="line">        PrintWriter writer=<span class="keyword">null</span>;</span><br><span class="line">        BufferedReader reader=<span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            client=<span class="keyword">new</span> Socket();</span><br><span class="line">            client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8000</span>));</span><br><span class="line">            writer=<span class="keyword">new</span> PrintWriter(client.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">            writer.println(<span class="string">"hello"</span>);</span><br><span class="line">            writer.flush();</span><br><span class="line"></span><br><span class="line">            reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">            System.out.println(<span class="string">"from server "</span> +reader.readLine());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">             <span class="keyword">try</span> &#123;</span><br><span class="line">                 <span class="keyword">if</span> (client!=<span class="keyword">null</span>) client.close();</span><br><span class="line">                 <span class="keyword">if</span> (writer!=<span class="keyword">null</span>) writer.close();</span><br><span class="line">                 <span class="keyword">if</span> (reader!=<span class="keyword">null</span>) reader.close();</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们测试一下我们的服务端是否能够正常启动，运行main()函数，查看一下运行结果，发现的确一直在阻塞状态。</p>
<p><img src="/guojian731.github.io/2017/12/19/java基础-AIO、BIO、NIO/io1.png" alt="你想输入的替代文字"></p>
<p>启动客户端。</p>
<p><img src="/guojian731.github.io/2017/12/19/java基础-AIO、BIO、NIO/io2.png" alt="你想输入的替代文字"></p>
<p>查看服务器端控制台。</p>
<p><img src="/guojian731.github.io/2017/12/19/java基础-AIO、BIO、NIO/io3.png" alt="你想输入的替代文字"></p>
<h3 id="BIOClient-存在网络延迟"><a href="#BIOClient-存在网络延迟" class="headerlink" title="BIOClient 存在网络延迟"></a>BIOClient 存在网络延迟</h3><p>前面的例子，发现速度很快完成了客服端和服务器端的交互，但是会出现一种情况，就是客户端存在网络延迟，那么客户端运行了多长时间，那么服务器端就会在处理这个线程的时候被阻塞多长时间。我们在测试的时候，会用到Thread.sleep()来模拟网络延迟，我们看一下效果。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.*;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.Socket;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executor;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutorService;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Executors;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * 客户端存在网络延迟</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HeavySocketClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> ExecutorService tp= Executors.newCachedThreadPool();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">final</span> <span class="keyword">static</span>  <span class="keyword">int</span> sleep_time=<span class="number">1000</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span>  <span class="keyword">static</span>  <span class="class"><span class="keyword">class</span> <span class="title">EchoClient</span> <span class="keyword">implements</span> <span class="title">Runnable</span></span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">synchronized</span> (<span class="keyword">this</span>)&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            Socket client=<span class="keyword">null</span>;</span><br><span class="line">            PrintWriter writer=<span class="keyword">null</span>;</span><br><span class="line">            BufferedReader reader=<span class="keyword">null</span>;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                client=<span class="keyword">new</span> Socket();</span><br><span class="line">                client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8000</span>));</span><br><span class="line">                writer=<span class="keyword">new</span> PrintWriter(client.getOutputStream(),<span class="keyword">true</span>);</span><br><span class="line">                writer.print(<span class="string">"h"</span>);</span><br><span class="line">                Thread.sleep(sleep_time);</span><br><span class="line">                writer.print(<span class="string">"e"</span>);</span><br><span class="line">                Thread.sleep(sleep_time);</span><br><span class="line">                writer.print(<span class="string">"l"</span>);</span><br><span class="line">                Thread.sleep(sleep_time);</span><br><span class="line">                writer.print(<span class="string">"l"</span>);</span><br><span class="line">                Thread.sleep(sleep_time);</span><br><span class="line">                writer.print(<span class="string">"o"</span>);</span><br><span class="line">                Thread.sleep(sleep_time);</span><br><span class="line">                writer.println();</span><br><span class="line">                writer.flush();</span><br><span class="line">                reader=<span class="keyword">new</span> BufferedReader(<span class="keyword">new</span> InputStreamReader(client.getInputStream()));</span><br><span class="line">                System.out.println(<span class="string">"form server : "</span>+reader.readLine());</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    <span class="keyword">if</span> (writer!=<span class="keyword">null</span>) writer.close();</span><br><span class="line">                    <span class="keyword">if</span> (reader!=<span class="keyword">null</span>) reader.close();</span><br><span class="line">                    <span class="keyword">if</span> (client!=<span class="keyword">null</span>) client.close();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        EchoClient echoClient=<span class="keyword">new</span> EchoClient();</span><br><span class="line">        <span class="comment">//for (int i=0;i&lt;=5;i++) &#123;</span></span><br><span class="line">            tp.execute(echoClient);</span><br><span class="line">        <span class="comment">//&#125;</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/guojian731.github.io/2017/12/19/java基础-AIO、BIO、NIO/io4.png" alt="你想输入的替代文字"></p>
<p>可以看到,服务器端耗费了比较长的时间。因为服务器要先读入客户端的输入，而客户端缓慢的处理速度使的服务器花费了更多的时间。在这个案例中，我们可以将main函数的for循环打开，就会有产生五个线程。但是我们有100线程同时请求，假设我们线程池里面只有10个线程可供使用，那么其他的90个就会等待线程池里的线程里可以使用的线程，那么这样服务器因为客户端的缓慢势必会影响到并发。<br>在这个案例中，服务器请求缓慢不是因为服务器端有多少繁重的任务，而是因为服务器线程在等待IO。 让告诉运转的CPU去等待效率低下的网络IO是极其不合算的。我们如何使用一种方式，使网络IO的等待时间从线程中分离出来。</p>
<h2 id="NIO"><a href="#NIO" class="headerlink" title="NIO"></a>NIO</h2><p>上述的问题，使用NIO就可以将网络IO的等待时间从线程中分离出来。<br>NIO中一个关键组件是channel()，他的意思是管道。channel类似于流，一个channel可以跟一个文件或者网络Socket对应。如果一个channel对应一个文件和网络Socket，那么往这个channel中写数据，就相当于往Socket中写数据。<br>和channel结合使用的是另一个组件Buffer，Buffer相当于一个内存区域或者byte数组。数据需要包装成Buffer形式才能与channel进行交互(写入或者读取)。<br>另外一个与channel组件相关的是Selector(选择器)。在channel的众多实现中，有一个SelectableChannel的实现，表示可以被选择的通道。任何一个SelectableChannel都可以注册到一个selector中。这样，这个channel就会被selector管理。而一个selector可以管理多个channel。当SelectableChannel的数据准备好之后，Selector就会接到通知，得到那些已经准备好的数据。而SocketChannel就是SelectableChannel的一种。</p>
<p><img src="/guojian731.github.io/2017/12/19/java基础-AIO、BIO、NIO/io5.png" alt="你想输入的替代文字"></p>
<p>我们创建一个线程Selector来管理channel，而一个SocketChannel代表一个客户端的连接，因此是selector处理多个客户端连接，当客户端的数据没有准备好的时候，selector处于准备状态，一旦有任何一个SocketChannel准备好数据之后，Selector就能立即得到通知，获取数据进行处理。</p>
<h3 id="NIO-Server"><a href="#NIO-Server" class="headerlink" title="NIO Server"></a>NIO Server</h3><p>package io;</p>
<p>import java.io.IOException;<br>import java.net.InetAddress;<br>import java.net.InetSocketAddress;<br>import java.net.Socket;<br>import java.nio.ByteBuffer;<br>import java.nio.channels.SelectionKey;<br>import java.nio.channels.Selector;<br>import java.nio.channels.ServerSocketChannel;<br>import java.nio.channels.SocketChannel;<br>import java.nio.channels.spi.SelectorProvider;<br>import java.util.*;<br>import java.util.concurrent.ExecutorService;<br>import java.util.concurrent.Executors;</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line">    <span class="keyword">private</span> ExecutorService tp= Executors.newCachedThreadPool();</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Socket,Long&gt; time_stat=<span class="keyword">new</span> HashMap&lt;Socket, Long&gt;(<span class="number">10240</span>);</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">startServer</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">//通过工厂创建一个selector</span></span><br><span class="line">	selector= SelectorProvider.provider().openSelector();</span><br><span class="line">            </span><br><span class="line">	<span class="comment">//获得一个服务器端channel的实例</span></span><br><span class="line">	ServerSocketChannel scc=ServerSocketChannel.open();</span><br><span class="line">            </span><br><span class="line">	<span class="comment">//将服务器端设置为非阻塞模式</span></span><br><span class="line">	scc.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">    </span><br><span class="line">	InetSocketAddress isa=<span class="keyword">new</span> InetSocketAddress(<span class="number">8000</span>);</span><br><span class="line">			</span><br><span class="line">	<span class="comment">//为服务器channel绑定地址和端口号</span></span><br><span class="line">	scc.socket().bind(isa);</span><br><span class="line"></span><br><span class="line">	<span class="comment">//注释1 将服务器channel绑定到selector上，并且将selector感兴趣的事件记录为"accept"</span></span><br><span class="line">	SelectionKey acceptkey=scc.register(selector,SelectionKey.OP_ACCEPT);</span><br><span class="line">			</span><br><span class="line">	<span class="comment">//for循环，它的任务就是等待-分发网络消息</span></span><br><span class="line">            <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		*select()方法是一个阻塞的方法，当没有任何数据准备的时候，他就会等待。</span></span><br><span class="line"><span class="comment">		*一旦有数据，他就会立即返回。他的返回值是已经准备就绪的selectionKey。</span></span><br><span class="line"><span class="comment">		**/</span></span><br><span class="line">                selector.select();</span><br><span class="line">		</span><br><span class="line">		<span class="comment">/**</span></span><br><span class="line"><span class="comment">		*获取准备好的selectionKey，因为Selector为多个Channel服务，所以</span></span><br><span class="line"><span class="comment">		*已经就绪的Channel可能是多个，所以是一个集合。</span></span><br><span class="line"><span class="comment">		**/</span>		</span><br><span class="line">                Set readyKeys = selector.selectedKeys();</span><br><span class="line">                Iterator i = readyKeys.iterator();</span><br><span class="line"></span><br><span class="line">                <span class="keyword">long</span> e=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">while</span>(i.hasNext())&#123;</span><br><span class="line"></span><br><span class="line">					SelectionKey sk= (SelectionKey) i.next();</span><br><span class="line">					</span><br><span class="line">					<span class="comment">//将SelectionKey移除，如果不移除，就会重复处理相同的SelectionKey</span></span><br><span class="line">					i.remove();</span><br><span class="line">		</span><br><span class="line">					<span class="comment">//判断selectionKey的状态是否是可接收状态，如果是，就执行doAccept()方法。</span></span><br><span class="line">                    <span class="keyword">if</span> (sk.isAcceptable())&#123;</span><br><span class="line">                        doAccept(sk);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sk.isValid()  &amp;&amp; sk.isReadable())&#123;</span><br><span class="line">                        <span class="keyword">if</span> (!time_stat.containsKey( ((SocketChannel)sk.channel()).socket()))&#123;</span><br><span class="line">                            time_stat.put(((SocketChannel)sk.channel()).socket(),System.currentTimeMillis());</span><br><span class="line">                        &#125;</span><br><span class="line">                        doRead(sk);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span> <span class="keyword">if</span>(sk.isValid() &amp;&amp; sk.isWritable())&#123;</span><br><span class="line">                        doWrite(sk);</span><br><span class="line">                        e=System.currentTimeMillis();</span><br><span class="line">                        <span class="keyword">long</span> b=time_stat.remove(((SocketChannel)sk.channel()).socket());</span><br><span class="line">                        System.out.println(<span class="string">"spend="</span>+(e-b)+<span class="string">"ms"</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doRead</span><span class="params">(SelectionKey sk)</span> </span>&#123;</span><br><span class="line">         SocketChannel channel=(SocketChannel) sk.channel();</span><br><span class="line">         ByteBuffer bb=ByteBuffer.allocate(<span class="number">8192</span>);</span><br><span class="line">         <span class="keyword">int</span> len;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            len =channel.read(bb);</span><br><span class="line">            <span class="keyword">if</span> (len&lt;<span class="number">0</span>) &#123;</span><br><span class="line">                disconnect(sk);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Failed to read form client !!"</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            disconnect(sk);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        bb.flip();</span><br><span class="line">        tp.execute(<span class="keyword">new</span> HandleMsg(sk,bb));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">disconnect</span><span class="params">(SelectionKey sk)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doWrite</span><span class="params">(SelectionKey sk)</span> </span>&#123;</span><br><span class="line">        SocketChannel channel= (SocketChannel) sk.channel();</span><br><span class="line">        EchoClient echoClient= (EchoClient) sk.attachment();</span><br><span class="line">        LinkedList&lt;ByteBuffer&gt; outq=echoClient.getOutputQueue();</span><br><span class="line"></span><br><span class="line">        ByteBuffer bb= outq.getLast();</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">int</span> len=channel.write(bb);</span><br><span class="line">            <span class="keyword">if</span> (len == -<span class="number">1</span>)&#123;</span><br><span class="line">                disconnect(sk);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (bb.remaining()==<span class="number">0</span>)&#123;</span><br><span class="line">                outq.removeLast();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"Failed to write client."</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">            disconnect(sk);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (outq.size()==<span class="number">0</span>)&#123;</span><br><span class="line">            sk.interestOps(SelectionKey.OP_READ);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">doAccept</span><span class="params">(SelectionKey sk)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//System.out.println("doAccept");</span></span><br><span class="line">		</span><br><span class="line">        ServerSocketChannel server=(ServerSocketChannel) sk.channel();</span><br><span class="line">        SocketChannel clientChannel;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">			<span class="comment">//根据ServerSocketChannel获取clientChannel	</span></span><br><span class="line">            clientChannel= server.accept();</span><br><span class="line">            clientChannel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            SelectionKey clientKey=clientChannel.register(selector,SelectionKey.OP_READ);</span><br><span class="line">            EchoClient echoClient=<span class="keyword">new</span> EchoClient();</span><br><span class="line">            clientKey.attach(echoClient);</span><br><span class="line">            InetAddress clientAddress=clientChannel.socket().getInetAddress();</span><br><span class="line">            System.out.println(<span class="string">"Accepted connection from  "</span>+clientAddress.getHostAddress());</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            System.out.println(<span class="string">"fail to accept new client."</span>);</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">HandleMsg</span> <span class="keyword">implements</span>  <span class="title">Runnable</span></span>&#123;</span><br><span class="line">        SelectionKey sk;</span><br><span class="line">        ByteBuffer bb;</span><br><span class="line"></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="title">HandleMsg</span><span class="params">(SelectionKey sk,ByteBuffer bb)</span></span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.sk=sk;</span><br><span class="line">            <span class="keyword">this</span>.bb=bb;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            EchoClient  echoClient= (EchoClient) sk.attachment();</span><br><span class="line">            echoClient.enqueue(bb);</span><br><span class="line">            sk.interestOps(SelectionKey.OP_READ | SelectionKey.OP_WRITE);</span><br><span class="line">            selector.wakeup();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioServer nioServer=<span class="keyword">new</span> NioServer();</span><br><span class="line">        nioServer.startServer();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>我们先创建一个选择器Selector和连接池。连接池是为客户端建立线程，每一个请求都会委托线程池中的线程来进行实际的处理。<br>为了能够统计一个线程在服务器中所话费的时间，我们定义了与时间有关的类：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> Map&lt;Socket,Long&gt; time_stat=<span class="keyword">new</span> HashMap&lt;Socket, Long&gt;(<span class="number">10240</span>);</span><br></pre></td></tr></table></figure>
<p>他是一个hashMap，key是一个socket，value是代表服务器端处理该请求处理的时间。</p>
<p><strong>注释1：因为我们设置selector感兴趣的事件为SelectionKey.OP_ACCEPT，那么只要当客户端进行连接时，就会通知ServerSocketChannel进行处理。register()的返回值是一个SelectionKey，SelectionKey代表这selector和channel的一种关系。当channel注册到selector上时，就已经确立了两者的服务关系。那么selector就是这个契约，如果selector或者channel被关闭时，他们对应的selectionKey就会失效。</strong></p>
<h3 id="NIO-Client"><a href="#NIO-Client" class="headerlink" title="NIO Client"></a>NIO Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.net.SocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SelectionKey;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.Selector;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.SocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.spi.SelectorProvider;</span><br><span class="line"><span class="keyword">import</span> java.util.Iterator;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">NioClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> Selector selector;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">init</span> <span class="params">(String ip,<span class="keyword">int</span> port)</span></span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">            SocketChannel channel=SocketChannel.open();</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            <span class="keyword">this</span>.selector= SelectorProvider.provider().openSelector();</span><br><span class="line">            channel.connect(<span class="keyword">new</span> InetSocketAddress(ip, port));</span><br><span class="line">            channel.register(selector, SelectionKey.OP_CONNECT);</span><br><span class="line"></span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">working</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line"></span><br><span class="line">            <span class="keyword">if</span> (!selector.isOpen())&#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                selector.select();</span><br><span class="line">                Iterator&lt;SelectionKey&gt; iterator= <span class="keyword">this</span>.selector.selectedKeys().iterator();</span><br><span class="line">                <span class="keyword">while</span> (iterator.hasNext())&#123;</span><br><span class="line">                    SelectionKey key=iterator.next();</span><br><span class="line">                    iterator.remove();</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">if</span> (key.isConnectable())&#123;</span><br><span class="line">                        connect(key);</span><br><span class="line">                    &#125;<span class="keyword">else</span> <span class="keyword">if</span>(key.isReadable())&#123;</span><br><span class="line">                        read(key);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                e.printStackTrace();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">read</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SocketChannel channel= (SocketChannel) key.channel();</span><br><span class="line">            ByteBuffer buffer=ByteBuffer.allocate(<span class="number">100</span>);</span><br><span class="line">            channel.read(buffer);</span><br><span class="line">            <span class="keyword">byte</span>[] data=buffer.array();</span><br><span class="line">            String msg=<span class="keyword">new</span> String(data).trim();</span><br><span class="line">            System.out.println(<span class="string">"客户端收到消息"</span>+msg);</span><br><span class="line">            channel.close();</span><br><span class="line">            key.selector().close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">private</span> <span class="keyword">void</span> <span class="title">connect</span><span class="params">(SelectionKey key)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        SocketChannel channel= (SocketChannel) key.channel();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (channel.isConnectionPending())&#123;</span><br><span class="line">                channel.finishConnect();</span><br><span class="line">            &#125;</span><br><span class="line">            Thread.sleep(<span class="number">10000</span>);</span><br><span class="line">            channel.configureBlocking(<span class="keyword">false</span>);</span><br><span class="line">            channel.write(ByteBuffer.wrap(<span class="keyword">new</span> String(<span class="string">"hello server!\r\n"</span>).getBytes()));</span><br><span class="line">            channel.register(<span class="keyword">this</span>.selector,SelectionKey.OP_READ);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;<span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        NioClient client=<span class="keyword">new</span> NioClient();</span><br><span class="line">        client.init(<span class="string">"localhost"</span> ,<span class="number">8000</span>);</span><br><span class="line">        client.working();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="AIO"><a href="#AIO" class="headerlink" title="AIO"></a>AIO</h2><p><strong>AIO中的”A”代表这ASynchronized，就是异步的意思，我们在用AIO的时候，解决了阻塞的问题，但是NIO中的IO操作还是同步的。对于NIO来说，我们的业务线程是在IO操作准备好的时候，得到通知，接着由这个线程自行进行IO操作，IO操作本身依旧是同步的。<br>对于AIO来说，则更近一步，他不是在IO准备好时通知线程，而是在IO操作已经完成后通知线程。因此，AIO是完全不阻塞的。此时，我们的业务逻辑变成了一个回调函数，等待IO操作结束后系统自动触发。</strong></p>
<h3 id="AIO-Server"><a href="#AIO-Server" class="headerlink" title="AIO Server"></a>AIO Server</h3><p>异步的IO使用异步通道ASynchronousServerSocketChannel。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> &lt;A&gt; <span class="function"><span class="keyword">void</span> <span class="title">accept</span><span class="params">(A attachment,</span></span></span><br><span class="line"><span class="function"><span class="params">                                   CompletionHandler&lt;AsynchronousSocketChannel,? <span class="keyword">super</span> A&gt; handler)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Invoked when an operation has completed.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   result</span></span><br><span class="line"><span class="comment">    *          The result of the I/O operation.</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   attachment</span></span><br><span class="line"><span class="comment">    *          The object attached to the I/O operation when it was initiated.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">completed</span><span class="params">(V result, A attachment)</span></span>;</span><br><span class="line"></span><br><span class="line">   <span class="comment">/**</span></span><br><span class="line"><span class="comment">    * Invoked when an operation fails.</span></span><br><span class="line"><span class="comment">    *</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   exc</span></span><br><span class="line"><span class="comment">    *          The exception to indicate why the I/O operation failed</span></span><br><span class="line"><span class="comment">    * <span class="doctag">@param</span>   attachment</span></span><br><span class="line"><span class="comment">    *          The object attached to the I/O operation when it was initiated.</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">   <span class="function"><span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, A attachment)</span></span>;</span><br></pre></td></tr></table></figure>
<p>ASynchronousServerSocketChannel.accept()方法会立即返回，它并不会真正的等待客户端的到来。它的第一个参数是一个附件，可以是任意一个类型，作用是让当前线程和后续的回调方法共享信息。他会在后续的调用用，传递给handler。第二个参数是CompletionHandler接口，我们需要实现他的两个方法completed和failed，completed是连接成功后执行的方法，failed是连接失败的时候执行的方法。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousServerSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.ExecutionException;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.Future;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeUnit;</span><br><span class="line"><span class="keyword">import</span> java.util.concurrent.TimeoutException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioServer</span> </span>&#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">final</span>  Integer port=<span class="number">8000</span>;</span><br><span class="line">    <span class="keyword">private</span> AsynchronousServerSocketChannel server;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="title">AioServer</span><span class="params">()</span> <span class="keyword">throws</span>  IOException</span>&#123;</span><br><span class="line">        server =AsynchronousServerSocketChannel.open().bind(<span class="keyword">new</span> InetSocketAddress(port));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">start</span><span class="params">()</span></span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"server listen on  "</span>+port);</span><br><span class="line">        server.accept(<span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;AsynchronousSocketChannel, Object&gt;() &#123;</span><br><span class="line">            <span class="keyword">final</span> ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(AsynchronousSocketChannel result, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(Thread.currentThread().getName());</span><br><span class="line">                Future&lt;Integer&gt; writeResult=<span class="keyword">null</span>;</span><br><span class="line">                <span class="keyword">try</span> &#123;</span><br><span class="line">                    buffer.clear();</span><br><span class="line">                    result.read(buffer).get(<span class="number">100</span>, TimeUnit.SECONDS);</span><br><span class="line">                    buffer.flip();</span><br><span class="line">                    writeResult=result.write(buffer);</span><br><span class="line">                &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125; <span class="keyword">catch</span> (TimeoutException e) &#123;</span><br><span class="line">                    e.printStackTrace();</span><br><span class="line">                &#125;<span class="keyword">finally</span> &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">try</span> &#123;</span><br><span class="line">                        server.accept(<span class="keyword">null</span>,<span class="keyword">this</span>);</span><br><span class="line">                        writeResult.get();</span><br><span class="line">                        result.close();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125; <span class="keyword">catch</span> (ExecutionException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;<span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                        e.printStackTrace();</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line">                System.out.println(<span class="string">"failed :"</span>+exc);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> InterruptedException, IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AioServer().start();</span><br><span class="line">        <span class="keyword">while</span> (<span class="keyword">true</span>)&#123;</span><br><span class="line">            Thread.sleep(<span class="number">1000</span>);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="AIO-Client"><a href="#AIO-Client" class="headerlink" title="AIO Client"></a>AIO Client</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> io;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"><span class="keyword">import</span> java.net.InetSocketAddress;</span><br><span class="line"><span class="keyword">import</span> java.nio.ByteBuffer;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.AsynchronousSocketChannel;</span><br><span class="line"><span class="keyword">import</span> java.nio.channels.CompletionHandler;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">AioClient</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> <span class="keyword">throws</span> IOException, InterruptedException </span>&#123;</span><br><span class="line">        <span class="keyword">final</span> AsynchronousSocketChannel client=AsynchronousSocketChannel.open();</span><br><span class="line">        client.connect(<span class="keyword">new</span> InetSocketAddress(<span class="string">"localhost"</span>,<span class="number">8000</span>), <span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;Void, Object&gt;() &#123;</span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Void result, Object attachment)</span> </span>&#123;</span><br><span class="line">                client.write(ByteBuffer.wrap(<span class="string">"hello"</span>.getBytes()), <span class="keyword">null</span>, <span class="keyword">new</span> CompletionHandler&lt;Integer, Object&gt;() &#123;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, Object attachment)</span> </span>&#123;</span><br><span class="line">                        <span class="keyword">final</span> ByteBuffer buffer=ByteBuffer.allocate(<span class="number">1024</span>);</span><br><span class="line">                        client.read(buffer, buffer, <span class="keyword">new</span> CompletionHandler&lt;Integer, ByteBuffer&gt;() &#123;</span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">completed</span><span class="params">(Integer result, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line">                                System.out.println(<span class="string">"jinlailema"</span>);</span><br><span class="line">                                buffer.flip();</span><br><span class="line">                                System.out.println(<span class="keyword">new</span> String(buffer.array()));</span><br><span class="line"></span><br><span class="line">                                <span class="keyword">try</span> &#123;</span><br><span class="line">                                    client.close();</span><br><span class="line">                                &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">                                    e.printStackTrace();</span><br><span class="line">                                &#125;</span><br><span class="line">                            &#125;</span><br><span class="line"></span><br><span class="line">                            <span class="meta">@Override</span></span><br><span class="line">                            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, ByteBuffer attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;);</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    <span class="meta">@Override</span></span><br><span class="line">                    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;);</span><br><span class="line">            &#125;</span><br><span class="line"></span><br><span class="line">            <span class="meta">@Override</span></span><br><span class="line">            <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">failed</span><span class="params">(Throwable exc, Object attachment)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">        &#125;);</span><br><span class="line">        Thread.sleep(<span class="number">1000</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h1 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h1><p>BIO:BIO服务器端有一个连接，那么我们就要在服务器端建立一个线程来处理，进行一对一的处理。需要等待客户端的准备过程，对服务器的资源占用是很明显的，是一个连接一个线程。<br>NIO:NIO是使用一个selector选择器来进行轮询，当发现请求的时候，selector才会启动一个线程进行处理。属于一个请求一个线程，所以很适合高并发的场景。但是，当你接收之后，可能会写入数据库的操作，也就是请求应用的资源，但是现在数据库内的连接都是满的，那就需要一直等待连接池内的等待。是一个请求一个线程。<br>AIO：AIO的出现就解决了NIO应用资源占用的这个问题，通过调用操作系统以及并发操作解决这类问题。属于一个有效的请求一个线程。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>再看完这些之后，可能会对同步异步、阻塞非阻塞还有一些疑问，在学习的期间我也很困惑，常常纠结了很久，但是总会有柳暗花明的一天，我想通了期间的差别，它可能是错误的，但是即使是错误的，也是我这段时间学习的结晶。</p>
<p>BIO操作，当客户端与服务器端进行连接的时候，服务器端accept()就会阻塞，这时候服务器端在准备数据(写hello)，这段客服端准备数据的时候，服务器端就会被阻塞；这就像一个或者很多集装箱一样，他负责传输货物的，但是BIO相当于把货物的开膛、清洗、消毒、冷冻、传输等所有的操作都在集装箱进行，就会占用一个集装箱很长时间，如果集装箱满了，其他的货物就进不来；NIO呢，就是货物的开膛、清洗、消毒、冷冻这样的事不应该放在集装箱上进行，我这是负责传输的，你的这些操作应该事先准备好后，然后给我进行传输。那么BIO呢，我们接收到了数据之后，我们还要处理数据（读写操作），我们的读操作和写操作也会耗费一些时间，因为单线程是同步的么。如果货物到了集装箱，我们还要对货物进行检验，重量是否对应，检测是否有流感；我们在进行这些操作的时候，那么火车就不能开动。AIO就是相当于让集装箱开动了，并抽出两个人在同时做货物的检验。</p>
<p>最后在说一下，对于服务器端来说，阻塞非阻塞是相对与客户端来说，而同步异步是从客户端接收完数据之后，自己对数据的操作而言的。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojian731.github.io/guojian731.github.io/guojian731.github.io/2017/12/13/Spring-全注解项目构建/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Guo Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/guojian731.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/guojian731.github.io/2017/12/13/Spring-全注解项目构建/" itemprop="url">Spring-全注解项目构建</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-13T18:43:17+08:00">
                2017-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>首先将包依赖导入。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span> <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">  <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/maven-v4_0_0.xsd"</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.test<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>test3<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">packaging</span>&gt;</span>war<span class="tag">&lt;/<span class="name">packaging</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">name</span>&gt;</span>test3 Maven Webapp<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://maven.apache.org<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line"></span><br><span class="line">  <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">maven.build.timestamp.format</span>&gt;</span>yyyyMMddHHmmss<span class="tag">&lt;/<span class="name">maven.build.timestamp.format</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">spring.version</span>&gt;</span>3.2.9.RELEASE<span class="tag">&lt;/<span class="name">spring.version</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="comment">&lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-webmvc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>javax.servlet<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>javax.servlet-api<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.0.0-b07<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">      <span class="tag">&lt;<span class="name">scope</span>&gt;</span>provided<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">finalName</span>&gt;</span>test3<span class="tag">&lt;/<span class="name">finalName</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><strong> 注意：一定要引servlet-api包，因为SpringMVC的关键dispatcherservlet是需要继承Servlet的。</strong></p>
<h1 id="SpringMVC配置"><a href="#SpringMVC配置" class="headerlink" title="SpringMVC配置"></a>SpringMVC配置</h1><h2 id="配置DispatcherServlet和ContextLoaderListener"><a href="#配置DispatcherServlet和ContextLoaderListener" class="headerlink" title="配置DispatcherServlet和ContextLoaderListener"></a>配置DispatcherServlet和ContextLoaderListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.support.AbstractAnnotationConfigDispatcherServletInitializer;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">SpitterWebAppInitializer</span> <span class="keyword">extends</span> <span class="title">AbstractAnnotationConfigDispatcherServletInitializer</span></span>&#123;</span><br><span class="line">	</span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建ContextLoaderListener（Servlet监听器）</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;</span><br><span class="line">        <span class="comment">//System.out.println("加载rootconfig");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;RootConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 创建DispacherServlet</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;</span><br><span class="line">        <span class="comment">//System.out.println("加载ServletConfigClasses");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> Class&lt;?&gt;[]&#123;WebConfig.class&#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> String[] getServletMappings() &#123;</span><br><span class="line">        <span class="comment">//System.out.println("加载getServletMappings");</span></span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> String[]&#123;<span class="string">"/"</span>&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>我在java下建立一个包config，这个包用来装java的配置来。</strong></p>
<p>在这里我们新建一个类什么名字都无所谓，在这里我们使用了SpitterWebAppInitializer这个名字，使它继承</p>
<p><strong>AbstractAnnotationConfigDispatcherServletInitializer</strong>类。</p>
<p>我们不需要任何配置，只要项目启动，那么Spring就会找谁扩展了<strong>AbstractAnnotationConfigDispatcherServletInitializer</strong>，就会自动配置DispacherSevlet和Spring应用上下文，spring的应用上下文位于应用程序的Servlet上下文之中。</p>
<h2 id="getServletMappings-方法"><a href="#getServletMappings-方法" class="headerlink" title="getServletMappings()方法"></a>getServletMappings()方法</h2><p>它将一个或多个路径映射到DispacherServlet上，我们设置的是”/“,它会处理进入应用的所有请求。如果设置为”/*.do”，那么它只会处理以”.do”结尾的请求，起到了过滤的作用。</p>
<h2 id="DispatcherServlet和ContextLoaderListener的区别"><a href="#DispatcherServlet和ContextLoaderListener的区别" class="headerlink" title="DispatcherServlet和ContextLoaderListener的区别"></a>DispatcherServlet和ContextLoaderListener的区别</h2><p>当DispatcherServlet启动的时候，它会创建Spring应用上下文，并加载配置或配置类中所生命的bean（即getServletConfigClasses()中所需要干的事)。</p>
<p>除了DispatcherServlet创建的应用上下文，还有另外一个应用上下文。它是由ContextLoaderListener创建的（即getRootConfigClasses()干的事）。它也叫做Servlet监听器</p>
<p>我们希望DispatcherServlet加载包含Web组件的bean，如控制器，试图解析器，以及处理器映射,而ContextLoaderListener要加载应用中的其他bean，这些bean通常是驱动应用后端的中间层和数据层的组件。简单的说，DispatcherServlet配置的都是与springMVC请求和流程有关的bean。而ContextLoaderListener是配置项目支撑的bean。</p>
<h2 id="DispatcherServlet和ContextLoaderListener加载顺序"><a href="#DispatcherServlet和ContextLoaderListener加载顺序" class="headerlink" title="DispatcherServlet和ContextLoaderListener加载顺序"></a>DispatcherServlet和ContextLoaderListener加载顺序</h2><p>看到我们注掉的东西了么，这是为了哪个容器需要先加载，项目运行，看控制台的输出，发现ContextLoaderListener先被加载，之后是DispatcherServlet。</p>
<h2 id="配置DispacherServlet"><a href="#配置DispacherServlet" class="headerlink" title="配置DispacherServlet"></a>配置DispacherServlet</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Bean;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.ViewResolver;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.DefaultServletHandlerConfigurer;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.WebMvcConfigurerAdapter;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.view.InternalResourceViewResolver;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableWebMvc</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(<span class="string">"action"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">WebConfig</span> <span class="keyword">extends</span> <span class="title">WebMvcConfigurerAdapter</span></span>&#123;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置jsp视图解析器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> ViewResolver <span class="title">viewResolver</span><span class="params">()</span></span>&#123;</span><br><span class="line">        InternalResourceViewResolver resolver=<span class="keyword">new</span> InternalResourceViewResolver();</span><br><span class="line">        resolver.setPrefix(<span class="string">"/WEB-INF/views/"</span>);</span><br><span class="line">        resolver.setSuffix(<span class="string">".jsp"</span>);</span><br><span class="line">        resolver.setExposeContextBeansAsAttributes(<span class="keyword">true</span>);</span><br><span class="line">        <span class="keyword">return</span> resolver;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 配置静态资源的处理</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">configureDefaultServletHandling</span><span class="params">(DefaultServletHandlerConfigurer configurer)</span></span>&#123;</span><br><span class="line">        configurer.enable();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="配置ContextLoaderListener"><a href="#配置ContextLoaderListener" class="headerlink" title="配置ContextLoaderListener"></a>配置ContextLoaderListener</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.FilterType;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.servlet.config.annotation.EnableWebMvc;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = &#123;<span class="string">"config"</span>&#125;,excludeFilters = &#123;</span><br><span class="line">        <span class="meta">@ComponentScan</span>.Filter(type = FilterType.ANNOTATION,value= EnableWebMvc.class)&#125;)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">RootConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>刚才对ContextLoaderListener有过介绍，这模块主要是对SpringMVC进行配置，这个以后涉及到数据库连接池等的时候，我们再详细配置。</p>
<p><strong>@Configuration:之前说过，让spring知道你这个是java配置类。</strong></p>
<p><strong>@EnableWebMvc：启动SpringMVC注解,这个注解相当于xml中的”<a href="mvc:annotation-driven" target="_blank" rel="noopener">mvc:annotation-driven</a>“</strong></p>
<p><strong>@ComponentScan(“action”)：启动组件扫描，这样SpringMVC就会寻找action中带有@Controller中的注解了。</strong></p>
<p><strong>为什么要继承WebMvcConfigurerAdapter</strong><br>因为我们有时候要处理对静态资源的请求，但是DispatcherServlet会处理所有的请求，所以我们继承WebMvcConfigurerAdapter类，当处理静态资源的时候，将请求交给默认的servlet。</p>
<h2 id="测试控制器"><a href="#测试控制器" class="headerlink" title="测试控制器"></a>测试控制器</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> action.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoAction</span> </span>&#123;</span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="首页index-jsp"><a href="#首页index-jsp" class="headerlink" title="首页index.jsp"></a>首页index.jsp</h2><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">html</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>Hello World!<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"/test"</span>&gt;</span>test<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p><img src="/guojian731.github.io/2017/12/13/Spring-全注解项目构建/springmvc1.png" alt="jvm装载步骤"></p>
<h2 id="跳转页面home-jsp"><a href="#跳转页面home-jsp" class="headerlink" title="跳转页面home.jsp"></a>跳转页面home.jsp</h2><p>WEB-INF/views/下新建一个就可以了，看看能否跳转成功。</p>
<p><img src="/guojian731.github.io/2017/12/13/Spring-全注解项目构建/springmvc2.png" alt="jvm装载步骤"></p>
<p><strong>至此，springmvc的全注解配置就结束了。</strong></p>
<h1 id="Spring配置"><a href="#Spring配置" class="headerlink" title="Spring配置"></a>Spring配置</h1><p>之前已经介绍过Spring的配置了，那么我在这里就不在累赘了。</p>
<h2 id="配置javaConfig"><a href="#配置javaConfig" class="headerlink" title="配置javaConfig"></a>配置javaConfig</h2><p>javaConfig是用来告诉spring哪些类需要进行加载的。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> config;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"impl"</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JavaConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">｝</span><br></pre></td></tr></table></figure>
<p><strong>@Configuration:告诉spring自己的java配置类</strong></p>
<p><strong>@ComponentScan(basePackages = “impl”)：将哪些文件进行spring的装配</strong></p>
<p><strong>注意：这个文件一定要放在之前配置RootConfig所指定的包下，即config，否则spring是不会找到这个配置类的。</strong></p>
<p>如果你用的工具是idea，那么当你配置正确的时候，就会出现下图的标记。</p>
<p><img src="/guojian731.github.io/2017/12/13/Spring-全注解项目构建/spring1.png" alt="jvm装载步骤"></p>
<p>点进去可以查看他们的映射关系</p>
<p><img src="/guojian731.github.io/2017/12/13/Spring-全注解项目构建/spring2.png" alt="jvm装载步骤"></p>
<p>所以我们也可以看到ContextLoaderListener和DispacherServlet各司其职。</p>
<h2 id="编写接口"><a href="#编写接口" class="headerlink" title="编写接口"></a>编写接口</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> service.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Payservice</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">(Integer num)</span></span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="编写实现类"><a href="#编写实现类" class="headerlink" title="编写实现类"></a>编写实现类</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> impl.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> service.pay.Payservice;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerPayServiceImpl</span> <span class="keyword">implements</span> <span class="title">Payservice</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用电脑支付了"</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="修改action"><a href="#修改action" class="headerlink" title="修改action"></a>修改action</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> action.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Controller;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class="line"><span class="keyword">import</span> org.springframework.web.bind.annotation.RequestMethod;</span><br><span class="line"><span class="keyword">import</span> service.pay.Payservice;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Controller</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">DoAction</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Payservice payservice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@RequestMapping</span>(value = <span class="string">"/test"</span>,method = RequestMethod.GET)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">home</span><span class="params">()</span></span>&#123;</span><br><span class="line">        payservice.pay(<span class="number">100</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"home"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojian731.github.io/guojian731.github.io/guojian731.github.io/2017/12/13/spring-2-自动化装配/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Guo Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/guojian731.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/guojian731.github.io/2017/12/13/spring-2-自动化装配/" itemprop="url">spring-2-自动化装配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-13T16:33:05+08:00">
                2017-12-13
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Spring Context负责创建bean，又使用DI（依赖注入）满足bean之间的依赖。接下来我们谈如何使用。</strong></p>
<p>环境：</p>
<p>所需manven包<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>junit<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>4.10<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">  <span class="comment">&lt;!-- &lt;scope&gt;test&lt;/scope&gt; --&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-core<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-test<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>使用的spring.version 是3.2.9</p>
<p>我们注意到junit 的下面有一个<scope>test</scope>，是什么意思呢。说明这个jar只会在你测试的resourse 下才会被使用，正常的代码区域是不会被引用的。所以，在做测试的情况下如果没有建立测试的resourse的话，需要把这个注掉。</p>
<h1 id="使用注解形式："><a href="#使用注解形式：" class="headerlink" title="使用注解形式："></a>使用注解形式：</h1><p>之前我们一定接触过Spring，多数是用Spring xml的配置进行的。我们这次使用注解方式进行使用。</p>
<p>Spring从两个角度来实现自动化装配：</p>
<p><strong>组件扫描(component scanning)：Spring会自动发现应用上下文中所创建的bean。</strong></p>
<p><strong>自动装配(autowiring)：Spring自动满足bean之间的依赖。</strong></p>
<p>举个例子： </p>
<p><img src="/guojian731.github.io/2017/12/13/spring-2-自动化装配/spring1.png" alt="jvm装载步骤"></p>
<p>如图所示，在java文件夹下建立action包逻辑处理，config 配置文件包，service接口包，以及impl实现类包。然后我们像做项目一样，需要一个支付的模块，分别建立一个pay子包。</p>
<p>先介绍几个spring用到的注解</p>
<p><strong>@Configuration:spring将这个类设置为config</strong></p>
<p><strong>@ComponentScan:这个注解在spring中启动扫描</strong></p>
<p><strong>@Component：使用这个注解，就可以使类能够让spring扫描到。</strong></p>
<p>先看我们的支付接口Payservice，它只有一个方法，就是支付。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> service.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">Payservice</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">pay</span><span class="params">(Integer num)</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然后是我们的手机支付的实现类，继承Payservice接口</p>
<p>我们使用@Component使这个类在spring能够发现这个类，并进行创建bean。创建的bean会有名字，如果@Component不写的话，那么就是phonePayServiceImpl，如果写了的话创建的名字就是你写的那个@Component(value = “phonePayServiceImpl”)。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> impl.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> service.pay.Payservice;</span><br><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PhonePayServiceImpl</span> <span class="keyword">implements</span> <span class="title">Payservice</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用手机支付了"</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>来写我们的PayConig</p>
<p>@Configuration Spring在启动时会寻找这个注解，知道他是config类，然后再进行相关操作。</p>
<p>@ComponentScan：需要扫描的包，如果不写其他的话，它会扫描的读当前包下的所有文件。我们把PayConfig放在impl.pay下就可以了。如果你想像我一样，将配置类统一管理的话，那么就明确一下包路径。当然你也可以建立一个JavaConfig类，然后设置为它的总包路径impl就可以了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">package</span> config.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;</span><br><span class="line"><span class="keyword">import</span> org.springframework.context.annotation.Configuration;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@ComponentScan</span>(basePackages = <span class="string">"impl.pay"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在我们测试一下是否成功</p>
<p>@Autowired 我们完成以上的操作，spring已经发现了需要创建的bean，但是没有将需要创建的bean的其他对象进行装配，这时候使用@Autowired 就可以完成自动装配</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> config.pay.PayConfig;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"><span class="keyword">import</span> service.pay.Payservice;</span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = PayConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> Payservice payservice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        payservice.pay(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/guojian731.github.io/2017/12/13/spring-2-自动化装配/spring2.png" alt="jvm装载步骤"></p>
<p>运行成功。</p>
<h2 id="一个接口多个实现类"><a href="#一个接口多个实现类" class="headerlink" title="一个接口多个实现类"></a>一个接口多个实现类</h2><p>问题，我们当一个接口有一个实现类的时候，装配成功了。就像之前说的，在PayTest中，我们只是调用了pay接口，它是使用电脑支付、手机支付我们都不知道，完成了解耦。但是如果两个实现类我们建立后，在PayTest会装配到底会装配哪一个实现类呢，我们做一下测试，新建一个实现类computerPayServiceImpl。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> impl.pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> org.springframework.stereotype.Component;</span><br><span class="line"><span class="keyword">import</span> service.pay.Payservice;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Component</span>(value = <span class="string">"computerPayServiceImpl"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ComputerPayServiceImpl</span> <span class="keyword">implements</span> <span class="title">Payservice</span></span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">pay</span><span class="params">(Integer num)</span> </span>&#123;</span><br><span class="line">        System.out.println(<span class="string">"使用电脑支付了"</span>+num);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们再调用一次。</p>
<p><img src="/guojian731.github.io/2017/12/13/spring-2-自动化装配/spring3.png" alt="jvm装载步骤"></p>
<p>我们发现调用失败了，spring不知道到底该调哪一个。但是这种场景经常出现，我们该怎么办？</p>
<p>这个时候我们就只是单单使用@Autowired这个注解了，还应加入@Qualifier注解，并写上spring创建bean的名字。这样spring就知道应该加载哪个bean了。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> pay;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> config.pay.PayConfig;</span><br><span class="line"><span class="keyword">import</span> org.junit.Test;</span><br><span class="line"><span class="keyword">import</span> org.junit.runner.RunWith;</span><br><span class="line"><span class="keyword">import</span> org.springframework.beans.factory.annotation.Qualifier;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.ContextConfiguration;</span><br><span class="line"><span class="keyword">import</span> org.springframework.test.context.junit4.SpringJUnit4ClassRunner;</span><br><span class="line"><span class="keyword">import</span> service.pay.Payservice;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="meta">@RunWith</span>(SpringJUnit4ClassRunner.class)</span><br><span class="line"><span class="meta">@ContextConfiguration</span>(classes = PayConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">	<span class="meta">@Qualifier</span>(<span class="string">"computerPayServiceImpl"</span>)</span><br><span class="line">    <span class="keyword">private</span> Payservice payservice;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        payservice.pay(<span class="number">100</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><img src="/guojian731.github.io/2017/12/13/spring-2-自动化装配/spring4.png" alt="jvm装载步骤"></p>
<h1 id="显示配置Bean之java代码"><a href="#显示配置Bean之java代码" class="headerlink" title="显示配置Bean之java代码"></a>显示配置Bean之java代码</h1><p>当我们有的时候无法为bean添加@component的方法，有时候这个类不是我们创建的，那么就无法使用自动装配的方式了，显而易见，spring就不会发现这个bean了，那么怎么办，spring有两个解决方式，分别是java显示配置和xml显示配置，现在先说一下使用java显示代码配置。</p>
<p>我们还是这个例子，然后把PhonePayServiceImpl实现类注掉，保证payservice先有一个实现类以便测试。然后将ComputerPayServiceImpl中的@component去掉，这样我们payconfig进行包扫描时，因为ComputerPayServiceImpl没有@component注解，那么spring就不会发现bean。我们测试一下。</p>
<p><img src="/guojian731.github.io/2017/12/13/spring-2-自动化装配/spring5.png" alt="jvm装载步骤"></p>
<p><img src="/guojian731.github.io/2017/12/13/spring-2-自动化装配/springV1.png" alt="jvm装载步骤"></p>
<p>测试结果为：</p>
<p>我们重点看到红线标记部分（如果你用的也是idea的话），可以看到要装配computerPayServiceImpl的payservice1提示无法找到这个bean，但是要装配phonePayServiceImpl却能，这就很说明问题了。</p>
<p>这个时候我们在javaConfig下显示的配置bean。</p>
<pre><code class="java"><span class="keyword">package</span> config.pay;

<span class="keyword">import</span> impl.pay.ComputerPayServiceImpl;
<span class="keyword">import</span> impl.pay.PhonePayServiceImpl;
<span class="keyword">import</span> org.springframework.context.annotation.Bean;
<span class="keyword">import</span> org.springframework.context.annotation.ComponentScan;
<span class="keyword">import</span> org.springframework.context.annotation.Configuration;
<span class="keyword">import</span> service.pay.Payservice;

<span class="meta">@Configuration</span>
<span class="meta">@ComponentScan</span>(basePackages = <span class="string">"impl.pay"</span>)

<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">PayConfig</span> </span>{


    <span class="meta">@Bean</span>(name = <span class="string">"computerPayServiceImpl"</span>)
    <span class="function"><span class="keyword">public</span> Payservice <span class="title">getComputerPayService</span> <span class="params">()</span></span>{
        <span class="keyword">return</span> <span class="keyword">new</span> ComputerPayServiceImpl();
    }

}
</code></pre>
<p>@bean注解：告诉spring这个方法将会返回一个对象，该对象要注册为Spring应用上下文的bean。方法体中包含了最终产生bean实例的逻辑。</p>
<p>默认情况下，bean的ID与带有@Bean注解的方法名是一样的，如下图的话，bean的名字就是getPayService。也可以使用@Bean的name属性指定。</p>
<p><img src="/guojian731.github.io/2017/12/13/spring-2-自动化装配/springV2.png" alt="jvm装载步骤"></p>
<p>我们也无用运行测试类，直接用idea观察，就会发现，computerPayServiceImpl不是醒目的红色而是绿色了，如果不是用idea，运行一下程序即可。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojian731.github.io/guojian731.github.io/guojian731.github.io/2017/12/12/JVM-7-垃圾回收器介绍/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Guo Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/guojian731.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/guojian731.github.io/2017/12/12/JVM-7-垃圾回收器介绍/" itemprop="url">JVM-7-垃圾回收器介绍</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-12T02:13:58+08:00">
                2017-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="串行回收器："><a href="#串行回收器：" class="headerlink" title="串行回收器："></a>串行回收器：</h1><p>串行回收器可以在新生代和老年代使用，根据作用不同的堆空间，分为新生代串行回收器和老年串行回收器。</p>
<h2 id="新生代串行回收器："><a href="#新生代串行回收器：" class="headerlink" title="新生代串行回收器："></a>新生代串行回收器：</h2><p>特点：</p>
<p><strong>1、它仅仅使用单线程进行垃圾回收。</strong></p>
<p><strong>2、它是独占式的垃圾回收。</strong></p>
<p>在串行收集器进行垃圾回收时，java应用程序中的线程都需要暂停，等待垃圾回收的完成。应用程序停止工作，进行等待，这种现象称之为“stop-the-world”。它将造成非常糟糕的用户体验，在实时性比较高的应用场景下，是很难让人接受的。</p>
<p>-XX:+UseSerialGC参数可以制定虚拟机使用新生代串行收集器和老年代串行收集器。是虚拟机使用client模式下，默认的垃圾收集器。</p>
<h2 id="老年代串行回收器："><a href="#老年代串行回收器：" class="headerlink" title="老年代串行回收器："></a>老年代串行回收器：</h2><p>老年代串行收集器使用标记压缩算法，和新生代串行收集器一样，是独占式垃圾回收器。但是老年代由于存储空间大，老年代垃圾回收器会比新生代回收更长时间。</p>
<p>若老年代使用串行收集器，可以跟多种新生代回收器配合使用，同时它是CMS回收器的备用回收器。</p>
<p><strong>-XX:+UseSerialGC:新生代、老年代均使用串行回收器</strong></p>
<p><strong>-XX:+UseParNewGC：新生代使用ParNew回收器，老年代使用串行回收器</strong></p>
<p><strong>-XX:+UseParallelGC:新生代使用ParallelGC回收器，老年代使用串行收集器。</strong></p>
<h1 id="并行回收器"><a href="#并行回收器" class="headerlink" title="并行回收器"></a>并行回收器</h1><h2 id="新生代ParNew回收器："><a href="#新生代ParNew回收器：" class="headerlink" title="新生代ParNew回收器："></a>新生代ParNew回收器：</h2><p>ParNew回收器工作在新生代，它只是将串行回收器多线程化，ParNew也是独占式回收器，在收集过程中，应用程序会全部暂停。但由于是并行的，在并行能力强的CPU上，它产生的停顿时间要短于串行回收器。但是在单CPU或者并发能力弱的系统中，并行回收器效果很可能要比串行回收器差。</p>
<p><strong>-XX:+UseParNewGC:新生代使用ParNew回收器，老年代使用串行回收器。</strong></p>
<p><strong>-XX:+UseConcMarkSweepGC:新生代使用ParNew回收器，老年代使用CMS回收器。</strong></p>
<p>ParNew回收器工作的线程数量可以使用-XX:ParallelGCThreads参数指定。默认情况下，当CPU数量小于8个时，ParallelGCThreads的值等于CPU数量，当CPU数量大于8个时，ParallelGCThreads的值等于3+（5*CPU数量/8）。</p>
<h2 id="新生代ParallelGC回收器"><a href="#新生代ParallelGC回收器" class="headerlink" title="新生代ParallelGC回收器"></a>新生代ParallelGC回收器</h2><p>新生代ParallelGC回收器也是使用复制算法的收集器，同ParNew回收器一样，是多线程、独占式的收集器。ParallelGC回收器有一个重要特点，他非常关注系统的吞吐量。</p>
<p><strong>-XX:+UseParallelGC:新生代使用ParallelGC回收器，老年代使用串行收集器。</strong></p>
<p><strong>-XX:+UseParallelOldGC：新生代使用ParallelGC回收器，老年代使用ParallelGC回收器。</strong></p>
<p><strong>ParallelGC回收器提供了两个重要参数来控制系统的吞吐量：</strong></p>
<p>-XX:MaxGCPauseMilis:设置最大的垃圾收集停顿时间。他的值是大于0的整数，虚拟机会将停顿时间控制在设置的值内，如果希望停顿时间较小，那么将值设置小一些就可以了。但是这样虚拟机可能会使用一个较小的堆，因为小堆会比大堆用的时间少，但是会增加GC回收的次数，从而降低了吞吐量。</p>
<p>-XX:GCTimeRatio:设置吞吐量的大小。他的值在0到100之间的整数。默认值是19，以为着1/(1+19),将垃圾回收控制在总时间的5%以内。要是设置99，那么垃圾回收的时间应不超过1%。</p>
<p>我们可以使用-XX:UseAdaptiveSizePolicy可以打开GC自适应策略，在这个模式下，新生代大小，eden，old和suivivior的比例、晋升老年代的对象年龄等参数会被自动整理，来达到堆大小、吞吐量和停顿时间的平衡点。我们可以制定虚拟机的最大堆，目标吞吐量GCTimeRatio和停顿时间MaxGCPauseMilis，让虚拟机自己完成工作。</p>
<h2 id="老年代ParallerOldGC回收器"><a href="#老年代ParallerOldGC回收器" class="headerlink" title="老年代ParallerOldGC回收器"></a>老年代ParallerOldGC回收器</h2><p>老年代ParallelOldGC是回收器也是多线程并发的收集器。它也是一个关注吞吐量的回收器，它只能和新生代ParallelGC回收器一起使用。也是使用标记压缩算法。</p>
<p>XX:ParallelGCThreads也可用于设置垃圾回收时的线程数量。那么我们看到新生代ParNew回收器也会使用这个参数，那么岂不是冲突了吗？不会的，因为两个收集器是不可能在一起使用的，所以参数一样的，但是并不会起到冲突。</p>
<h1 id="并发垃圾回收器"><a href="#并发垃圾回收器" class="headerlink" title="并发垃圾回收器"></a>并发垃圾回收器</h1><h2 id="老年代CMS垃圾回收器"><a href="#老年代CMS垃圾回收器" class="headerlink" title="老年代CMS垃圾回收器"></a>老年代CMS垃圾回收器</h2><p>与Parallel和ParallelOldGC不同，CMS回收器主要关注于系统的停顿时间。CMS是Concurrent Mark Sweep的缩写，意为并发标记清除，从名称上可以得出，它使用的是标记清除算法，同时它是一个使用多线程并行回收的垃圾收集器。<br><img src="/guojian731.github.io/2017/12/12/JVM-7-垃圾回收器介绍/CMS流程图.png" alt="CMS流程图"></p>
<p>STW：停顿时间的缩写，在这个时间段应用程序的所有进程全部暂停。</p>
<p>我们可以看见，CMS中只有初始标记和重新标记两步需要应用程序暂停，其他步骤都是可以与应用程序一起执行的，所以说CMS不是一个独占式的垃圾回收器。初始标记、并发标记、重新标记都是为了标记出需要回收的垃圾对象，并发清理则在标记完成之后，正是回收垃圾对象。并发重置指在垃圾回收完成后，重新初始化CMS数据结构和数据，为下一次垃圾回收做准备。</p>
<p>在整个CMS回收过程中，默认情况下，在并发标记之后，会有一个预清理的操作（也可以关闭开关-XX:-CMSPrecleaningEnable，不进行预清理）。预清理是并发的，除了为正式做准备和检查以外，预清理还会尝试控制一次停顿时间。由于重新标记是独占CPU的，如果新生代发生GC的时候，就会立即触发一次重新标记，那么一次停顿时间可能会很长。为了避免这种情况，预处理时，会特意等待一次新生代GC的发生，然后根据历史性能数据预测下一次新生代GC可能发生的时间，然后在当前时间和预测时间的中间时刻，进行重新标记。这样，从最大程度上避免新生代GC和重新标记重合，尽可能减少一次的停顿时间。</p>
<h3 id="CMS主要参数："><a href="#CMS主要参数：" class="headerlink" title="CMS主要参数："></a>CMS主要参数：</h3><p><strong>-XX:+UseConcMarkSweepGC:新生代使用ParNew回收器，老年代使用CMS回收器。</strong></p>
<p>CMS默认启动的并发线程数是（ParallelGCThreads+3）/4。我们需要查看当ParNew回收器时设置的ParallelGCThreads参数。并发线程数量也可以通过-XX:ConGCThreads或者-XX:ParallelCMSThreads参数手工设定。当CPU资源比较紧张时，收到CMS回收线程的影响，应用程序的性能在垃圾回收阶段可能会非常糟糕。</p>
<p>因为CMS不是独占式回收器，所以在进行垃圾回收时，应用系统还在运行，还会不停的创造垃圾，这些新生的垃圾是不会被清除的。同时，因为没有中断，那么在CMS回收时，应确保剩余的堆空间有足够的内存可用，所以CMS不会在堆空间饱和的时候进行垃圾回收，因为要确保有足够的空间可以支持应用程序。</p>
<p>这个阀值使用-XX:CMSInitiatingOccupancyFraction来指定，默认是68.当老年代使用率达到68了，就进行CMS垃圾回收。如果在执行垃圾回收的时候，内存不足了，CMS垃圾回收就会失败，就会使用串行收集器进行回收，此时应用程序会完全中断。</p>
<p>因为CMS使用的是标记清除算法，所以他清理后会产生内存碎片，离散内存碎片无法分配较大的对象，这种情况会被迫进行再进行一次垃圾回收来获取一块可用的连续内存，但是这对系统性能影响很严重。</p>
<p>使用-XX:+UseCMSCompactAtFullCollectoin开始可以使CMS在垃圾收集完成后，进行一次脆片整理，内存碎片的整理不是并发进行的。-XX:CMSFullGCsBeforeCompaction参数可以用于设定进行多少次CMS回收后，进行一次内存压缩。</p>
<p>可以使用CMS来回收perm区，必须要打开-XX:+CMSClassUnloadingEnable开关。条件允许的情况下，系统会使用CMS机制回收Perm区的Class数据。</p>
<h2 id="未来做主的：G1回收器"><a href="#未来做主的：G1回收器" class="headerlink" title="未来做主的：G1回收器"></a>未来做主的：G1回收器</h2><p>G1（Garbage-First）回收器是在JDK1.7中正式使用的全新的垃圾回收器。它的出现是为了取代CMS垃圾回收器。</p>
<p>从分代上看，G1依然属于分代垃圾回收器，它依旧区分年轻代和老年代，依旧分为新生代和老年代。但是堆的结构来看，它不要求整个eden区、年轻代、老年代都连续，它使用了分区算法，来替代CMS长期替代方案。</p>
<p>（关于后续部分之后在更新。）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojian731.github.io/guojian731.github.io/guojian731.github.io/2017/12/12/JVM-6-垃圾回收概念与算法/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Guo Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/guojian731.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/guojian731.github.io/2017/12/12/JVM-6-垃圾回收概念与算法/" itemprop="url">JVM-6-垃圾回收概念与算法</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-12T02:09:45+08:00">
                2017-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>GC中的垃圾，特指存在于内存中的、不会被使用的对象，而“回收”，相当于把垃圾桶“倒掉”。</p>
<p>常用的垃圾回收算法</p>
<h1 id="1、引用计数法"><a href="#1、引用计数法" class="headerlink" title="1、引用计数法"></a>1、引用计数法</h1><p>对于一个对象A，任何一个对象引用了A，则A的计数器+1，当引用失效后，引用计数器-1。只要对象A的计数器为0，那么A对象就不会被引用。</p>
<p>它有两个严重的问题：</p>
<p><strong>无法处理循环引用的情况。因此，在Java的垃圾回收器中，没有使用这种算法。</strong></p>
<p><strong>引用计数器要求在每次因引用产生和消除时，需要伴随一次加法操作和减法操作，对系统性能呢个有一定的影响。</strong></p>
<p>例子：如果A、B对象相互引用，计数器均不为0，但是没有第三个对象引用他们，A，B应该是被回收的对象，但是由于他们两个相互引用，从而使垃圾回收期无法识别，引起内存泄漏。</p>
<h1 id="2、标记清除法"><a href="#2、标记清除法" class="headerlink" title="2、标记清除法"></a>2、标记清除法</h1><p>标记清除法是现代垃圾回收算法的思想基础。标记清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。一个可行的实现是，在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。然后，在清除阶段，清除所有未被标记的对象。标记清除算法可能产生最大的为题是空间碎片。</p>
<p><strong>标记清除算法先通过根节点标记所有可达对象，然后清除所有不可达对象，回收的空间是不连续的，不连续的空间的工作效率要低于连续的空间。这就是该算法最大的缺点。</strong></p>
<h1 id="3、复制算法"><a href="#3、复制算法" class="headerlink" title="3、复制算法"></a>3、复制算法</h1><p>复制算法的核心思想：将原有的空间内存分为两块，每次只使用其中一块，在垃圾回收时，将正在使用内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。</p>
<p>当需要回收的垃圾对象很多，需要复制的对象很少的时候，这个算法效率是很高的。此算法是不会产生空间碎片的，但是复制算法的代价就是将系统内存折半，因此单纯的复制算法让人难以接受。</p>
<p>在Java新生代的串行收集器中，使用了复制算法的思想。新生代分为eden空间，from区和to区三个部分。from区和to区就是两块内存大小相等，地位相等，可进行角色转换的内存块。from和to空间也被成为survivor空间，即存活者空间，用于存放未被回收的对象。</p>
<h1 id="4、标记压缩法"><a href="#4、标记压缩法" class="headerlink" title="4、标记压缩法"></a>4、标记压缩法</h1><p>因为复制算法适合只使用于垃圾对象多，存活对象少的情况，那么老年代这种垃圾对象少，存活对象多的情况，是不适合用复制算法的。标记压缩算法也是从根节点开始，对所有可达的对象做一次标记，它并不是简单的清理未标记的对象，而是将所有存活的对象压缩到内存的另一端，然后清理边界之外的所有对象。<br>标记压缩算法最终效果等同于标记清除法执行完成后，再进行一次内存碎片整理，因此，也可以把它成为标记清除压缩算法。</p>
<h1 id="5、分代算法"><a href="#5、分代算法" class="headerlink" title="5、分代算法"></a>5、分代算法</h1><p>前面的几种算法，他们没法完全替代其他算法，都有自己的优点和缺点。根据垃圾回收对象的特性，使用合适的算法回收，才是明智的选择。<br>分代算法就是基于这种思想，它将内存区间根据对象的特点分为几块，根据每块内存区间的特点，使用不同的回收算法，一提高垃圾回收的效率。</p>
<h1 id="6、分区算法"><a href="#6、分区算法" class="headerlink" title="6、分区算法"></a>6、分区算法</h1><p>分区算法将按照对象的生命周期长短划分成两个部分，分区算法将整个堆空间划分成连续的不同的小区间。每一个小区间都独立使用，独立回收。这种算法的好处是可以控制一次回收多少个小区间。</p>
<p>一般来说，在相同条件下，堆空间越大，一次GC所需要的时间越长，从而产生的停顿越长，即stop-the-world。为了更好的控制GC产生的停顿时间，将一块大的内存区域分割成多个小块，根据目标的停顿时间，每次合理的回收若干个小区间，而不是整个堆空间，从而减少一次GC的停顿。</p>
<p>jdk1.8中的G1垃圾回收器就是使用的这种方法。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojian731.github.io/guojian731.github.io/guojian731.github.io/2017/12/12/JVM-5-JIT编译及静态编译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Guo Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/guojian731.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/guojian731.github.io/2017/12/12/JVM-5-JIT编译及静态编译/" itemprop="url">JVM-5-JIT编译及静态编译</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-12T01:17:15+08:00">
                2017-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>对于执行的字节码会从两处进行优化。</p>
<p><strong>第一，就是使用javac编译时。</strong></p>
<p><strong>第二，就是使用JIT（just-in-time）即时编译，在运行时。</strong></p>
<h1 id="编译时计算："><a href="#编译时计算：" class="headerlink" title="编译时计算："></a>编译时计算：</h1><p>如果在程序中出现了计算表达式，如果表达式的值能够在编译时确定，那么表达式的计算会提前到编译阶段，而不是在运行时计算。<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">60</span>*<span class="number">60</span>*<span class="number">24</span>*<span class="number">1000</span>；i++)&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>我们经常会用到这样的写法60<em>60</em>24*1000，那么是不是每次循环都都要进行一次？其实不是，因为在编译的时候，对于给定的表达式会自动计算并给出结果。</p>
<p>字符串相加：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String info1=<span class="string">"ab"</span>;</span><br><span class="line"></span><br><span class="line">String info2=“a”+“b”；</span><br><span class="line"></span><br><span class="line">String <span class="keyword">const</span>=<span class="string">"a"</span>;</span><br><span class="line"></span><br><span class="line">String info3=<span class="keyword">const</span>+<span class="string">"b"</span>;</span><br></pre></td></tr></table></figure></p>
<p>三个值的字面量都是”ab”，那么他们相等吗，info1==info2 是相等的，理由：因为在info的“+”并为在运行时进行，在编译的时候就进行了，所以不会产生新的对象。而info3有一个未知的变量，所以“+”在运行时进行，产生了新的对象。</p>
<p>在变量字符串连接：</p>
<p>例子：<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">addString2</span><span class="params">(String ...str1)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    String str3=<span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span>(String str:str1)&#123;</span><br><span class="line"></span><br><span class="line">            str3+=str1;        </span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>当变量字符串相加时，系统会先将字符串转化为StringBuilder，然后做append操作。但是在for循环中，是每一次循环都建立一个StringBuilder对象，这样很费系统资源，正确的做法是在循环外建立一个StringBuilder，然后做append(）操作。S</p>
<h1 id="JIT编译"><a href="#JIT编译" class="headerlink" title="JIT编译"></a>JIT编译</h1><p>java虚拟机有三种执行方式，分别是解释执行(-Xint)、混合模式(-mixed mode )、编译执行(-Xcomp),默认是混合模式。</p>
<p>解释执行表示全部代码均解释执行，不做任何JIT编译，使用java -Xint -version来开启。</p>
<p>混合模式是根据是否会是热点代码，如果是，都会编译执行。</p>
<p>编译模式，所有代码均编译执行。</p>
<p>一般来说，编译模式的执行效率会远远高于解释模式。大家可以使用同一段代码根据-Xint、-Xcomp来比较。</p>
<h1 id="JIT编译阀值："><a href="#JIT编译阀值：" class="headerlink" title="JIT编译阀值："></a>JIT编译阀值：</h1><p>-client模式下，阀值是1500次</p>
<p>-server模式下，阀值是10000次。</p>
<p>使用-XX:CompileThreshold可以设置这个阀值。（-XX:CompileThreshold=500）</p>
<p>使用-XX:PrintCompilation可以打印出即时编译的日志。（-XX:PrintCompilation）</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojian731.github.io/guojian731.github.io/guojian731.github.io/2017/12/12/JVM-4-装载（加载、连接、初始化）/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Guo Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/guojian731.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/guojian731.github.io/2017/12/12/JVM-4-装载（加载、连接、初始化）/" itemprop="url">JVM-4-装载（加载、连接、初始化）</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-12T00:47:11+08:00">
                2017-12-12
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>Class类型通常以文件的形式存在（当然，任何二进制流都可以是class类型），只有被java虚拟机装在的class类型才能在程序中使用。系统装载Class类型可以分为加载、连接和初始化3个步骤。其中连接又可分为验证、准备、解析3步。</strong></p>
<p><img src="/guojian731.github.io/2017/12/12/JVM-4-装载（加载、连接、初始化）/jvm1.png" alt="jvm装载步骤"></p>
<h1 id="装载类的条件："><a href="#装载类的条件：" class="headerlink" title="装载类的条件："></a>装载类的条件：</h1><p><strong>Class只有在必要的时候才会被装载，JVM虚拟机不会无条件地加载Class类型。Java虚拟机规定，一个类或接口在初次使用前，必须要进行初始化。这里指的“使用”，是主动使用、主动使用只有下列几种情况。</strong></p>
<p>1、当创建一个类的实例的时候，new关键字、或者通过反射、克隆、反序列化。</p>
<p>2、当调用类的静态方法时，即当使用了字节码invokestatic指令。</p>
<p>3、当使用类或接口的静态字段时（final常量外）。</p>
<p>4、当使用java.lang.reflect包中的方法反射类的方法时。</p>
<p>5、初始化子类时，要求先初始化父类。</p>
<p>6、作为启动虚拟机，含有main()方法的那个类。</p>
<p>1、创建实例<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String name =<span class="string">"liumou"</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"student完成装载"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">Student student=<span class="keyword">new</span> Student();</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>输出结果是：student完成装载，说明student已经装载完成。</p>
<p>2、删除main中的方法改为<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">String name=Student.name;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p> 输出结果：student完成装载，说明调用类的静态变量可以完成该类的装载。</p>
<p>3、在student类中添加静态变量方法<br><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>&#123;</span><br><span class="line"></span><br><span class="line">System.out.println(<span class="string">"调用了student的静态方法"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>在test类中用调用staticMethod()方法。</p>
<p>输出结果：</p>
<pre><code>student完成装载

调用了student的静态方法
</code></pre><p>说明：调用类的静态方法是可以完成类的装载。</p>
<p>4、同样是student类，继承Person。</p>
<pre><code class="java">
<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Student</span> <span class="keyword">extends</span> <span class="title">Person</span></span>{

<span class="keyword">public</span> <span class="keyword">final</span> <span class="keyword">static</span>  String name =<span class="string">"liumou"</span>;



<span class="keyword">static</span>{

System.out.println(<span class="string">"student完成装载"</span>);

}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">staticMethod</span><span class="params">()</span></span>{

System.out.println(<span class="string">"调用了student的静态方法"</span>);

}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>{

System.out.println(<span class="string">"student可以被装载"</span>);

}

}



<span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>{

<span class="keyword">static</span> {

System.out.println(<span class="string">"父类Person完成装载"</span>);

}

<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">methodStatic</span><span class="params">()</span></span>{

System.out.println(<span class="string">"父类PerSon的方法"</span>);

}

}
</code></pre>
<p>（1） 在test类中，新建student对象。</p>
<p>输出结果：父类Person完成装载</p>
<p>student完成装载</p>
<p>调用了student的静态方法</p>
<p><strong>结论：对象装载之前需先装载其父类，然后才能装载自己。</strong></p>
<p>（2）在test类中，调用子类调用父类的静态方法methodStatic（），（子类并未覆盖此方法）。</p>
<p>  输出结果：父类Person完成装载</p>
<p>父类PerSon的方法</p>
<p><strong>结论：当子类调用父类的静态方法，子类是不会进行装载的。此时的装载，代表的是此时的子类student并未初始化，但是已经被系统加载。使用-XX:+TraceClassLoading可以看日志装载情况。</strong>   </p>
<p> （3）在test方法中，调用Student的name属性（final修饰的静态变量）。</p>
<p>输出结果：只有“liumou”</p>
<p>结论：说明调用类的final修饰的静态变量不会进行类的装载。此时类连加载都没有。  </p>
<p>注：这里说明其他类调用一个类的final修饰的变量时，是不会存在类的加载的，是在编译时直接放在常量池的。     </p>
<h1 id="加载类"><a href="#加载类" class="headerlink" title="加载类"></a>加载类</h1><p>加载类处于类加载的第一个阶段。在加载类时，Java虚拟机必须完成以下工作：</p>
<p>   通过类的全名，获取类的二进制数据流<br>   解析类的二进制数据流为方法区内的数据结构<br>   创建java.lang.Class类的实例，表示该类型</p>
<h1 id="验证"><a href="#验证" class="headerlink" title="验证"></a>验证</h1><h2 id="验证类"><a href="#验证类" class="headerlink" title="验证类"></a>验证类</h2><p><img src="/guojian731.github.io/2017/12/12/JVM-4-装载（加载、连接、初始化）/jvm2.png" alt="jvm装载步骤"></p>
<h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>当一个类验证通过时，虚拟机就会进入准备阶段。在这个阶段，虚拟机就会为这个类分配相应的内存空间，并设置初始值。<br>int：0</p>
<p>long:0L</p>
<p>short:(short)0</p>
<p>char: \u000</p>
<p>boolean: false</p>
<p>reference: null</p>
<p>float: 0f</p>
<p>double: 0f </p>
<p> 当类中存在常量字段，分情况。在准备阶段，是不会发生字节码行为的。<br> public static final String constString =”const”;<br> 当静态变量被final修饰后，该常量 constString在准备阶段被附上字符串”const”</p>
<p> 但是如果没有final修饰过，仅仅作为普通变量：<br> public static String cString=”const”<br> 此时，   cString的赋值在函数<clinit>中发生，属于java字节码的行为，此时是在初始化中赋值（后面会说到）</clinit></p>
<h2 id="解析类"><a href="#解析类" class="headerlink" title="解析类"></a>解析类</h2><p>在准备阶段完成后，进入解析阶段。解析阶段的工作就是讲类、接口、字段和方法的符号引用转化为直接引用。<br>符号引用就是字面量的引用。就是在class类文件中，通过常量池进行大量的符号引用。</p>
<h1 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h1><p>类的初始化是类的装载的最后一个阶段。如果前面的步骤都没有问题，那么表示类可以顺利的装载到系统中。此时，类才会执行java字节码。初始化阶段的重要是执行类的初始化方法<clinit>。方法<clinit>是由编译器自动生成的，他是有类静态成员的赋值语句以及static语句块合并产生的。<br>由于加载一个类之前，虚拟机总是试图尝试加载该类的父类，因此父类的<clinit>总是在子类<clinit>之前被调用。也就是说，子类的static块优先级高于父类。</clinit></clinit></clinit></clinit></p>
<p><strong>注：classLoader只负责类的加载，连接和初始化与classLoader无关。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojian731.github.io/guojian731.github.io/guojian731.github.io/2017/12/11/JVM-3-字符串的存储方式以及equals、intern、-之间的区别/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Guo Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/guojian731.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/guojian731.github.io/2017/12/11/JVM-3-字符串的存储方式以及equals、intern、-之间的区别/" itemprop="url">JVM-3-字符串的存储方式以及equals、intern、==之间的区别</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-11T17:59:40+08:00">
                2017-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="知识点："><a href="#知识点：" class="headerlink" title="知识点："></a>知识点：</h1><p><strong>在jvm中，字符串有着非常“高等的地位”。在1.7以后，堆空间分为字符串常量池（也有叫做缓冲区）和非字符串常量池。</strong></p>
<p><strong>字符串常量池：用来存储字符串的字面量。</strong></p>
<p><strong>非字符串常量池：存储字符串对象以及其他普通的对象。</strong></p>
<h1 id="为什么要有字符串常量池："><a href="#为什么要有字符串常量池：" class="headerlink" title="为什么要有字符串常量池："></a>为什么要有字符串常量池：</h1><p><strong>字符串的分配，和其他的对象分配一样，耗费高昂的时间与空间代价。JVM为了提高性能和减少内存开销，在实例化字符串常量的时候进行了一些优化。为了减少在JVM中创建的字符串的数量，字符串类维护了一个字符串池，每当代码创建字符串常量时，JVM会首先检查字符串常量池。如果字符串已经存在池中，就返回池中的实例引用。如果字符串不在池中，就会实例化一个字符串并放到池中。Java能够进行这样的优化是因为字符串是不可变的，可以不用担心数据冲突进行共享。</strong></p>
<h1 id="字符串的创建方式："><a href="#字符串的创建方式：" class="headerlink" title="字符串的创建方式："></a>字符串的创建方式：</h1><p><strong>字符串有两种创建方式，一种是通过双引号直接赋值和通过构造器来创建。</strong></p>
<h2 id="双引号赋值："><a href="#双引号赋值：" class="headerlink" title="双引号赋值："></a>双引号赋值：</h2><p>String s1=”11”;<br>创建一个对象的时候，会判断字符串常量池是否会有”11”，没有在字符串常量池添加”11”，并在非字符串常量池创建String对象，这时s1变量是指向字符串常量的”11”的。</p>
<h2 id="构造器创建："><a href="#构造器创建：" class="headerlink" title="构造器创建："></a>构造器创建：</h2><p>String s2=new String(“11”);</p>
<p>创建对象，并不会在字符串常量池进行操作，只会在非字符串常量池建立对象，s2指向指向这个对象。</p>
<p><img src="/guojian731.github.io/2017/12/11/JVM-3-字符串的存储方式以及equals、intern、-之间的区别/jvm1.png" alt="jvm内部构成表"></p>
<p>所以再用“==”判断的时候是false，因为两个变量的指向是不一样的。</p>
<h1 id="equals、-、intern-之间的区别"><a href="#equals、-、intern-之间的区别" class="headerlink" title="equals、==、intern()之间的区别"></a>equals、==、intern()之间的区别</h1><p>equals：是父类Object的方法，String重类写了这一方法，判断是否是首先判断是否是同一对象，是的话返回true。接着判断是否是String类型、如果是再判断是否值相同。<br>==：判断两个对象是否是同一对象，即两个对象的指向是否相同。<br>intern()：其实并不是用来判断是否相等的用途，它是在非字符串常量池添加字面量，所以他通常和new String()结合使用，可以在非字符串常量池建立变量并且指向它。<br>实例：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">String s1=<span class="string">"ab"</span>;</span><br><span class="line">String s2=<span class="string">"abcd"</span>;</span><br><span class="line">String s3=<span class="string">"ab"</span>+<span class="string">"cd"</span>;</span><br><span class="line">String s4=s1+<span class="string">"cd"</span>;</span><br><span class="line">         </span><br><span class="line">System.out.println(<span class="string">"----第一部分  ----"</span>);</span><br><span class="line">System.out.println(s2==s3);<span class="comment">//true</span></span><br><span class="line">System.out.println(s2==s3.intern());<span class="comment">//true</span></span><br><span class="line">System.out.println(s2.intern()==s3);<span class="comment">//true</span></span><br><span class="line">         </span><br><span class="line">System.out.println(<span class="string">"---- 第二部分 ----"</span>);</span><br><span class="line">System.out.println(s2==s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s2==s4.intern());<span class="comment">//true</span></span><br><span class="line">System.out.println(s2.intern()==s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(<span class="string">"---- 第三部分 ----"</span>);</span><br><span class="line">System.out.println(s3==s4);<span class="comment">//false</span></span><br><span class="line">System.out.println(s3==s4.intern());<span class="comment">//true</span></span><br><span class="line">System.out.println(s3.intern()==s4);<span class="comment">//false</span></span><br></pre></td></tr></table></figure>
<h2 id="第一部分解析："><a href="#第一部分解析：" class="headerlink" title="第一部分解析："></a>第一部分解析：</h2><p>1、当String由两个字面量相加的时候，会判断字符串常量池，所以全是true。</p>
<h2 id="第二部分解析："><a href="#第二部分解析：" class="headerlink" title="第二部分解析："></a>第二部分解析：</h2><p>1、当String是变量和字面量相加的时候，不会在字符串常量池进行判断，所以两个对象指向不同，false。<br>2、对s4这个对象进行intern()操作时，它会在字符串常量池进行判断，如果有的话，那么他不添加，没有的话就添加，所以为true。但是，记住即使s4.intern()不会改变s4的指向，他的指向还在非字符串常量池。如果想改变s4的指引的话，需要赋值。s4=s4.intern();所以说intern()应该跟new String(）结合使用，即 String s4=new String(“abcd”).intern()要不还需要有赋值的操作。<br>3、还是如二所说，s4的指向还是非字符串常量池，所以不相等。</p>
<h2 id="第三部分解析："><a href="#第三部分解析：" class="headerlink" title="第三部分解析："></a>第三部分解析：</h2><p>根据第二部分自己看吧~</p>
<p><strong>注：在字符串尽量少使用 String ss=”ab”+”cd”这样的操作，因为这样的操作如同新建了StringBuilder，然后进行append，这好像并没有什么不妥，但是要记住，当你要遍历时，每次都会新建一个StringBuilder，这样很浪费资源。</strong></p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://guojian731.github.io/guojian731.github.io/guojian731.github.io/2017/12/11/JVM-2-常用命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Guo Jian">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/guojian731.github.io/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Notes">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/guojian731.github.io/2017/12/11/JVM-2-常用命令/" itemprop="url">JVM-2-常用命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-12-11T17:48:41+08:00">
                2017-12-11
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h1 id="堆内存设定"><a href="#堆内存设定" class="headerlink" title="堆内存设定"></a>堆内存设定</h1><p>-Xmx ：最大堆内存</p>
<p>-Xms ：初始堆内存 </p>
<h1 id="占空间设定"><a href="#占空间设定" class="headerlink" title="占空间设定"></a>占空间设定</h1><p>-Xss ：指定线程最大栈空间</p>
<h1 id="方法区："><a href="#方法区：" class="headerlink" title="方法区："></a>方法区：</h1><p><strong>理解为永久区perm，在jdk1.6和1.7中存在，在1.8中剔除</strong></p>
<p>-XX:PermSize：初始化方法区。</p>
<p>-XX:MaxPermSize:最大方法区：默认情况为64M</p>
<h1 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h1><p>-XX:+PrintGC 打印gc日志</p>
<p>-XX:+PrintGCDetails  打印详细的gc日志</p>
<p>-XX:+PrintHeapAtGC 在每次GC前后分别打印堆的信息。</p>
<p>-XX:+PrintGCTimeStamps 该参数会在每个GC发生时，额外的输出GC发生的时间，该输出时间为虚拟机启动后的时间偏移量。</p>
<p>-XX:+PrintGCApplicationConcurrentTime 打印应用程序的执行时间</p>
<p>-XX:+PrintGCApplicationStoppedTime 打印应用程序由于GC而产生的停顿时间。</p>
<p>-XX:+PrintReferenceGC 跟踪系统中软引用、弱引用、虚引用和Finallize队列。</p>
<p>-Xloggc:log/gc.log  在当前目录下的log文件夹下的log文件夹下的gc.log文件中记录所有的GC日志。</p>
<h1 id="类加载-卸载的跟踪"><a href="#类加载-卸载的跟踪" class="headerlink" title="类加载/卸载的跟踪"></a>类加载/卸载的跟踪</h1><p>-verbose:class 跟踪类的加载和卸载</p>
<p>-XX:+TranceClassLoading 跟踪类的加载</p>
<p>-XX:+TranceClassUnloading 跟踪类的卸载</p>
<p>Java虚拟机还允许研发人员在运行时打印、查看系统中类的分布情况。只要在系统中启动时加上-XX:+PrintClassHistogram参数，然后在Java的控制台中按下Ctrl+Break组合键，控制台上就会显示当前的类信息柱状图。</p>
<h1 id="系统参数查看："><a href="#系统参数查看：" class="headerlink" title="系统参数查看："></a>系统参数查看：</h1><p>-XX:+PrintVMOptions 在程序运行时，打印虚拟机接收到的命令行显示参数。</p>
<p>-XX:+PrintCommandLineFlags 可以打印传递给虚拟机的显示和隐示参数。</p>
<p>-XX:+PrintFlagsFinal 打印所有的系统参数的值（大约有500多个）</p>
<h1 id="新生代配置："><a href="#新生代配置：" class="headerlink" title="新生代配置："></a>新生代配置：</h1><p>-Xmn 用于设置新生代的大小。新生代大小一般设置为整个堆空间的1/3到1/4之间。(-Xmn1m)</p>
<p>-XX:SurvivorRatio=eden/from=eden/to 设置新生代中eden空间和from/to空间的比例关系。</p>
<p>（-XX:SurvivorRatio=2 新生代内存有10m，那么eden区的内存即为5m）</p>
<p>-XX:NewRatio=老年代/新生代 设置新生代和老年代的比例（与-Xmn区别是一个是设置新生代绝对大小，一个是根据比例设置）</p>
<h1 id="堆溢出处理："><a href="#堆溢出处理：" class="headerlink" title="堆溢出处理："></a>堆溢出处理：</h1><p>-XX:+HeapDumpOnOutOfMemoryError 在内存溢出时到处整个堆信息。</p>
<p>-XX:+HeapDumpPath:d:/a.dmp 和-XX:+HeapDumpOnOutOfMemoryError配合使用，导出堆的存放路径。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/guojian731.github.io/page/2/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/guojian731.github.io/">1</a><a class="page-number" href="/guojian731.github.io/page/2/">2</a><span class="page-number current">3</span><a class="page-number" href="/guojian731.github.io/page/4/">4</a><a class="page-number" href="/guojian731.github.io/page/5/">5</a><a class="extend next" rel="next" href="/guojian731.github.io/page/4/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <p class="site-author-name" itemprop="name">Guo Jian</p>
              <p class="site-description motion-element" itemprop="description"></p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/guojian731.github.io/archives/">
              
                  <span class="site-state-item-count">44</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/guojian731.github.io/tags/index.html">
                  <span class="site-state-item-count">21</span>
                  <span class="site-state-item-name">标签</span>
                </a>
              </div>
            

          </nav>

          

          <div class="links-of-author motion-element">
            
          </div>

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Guo Jian</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.3</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/guojian731.github.io/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/guojian731.github.io/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/guojian731.github.io/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/guojian731.github.io/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/guojian731.github.io/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/guojian731.github.io/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/guojian731.github.io/js/src/utils.js?v=5.1.3"></script>

  <script type="text/javascript" src="/guojian731.github.io/js/src/motion.js?v=5.1.3"></script>



  
  


  <script type="text/javascript" src="/guojian731.github.io/js/src/affix.js?v=5.1.3"></script>

  <script type="text/javascript" src="/guojian731.github.io/js/src/schemes/pisces.js?v=5.1.3"></script>



  

  


  <script type="text/javascript" src="/guojian731.github.io/js/src/bootstrap.js?v=5.1.3"></script>



  


  




	





  





  








  





  

  

  

  

  

  

</body>
</html>
